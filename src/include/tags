!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ADDR_PARSING_H_	addr_parsing.h	11;"	d
ALLOC_HINT_FLAG_APPEND_ONLY	rados/librados.hpp	/^    ALLOC_HINT_FLAG_APPEND_ONLY = 16,$/;"	e	enum:librados::AllocHintFlags
ALLOC_HINT_FLAG_COMPRESSIBLE	rados/librados.hpp	/^    ALLOC_HINT_FLAG_COMPRESSIBLE = 256,$/;"	e	enum:librados::AllocHintFlags
ALLOC_HINT_FLAG_IMMUTABLE	rados/librados.hpp	/^    ALLOC_HINT_FLAG_IMMUTABLE = 32,$/;"	e	enum:librados::AllocHintFlags
ALLOC_HINT_FLAG_INCOMPRESSIBLE	rados/librados.hpp	/^    ALLOC_HINT_FLAG_INCOMPRESSIBLE = 512,$/;"	e	enum:librados::AllocHintFlags
ALLOC_HINT_FLAG_LONGLIVED	rados/librados.hpp	/^    ALLOC_HINT_FLAG_LONGLIVED = 128,$/;"	e	enum:librados::AllocHintFlags
ALLOC_HINT_FLAG_RANDOM_READ	rados/librados.hpp	/^    ALLOC_HINT_FLAG_RANDOM_READ = 8,$/;"	e	enum:librados::AllocHintFlags
ALLOC_HINT_FLAG_RANDOM_WRITE	rados/librados.hpp	/^    ALLOC_HINT_FLAG_RANDOM_WRITE = 2,$/;"	e	enum:librados::AllocHintFlags
ALLOC_HINT_FLAG_SEQUENTIAL_READ	rados/librados.hpp	/^    ALLOC_HINT_FLAG_SEQUENTIAL_READ = 4,$/;"	e	enum:librados::AllocHintFlags
ALLOC_HINT_FLAG_SEQUENTIAL_WRITE	rados/librados.hpp	/^    ALLOC_HINT_FLAG_SEQUENTIAL_WRITE = 1,$/;"	e	enum:librados::AllocHintFlags
ALLOC_HINT_FLAG_SHORTLIVED	rados/librados.hpp	/^    ALLOC_HINT_FLAG_SHORTLIVED = 64,$/;"	e	enum:librados::AllocHintFlags
ASSERT	error.h	24;"	d
ATTR_NAME_MISMATCH	rados/rados_types.hpp	/^    ATTR_NAME_MISMATCH    = 1 << 8,$/;"	m	struct:librados::obj_err_t	typeref:enum:librados::obj_err_t::
ATTR_VALUE_MISMATCH	rados/rados_types.hpp	/^    ATTR_VALUE_MISMATCH  = 1 << 7,$/;"	m	struct:librados::obj_err_t	typeref:enum:librados::obj_err_t::
AT_NO_ATTR_SYNC	cephfs/ceph_statx.h	69;"	d
AioCompletion	rados/librados.hpp	/^    AioCompletion(AioCompletionImpl *pc_) : pc(pc_) {}$/;"	f	struct:librados::AioCompletion
AioCompletion	rados/librados.hpp	/^  struct CEPH_RADOS_API AioCompletion {$/;"	s	namespace:librados
AioCompletion	rbd/librbd.hpp	/^  struct AioCompletion {$/;"	s	class:librbd::RBD
AllocHintFlags	rados/librados.hpp	/^  enum AllocHintFlags {$/;"	g	namespace:librados
BOOST_CHRONO_IO_TIME_POINT_IO_H	timegm.h	20;"	d
BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS	int_types.h	54;"	d
BOOST_MPL_LIMIT_MAP_SIZE	int_types.h	62;"	d
BOOST_MPL_LIMIT_VECTOR_SIZE	int_types.h	58;"	d
BUFFER_FWD_H	buffer_fwd.h	2;"	d
BUFFER_FWD_H	rados/buffer_fwd.h	2;"	d
CACHE_NEXT	elist.h	/^    MAGIC, CURRENT, CACHE_NEXT$/;"	e	enum:elist::mode_t
CEPHFS_ERROR_MESSENGER_START	cephfs/libcephfs.h	125;"	d
CEPHFS_ERROR_MON_MAP_BUILD	cephfs/libcephfs.h	123;"	d
CEPHFS_ERROR_NEW_CLIENT	cephfs/libcephfs.h	124;"	d
CEPH_AES_IV	ceph_fs.h	69;"	d
CEPH_ALLOC_PTR_H	alloc_ptr.h	16;"	d
CEPH_ASSERT_H	assert.h	2;"	d
CEPH_AUTH_CEPHX	ceph_fs.h	74;"	d
CEPH_AUTH_NONE	ceph_fs.h	73;"	d
CEPH_AUTH_UID_DEFAULT	ceph_fs.h	76;"	d
CEPH_AUTH_UNKNOWN	ceph_fs.h	72;"	d
CEPH_BANNER	msgr.h	28;"	d
CEPH_BITMAPPER_H	bitmapper.h	16;"	d
CEPH_BLOBHASH_H	blobhash.h	15;"	d
CEPH_BUFFER_API	buffer.h	/^namespace buffer CEPH_BUFFER_API {$/;"	n	namespace:ceph
CEPH_BUFFER_API	buffer.h	62;"	d
CEPH_BUFFER_API	buffer.h	64;"	d
CEPH_BUFFER_API	rados/buffer.h	/^namespace buffer CEPH_BUFFER_API {$/;"	n	namespace:ceph
CEPH_BUFFER_API	rados/buffer.h	62;"	d
CEPH_BUFFER_API	rados/buffer.h	64;"	d
CEPH_BUFFER_H	buffer.h	15;"	d
CEPH_BUFFER_H	rados/buffer.h	15;"	d
CEPH_CAP_ANY	ceph_fs.h	754;"	d
CEPH_CAP_ANY_EXCL	ceph_fs.h	745;"	d
CEPH_CAP_ANY_FILE_RD	ceph_fs.h	749;"	d
CEPH_CAP_ANY_FILE_WR	ceph_fs.h	751;"	d
CEPH_CAP_ANY_RD	ceph_fs.h	742;"	d
CEPH_CAP_ANY_SHARED	ceph_fs.h	738;"	d
CEPH_CAP_ANY_WR	ceph_fs.h	753;"	d
CEPH_CAP_AUTH_EXCL	ceph_fs.h	701;"	d
CEPH_CAP_AUTH_SHARED	ceph_fs.h	700;"	d
CEPH_CAP_FILE	ceph_fs.h	706;"	d
CEPH_CAP_FILE_BITS	ceph_fs.h	691;"	d
CEPH_CAP_FILE_BUFFER	ceph_fs.h	712;"	d
CEPH_CAP_FILE_CACHE	ceph_fs.h	709;"	d
CEPH_CAP_FILE_EXCL	ceph_fs.h	708;"	d
CEPH_CAP_FILE_LAZYIO	ceph_fs.h	714;"	d
CEPH_CAP_FILE_RD	ceph_fs.h	710;"	d
CEPH_CAP_FILE_SHARED	ceph_fs.h	707;"	d
CEPH_CAP_FILE_WR	ceph_fs.h	711;"	d
CEPH_CAP_FILE_WREXTEND	ceph_fs.h	713;"	d
CEPH_CAP_FLAG_AUTH	ceph_fs.h	627;"	d
CEPH_CAP_FLAG_RELEASE	ceph_fs.h	628;"	d
CEPH_CAP_GBUFFER	ceph_fs.h	686;"	d
CEPH_CAP_GCACHE	ceph_fs.h	683;"	d
CEPH_CAP_GEXCL	ceph_fs.h	682;"	d
CEPH_CAP_GLAZYIO	ceph_fs.h	688;"	d
CEPH_CAP_GRD	ceph_fs.h	684;"	d
CEPH_CAP_GSHARED	ceph_fs.h	681;"	d
CEPH_CAP_GWR	ceph_fs.h	685;"	d
CEPH_CAP_GWREXTEND	ceph_fs.h	687;"	d
CEPH_CAP_LINK_EXCL	ceph_fs.h	703;"	d
CEPH_CAP_LINK_SHARED	ceph_fs.h	702;"	d
CEPH_CAP_LOCKS	ceph_fs.h	758;"	d
CEPH_CAP_OP_DROP	ceph_fs.h	/^	CEPH_CAP_OP_DROP,          \/* client->mds drop cap bits *\/$/;"	e	enum:__anon65
CEPH_CAP_OP_EXPORT	ceph_fs.h	/^	CEPH_CAP_OP_EXPORT,        \/* mds has exported the cap *\/$/;"	e	enum:__anon65
CEPH_CAP_OP_FLUSH	ceph_fs.h	/^	CEPH_CAP_OP_FLUSH,         \/* client->mds cap writeback *\/$/;"	e	enum:__anon65
CEPH_CAP_OP_FLUSHSNAP	ceph_fs.h	/^	CEPH_CAP_OP_FLUSHSNAP,     \/* client->mds flush snapped metadata *\/$/;"	e	enum:__anon65
CEPH_CAP_OP_FLUSHSNAP_ACK	ceph_fs.h	/^	CEPH_CAP_OP_FLUSHSNAP_ACK, \/* mds->client flushed snapped metadata *\/$/;"	e	enum:__anon65
CEPH_CAP_OP_FLUSH_ACK	ceph_fs.h	/^	CEPH_CAP_OP_FLUSH_ACK,     \/* mds->client flushed *\/$/;"	e	enum:__anon65
CEPH_CAP_OP_GRANT	ceph_fs.h	/^	CEPH_CAP_OP_GRANT,         \/* mds->client grant *\/$/;"	e	enum:__anon65
CEPH_CAP_OP_IMPORT	ceph_fs.h	/^	CEPH_CAP_OP_IMPORT,        \/* mds has imported the cap *\/$/;"	e	enum:__anon65
CEPH_CAP_OP_RELEASE	ceph_fs.h	/^	CEPH_CAP_OP_RELEASE,       \/* client->mds release (clean) cap *\/$/;"	e	enum:__anon65
CEPH_CAP_OP_RENEW	ceph_fs.h	/^	CEPH_CAP_OP_RENEW,         \/* client->mds renewal request *\/$/;"	e	enum:__anon65
CEPH_CAP_OP_REVOKE	ceph_fs.h	/^	CEPH_CAP_OP_REVOKE,        \/* mds->client revoke *\/$/;"	e	enum:__anon65
CEPH_CAP_OP_TRUNC	ceph_fs.h	/^	CEPH_CAP_OP_TRUNC,         \/* mds->client trunc notify *\/$/;"	e	enum:__anon65
CEPH_CAP_OP_UPDATE	ceph_fs.h	/^	CEPH_CAP_OP_UPDATE,        \/* client->mds update *\/$/;"	e	enum:__anon65
CEPH_CAP_PIN	ceph_fs.h	678;"	d
CEPH_CAP_SAUTH	ceph_fs.h	694;"	d
CEPH_CAP_SFILE	ceph_fs.h	697;"	d
CEPH_CAP_SIMPLE_BITS	ceph_fs.h	690;"	d
CEPH_CAP_SLINK	ceph_fs.h	695;"	d
CEPH_CAP_SXATTR	ceph_fs.h	696;"	d
CEPH_CAP_XATTR_EXCL	ceph_fs.h	705;"	d
CEPH_CAP_XATTR_SHARED	ceph_fs.h	704;"	d
CEPH_CEPH_STATX_H	cephfs/ceph_statx.h	18;"	d
CEPH_COLOR_H	color.h	2;"	d
CEPH_COMMON_EVENT_TYPE_H	event_type.h	18;"	d
CEPH_COMPACT_MAP_H	compact_map.h	13;"	d
CEPH_COMPACT_SET_H	compact_set.h	13;"	d
CEPH_COMPATSET_H	CompatSet.h	16;"	d
CEPH_COMPAT_H	compat.h	13;"	d
CEPH_CONTEXT_H	Context.h	17;"	d
CEPH_COUNTER_H	counter.h	16;"	d
CEPH_CRC32C_H	crc32c.h	2;"	d
CEPH_CRC32C_H	rados/crc32c.h	2;"	d
CEPH_CRYPTO_AES	ceph_fs.h	67;"	d
CEPH_CRYPTO_NONE	ceph_fs.h	66;"	d
CEPH_DELEGATION_NONE	cephfs/libcephfs.h	1604;"	d
CEPH_DELEGATION_RD	cephfs/libcephfs.h	1605;"	d
CEPH_DELEGATION_WR	cephfs/libcephfs.h	1606;"	d
CEPH_DISTRIBUTION_H	Distribution.h	17;"	d
CEPH_ELIST_H	elist.h	16;"	d
CEPH_ENCODING_H	encoding.h	15;"	d
CEPH_ENTITY_TYPE_ANY	msgr.h	58;"	d
CEPH_ENTITY_TYPE_AUTH	msgr.h	56;"	d
CEPH_ENTITY_TYPE_CLIENT	msgr.h	54;"	d
CEPH_ENTITY_TYPE_MDS	msgr.h	52;"	d
CEPH_ENTITY_TYPE_MGR	msgr.h	55;"	d
CEPH_ENTITY_TYPE_MON	msgr.h	51;"	d
CEPH_ENTITY_TYPE_OSD	msgr.h	53;"	d
CEPH_ERR_H	err.h	2;"	d
CEPH_FEATURES_ALL	ceph_features.h	175;"	d
CEPH_FEATURES_CRUSH	ceph_features.h	241;"	d
CEPH_FEATURES_SUPPORTED_DEFAULT	ceph_features.h	236;"	d
CEPH_FEATURE_INCARNATION_1	ceph_features.h	11;"	d
CEPH_FEATURE_INCARNATION_2	ceph_features.h	12;"	d
CEPH_FILEPATH_H	filepath.h	17;"	d
CEPH_FILE_MODE_LAZY	ceph_fs.h	668;"	d
CEPH_FILE_MODE_NUM	ceph_fs.h	669;"	d
CEPH_FILE_MODE_PIN	ceph_fs.h	664;"	d
CEPH_FILE_MODE_RD	ceph_fs.h	665;"	d
CEPH_FILE_MODE_RDWR	ceph_fs.h	667;"	d
CEPH_FILE_MODE_WR	ceph_fs.h	666;"	d
CEPH_FRAG_H	frag.h	16;"	d
CEPH_FS_H	ceph_fs.h	13;"	d
CEPH_HASH_H	hash.h	2;"	d
CEPH_INCLUDE_BTREE_MAP_H	btree_map.h	5;"	d
CEPH_INCLUDE_DEMANGLE	demangle.h	16;"	d
CEPH_INCLUDE_FS_TYPES_H	fs_types.h	4;"	d
CEPH_INLINE_MAX_SIZE	ceph_fs.h	675;"	d
CEPH_INLINE_MEMORY_H	inline_memory.h	15;"	d
CEPH_INLINE_MEMORY_H	rados/inline_memory.h	15;"	d
CEPH_INLINE_NONE	ceph_fs.h	674;"	d
CEPH_INO_CEPH	ceph_fs.h	30;"	d
CEPH_INO_LOST_AND_FOUND	ceph_fs.h	31;"	d
CEPH_INO_ROOT	ceph_fs.h	29;"	d
CEPH_INO_ROOT	cephfs/libcephfs.h	57;"	d
CEPH_INTARITH_H	intarith.h	16;"	d
CEPH_INTERVAL_SET_H	interval_set.h	17;"	d
CEPH_INTTYPES_H	int_types.h	2;"	d
CEPH_IPADDR_H	ipaddr.h	2;"	d
CEPH_KRBD_H	krbd.h	14;"	d
CEPH_LIBRADOSSTRIPER_H	radosstriper/libradosstriper.h	2;"	d
CEPH_LIBRADOS_H	rados/librados.h	16;"	d
CEPH_LIBRBD_H	rbd/librbd.h	16;"	d
CEPH_LIBRGW_H	rados/librgw.h	15;"	d
CEPH_LIB_H	cephfs/libcephfs.h	16;"	d
CEPH_LOCK_DN	ceph_fs.h	280;"	d
CEPH_LOCK_DVERSION	ceph_fs.h	279;"	d
CEPH_LOCK_EXCL	ceph_fs.h	650;"	d
CEPH_LOCK_FCNTL	ceph_fs.h	644;"	d
CEPH_LOCK_FCNTL_INTR	ceph_fs.h	646;"	d
CEPH_LOCK_FLOCK	ceph_fs.h	645;"	d
CEPH_LOCK_FLOCK_INTR	ceph_fs.h	647;"	d
CEPH_LOCK_IAUTH	ceph_fs.h	284;"	d
CEPH_LOCK_IDFT	ceph_fs.h	286;"	d
CEPH_LOCK_IFILE	ceph_fs.h	283;"	d
CEPH_LOCK_IFLOCK	ceph_fs.h	289;"	d
CEPH_LOCK_ILINK	ceph_fs.h	285;"	d
CEPH_LOCK_INEST	ceph_fs.h	287;"	d
CEPH_LOCK_INO	ceph_fs.h	290;"	d
CEPH_LOCK_IPOLICY	ceph_fs.h	291;"	d
CEPH_LOCK_ISNAP	ceph_fs.h	281;"	d
CEPH_LOCK_IVERSION	ceph_fs.h	282;"	d
CEPH_LOCK_IXATTR	ceph_fs.h	288;"	d
CEPH_LOCK_SHARED	ceph_fs.h	649;"	d
CEPH_LOCK_UNLOCK	ceph_fs.h	651;"	d
CEPH_LRU_H	lru.h	18;"	d
CEPH_MAXSNAP	rados.h	30;"	d
CEPH_MAX_MON	ceph_fs.h	34;"	d
CEPH_MDSC_PROTOCOL	ceph_fs.h	25;"	d
CEPH_MDSMAP_ALLOW_CLASSICS	ceph_fs.h	239;"	d
CEPH_MDSMAP_ALLOW_DIRFRAGS	ceph_fs.h	237;"	d
CEPH_MDSMAP_ALLOW_MULTIMDS	ceph_fs.h	236;"	d
CEPH_MDSMAP_ALLOW_SNAPS	ceph_fs.h	235;"	d
CEPH_MDSMAP_DEFAULTS	ceph_fs.h	242;"	d
CEPH_MDSMAP_DOWN	ceph_fs.h	234;"	d
CEPH_MDS_FLAG_REPLAY	ceph_fs.h	478;"	d
CEPH_MDS_FLAG_WANT_DENTRY	ceph_fs.h	479;"	d
CEPH_MDS_LEASE_RELEASE	ceph_fs.h	842;"	d
CEPH_MDS_LEASE_RENEW	ceph_fs.h	843;"	d
CEPH_MDS_LEASE_REVOKE	ceph_fs.h	841;"	d
CEPH_MDS_LEASE_REVOKE_ACK	ceph_fs.h	844;"	d
CEPH_MDS_OP_CREATE	ceph_fs.h	/^	CEPH_MDS_OP_CREATE     = 0x01301,$/;"	e	enum:__anon46
CEPH_MDS_OP_ENQUEUE_SCRUB	ceph_fs.h	/^	CEPH_MDS_OP_ENQUEUE_SCRUB  = 0x01503,$/;"	e	enum:__anon46
CEPH_MDS_OP_EXPORTDIR	ceph_fs.h	/^	CEPH_MDS_OP_EXPORTDIR  = 0x01501,$/;"	e	enum:__anon46
CEPH_MDS_OP_FLUSH	ceph_fs.h	/^	CEPH_MDS_OP_FLUSH      = 0x01502,$/;"	e	enum:__anon46
CEPH_MDS_OP_FRAGMENTDIR	ceph_fs.h	/^	CEPH_MDS_OP_FRAGMENTDIR= 0x01500,$/;"	e	enum:__anon46
CEPH_MDS_OP_GETATTR	ceph_fs.h	/^	CEPH_MDS_OP_GETATTR    = 0x00101,$/;"	e	enum:__anon46
CEPH_MDS_OP_GETFILELOCK	ceph_fs.h	/^	CEPH_MDS_OP_GETFILELOCK= 0x00110,$/;"	e	enum:__anon46
CEPH_MDS_OP_LINK	ceph_fs.h	/^	CEPH_MDS_OP_LINK       = 0x01202,$/;"	e	enum:__anon46
CEPH_MDS_OP_LOOKUP	ceph_fs.h	/^	CEPH_MDS_OP_LOOKUP     = 0x00100,$/;"	e	enum:__anon46
CEPH_MDS_OP_LOOKUPHASH	ceph_fs.h	/^	CEPH_MDS_OP_LOOKUPHASH = 0x00102,$/;"	e	enum:__anon46
CEPH_MDS_OP_LOOKUPINO	ceph_fs.h	/^	CEPH_MDS_OP_LOOKUPINO  = 0x00104,$/;"	e	enum:__anon46
CEPH_MDS_OP_LOOKUPNAME	ceph_fs.h	/^	CEPH_MDS_OP_LOOKUPNAME = 0x00105,$/;"	e	enum:__anon46
CEPH_MDS_OP_LOOKUPPARENT	ceph_fs.h	/^	CEPH_MDS_OP_LOOKUPPARENT = 0x00103,$/;"	e	enum:__anon46
CEPH_MDS_OP_LOOKUPSNAP	ceph_fs.h	/^	CEPH_MDS_OP_LOOKUPSNAP = 0x00400,$/;"	e	enum:__anon46
CEPH_MDS_OP_LSSNAP	ceph_fs.h	/^	CEPH_MDS_OP_LSSNAP     = 0x00402,$/;"	e	enum:__anon46
CEPH_MDS_OP_MKDIR	ceph_fs.h	/^	CEPH_MDS_OP_MKDIR      = 0x01220,$/;"	e	enum:__anon46
CEPH_MDS_OP_MKNOD	ceph_fs.h	/^	CEPH_MDS_OP_MKNOD      = 0x01201,$/;"	e	enum:__anon46
CEPH_MDS_OP_MKSNAP	ceph_fs.h	/^	CEPH_MDS_OP_MKSNAP     = 0x01400,$/;"	e	enum:__anon46
CEPH_MDS_OP_OPEN	ceph_fs.h	/^	CEPH_MDS_OP_OPEN       = 0x00302,$/;"	e	enum:__anon46
CEPH_MDS_OP_READDIR	ceph_fs.h	/^	CEPH_MDS_OP_READDIR    = 0x00305,$/;"	e	enum:__anon46
CEPH_MDS_OP_RENAME	ceph_fs.h	/^	CEPH_MDS_OP_RENAME     = 0x01204,$/;"	e	enum:__anon46
CEPH_MDS_OP_RENAMESNAP	ceph_fs.h	/^	CEPH_MDS_OP_RENAMESNAP = 0x01403,$/;"	e	enum:__anon46
CEPH_MDS_OP_REPAIR_FRAGSTATS	ceph_fs.h	/^	CEPH_MDS_OP_REPAIR_FRAGSTATS = 0x01504,$/;"	e	enum:__anon46
CEPH_MDS_OP_REPAIR_INODESTATS	ceph_fs.h	/^	CEPH_MDS_OP_REPAIR_INODESTATS = 0x01505$/;"	e	enum:__anon46
CEPH_MDS_OP_RMDIR	ceph_fs.h	/^	CEPH_MDS_OP_RMDIR      = 0x01221,$/;"	e	enum:__anon46
CEPH_MDS_OP_RMSNAP	ceph_fs.h	/^	CEPH_MDS_OP_RMSNAP     = 0x01401,$/;"	e	enum:__anon46
CEPH_MDS_OP_RMXATTR	ceph_fs.h	/^	CEPH_MDS_OP_RMXATTR    = 0x01106,$/;"	e	enum:__anon46
CEPH_MDS_OP_SETATTR	ceph_fs.h	/^	CEPH_MDS_OP_SETATTR    = 0x01108,$/;"	e	enum:__anon46
CEPH_MDS_OP_SETDIRLAYOUT	ceph_fs.h	/^	CEPH_MDS_OP_SETDIRLAYOUT=0x0110a,$/;"	e	enum:__anon46
CEPH_MDS_OP_SETFILELOCK	ceph_fs.h	/^	CEPH_MDS_OP_SETFILELOCK= 0x01109,$/;"	e	enum:__anon46
CEPH_MDS_OP_SETLAYOUT	ceph_fs.h	/^	CEPH_MDS_OP_SETLAYOUT  = 0x01107,$/;"	e	enum:__anon46
CEPH_MDS_OP_SETXATTR	ceph_fs.h	/^	CEPH_MDS_OP_SETXATTR   = 0x01105,$/;"	e	enum:__anon46
CEPH_MDS_OP_SYMLINK	ceph_fs.h	/^	CEPH_MDS_OP_SYMLINK    = 0x01222,$/;"	e	enum:__anon46
CEPH_MDS_OP_UNLINK	ceph_fs.h	/^	CEPH_MDS_OP_UNLINK     = 0x01203,$/;"	e	enum:__anon46
CEPH_MDS_OP_WRITE	ceph_fs.h	328;"	d
CEPH_MDS_REQUEST_HEAD_VERSION	ceph_fs.h	554;"	d
CEPH_MDS_STATE_ACTIVE	ceph_fs.h	266;"	d
CEPH_MDS_STATE_BOOT	ceph_fs.h	252;"	d
CEPH_MDS_STATE_CLIENTREPLAY	ceph_fs.h	265;"	d
CEPH_MDS_STATE_CREATING	ceph_fs.h	254;"	d
CEPH_MDS_STATE_DAMAGED	ceph_fs.h	268;"	d
CEPH_MDS_STATE_DNE	ceph_fs.h	249;"	d
CEPH_MDS_STATE_NULL	ceph_fs.h	258;"	d
CEPH_MDS_STATE_RECONNECT	ceph_fs.h	263;"	d
CEPH_MDS_STATE_REJOIN	ceph_fs.h	264;"	d
CEPH_MDS_STATE_REPLAY	ceph_fs.h	260;"	d
CEPH_MDS_STATE_REPLAYONCE	ceph_fs.h	257;"	d
CEPH_MDS_STATE_RESOLVE	ceph_fs.h	261;"	d
CEPH_MDS_STATE_STANDBY	ceph_fs.h	253;"	d
CEPH_MDS_STATE_STANDBY_REPLAY	ceph_fs.h	256;"	d
CEPH_MDS_STATE_STARTING	ceph_fs.h	255;"	d
CEPH_MDS_STATE_STOPPED	ceph_fs.h	250;"	d
CEPH_MDS_STATE_STOPPING	ceph_fs.h	267;"	d
CEPH_MEMORY_H	memory.h	2;"	d
CEPH_MEMORY_H	rados/memory.h	2;"	d
CEPH_MIN_STRIPE_UNIT	ceph_fs.h	56;"	d
CEPH_MONC_PROTOCOL	ceph_fs.h	26;"	d
CEPH_MON_PORT	msgr.h	14;"	d
CEPH_MSGR_H	msgr.h	2;"	d
CEPH_MSGR_TAG_ACK	msgr.h	88;"	d
CEPH_MSGR_TAG_BADAUTHORIZER	msgr.h	91;"	d
CEPH_MSGR_TAG_BADPROTOVER	msgr.h	90;"	d
CEPH_MSGR_TAG_CHALLENGE_AUTHORIZER	msgr.h	96;"	d
CEPH_MSGR_TAG_CLOSE	msgr.h	86;"	d
CEPH_MSGR_TAG_FEATURES	msgr.h	92;"	d
CEPH_MSGR_TAG_KEEPALIVE	msgr.h	89;"	d
CEPH_MSGR_TAG_KEEPALIVE2	msgr.h	94;"	d
CEPH_MSGR_TAG_KEEPALIVE2_ACK	msgr.h	95;"	d
CEPH_MSGR_TAG_MSG	msgr.h	87;"	d
CEPH_MSGR_TAG_READY	msgr.h	78;"	d
CEPH_MSGR_TAG_RESETSESSION	msgr.h	79;"	d
CEPH_MSGR_TAG_RETRY_GLOBAL	msgr.h	84;"	d
CEPH_MSGR_TAG_RETRY_SESSION	msgr.h	82;"	d
CEPH_MSGR_TAG_SEQ	msgr.h	93;"	d
CEPH_MSGR_TAG_WAIT	msgr.h	80;"	d
CEPH_MSG_AUTH	ceph_fs.h	100;"	d
CEPH_MSG_AUTH_REPLY	ceph_fs.h	101;"	d
CEPH_MSG_CLIENT_CAPRELEASE	ceph_fs.h	117;"	d
CEPH_MSG_CLIENT_CAPS	ceph_fs.h	114;"	d
CEPH_MSG_CLIENT_LEASE	ceph_fs.h	115;"	d
CEPH_MSG_CLIENT_QUOTA	ceph_fs.h	118;"	d
CEPH_MSG_CLIENT_RECONNECT	ceph_fs.h	109;"	d
CEPH_MSG_CLIENT_REPLY	ceph_fs.h	113;"	d
CEPH_MSG_CLIENT_REQUEST	ceph_fs.h	111;"	d
CEPH_MSG_CLIENT_REQUEST_FORWARD	ceph_fs.h	112;"	d
CEPH_MSG_CLIENT_SESSION	ceph_fs.h	108;"	d
CEPH_MSG_CLIENT_SNAP	ceph_fs.h	116;"	d
CEPH_MSG_CONNECT_LOSSY	msgr.h	122;"	d
CEPH_MSG_FOOTER_COMPLETE	msgr.h	189;"	d
CEPH_MSG_FOOTER_NOCRC	msgr.h	190;"	d
CEPH_MSG_FOOTER_SIGNED	msgr.h	191;"	d
CEPH_MSG_FS_MAP	ceph_fs.h	133;"	d
CEPH_MSG_FS_MAP_USER	ceph_fs.h	135;"	d
CEPH_MSG_MDS_MAP	ceph_fs.h	106;"	d
CEPH_MSG_MON_GET_MAP	ceph_fs.h	93;"	d
CEPH_MSG_MON_GET_OSDMAP	ceph_fs.h	94;"	d
CEPH_MSG_MON_GET_VERSION	ceph_fs.h	102;"	d
CEPH_MSG_MON_GET_VERSION_REPLY	ceph_fs.h	103;"	d
CEPH_MSG_MON_MAP	ceph_fs.h	92;"	d
CEPH_MSG_MON_METADATA	ceph_fs.h	95;"	d
CEPH_MSG_MON_SUBSCRIBE	ceph_fs.h	98;"	d
CEPH_MSG_MON_SUBSCRIBE_ACK	ceph_fs.h	99;"	d
CEPH_MSG_OSD_BACKOFF	ceph_fs.h	130;"	d
CEPH_MSG_OSD_MAP	ceph_fs.h	126;"	d
CEPH_MSG_OSD_OP	ceph_fs.h	127;"	d
CEPH_MSG_OSD_OPREPLY	ceph_fs.h	128;"	d
CEPH_MSG_PING	ceph_fs.h	89;"	d
CEPH_MSG_POOLOP	ceph_fs.h	122;"	d
CEPH_MSG_POOLOP_REPLY	ceph_fs.h	121;"	d
CEPH_MSG_PRIO_DEFAULT	msgr.h	168;"	d
CEPH_MSG_PRIO_HIGH	msgr.h	169;"	d
CEPH_MSG_PRIO_HIGHEST	msgr.h	170;"	d
CEPH_MSG_PRIO_LOW	msgr.h	167;"	d
CEPH_MSG_SHUTDOWN	ceph_fs.h	88;"	d
CEPH_MSG_STATFS	ceph_fs.h	96;"	d
CEPH_MSG_STATFS_REPLY	ceph_fs.h	97;"	d
CEPH_MSG_WATCH_NOTIFY	ceph_fs.h	129;"	d
CEPH_NOSNAP	cephfs/libcephfs.h	58;"	d
CEPH_NOSNAP	rados.h	29;"	d
CEPH_OBJCLASS_OBJCLASS_PUBLIC_H	rados/objclass.h	5;"	d
CEPH_OBJECT_H	object.h	16;"	d
CEPH_OBJECT_LAYOUT_HASH	rados.h	41;"	d
CEPH_OBJECT_LAYOUT_HASHINO	rados.h	43;"	d
CEPH_OBJECT_LAYOUT_LINEAR	rados.h	42;"	d
CEPH_ON_EXIT_H	on_exit.h	2;"	d
CEPH_OSDC_PROTOCOL	ceph_fs.h	24;"	d
CEPH_OSDMAP_FULL	rados.h	140;"	d
CEPH_OSDMAP_LEGACY_REQUIRE_FLAGS	rados.h	168;"	d
CEPH_OSDMAP_NEARFULL	rados.h	139;"	d
CEPH_OSDMAP_NOBACKFILL	rados.h	148;"	d
CEPH_OSDMAP_NODEEP_SCRUB	rados.h	151;"	d
CEPH_OSDMAP_NODOWN	rados.h	145;"	d
CEPH_OSDMAP_NOIN	rados.h	147;"	d
CEPH_OSDMAP_NOOUT	rados.h	146;"	d
CEPH_OSDMAP_NOREBALANCE	rados.h	153;"	d
CEPH_OSDMAP_NORECOVER	rados.h	149;"	d
CEPH_OSDMAP_NOSCRUB	rados.h	150;"	d
CEPH_OSDMAP_NOTIERAGENT	rados.h	152;"	d
CEPH_OSDMAP_NOUP	rados.h	144;"	d
CEPH_OSDMAP_PAUSERD	rados.h	141;"	d
CEPH_OSDMAP_PAUSEREC	rados.h	143;"	d
CEPH_OSDMAP_PAUSEWR	rados.h	142;"	d
CEPH_OSDMAP_PURGED_SNAPDIRS	rados.h	159;"	d
CEPH_OSDMAP_RECOVERY_DELETES	rados.h	158;"	d
CEPH_OSDMAP_REQUIRE_JEWEL	rados.h	155;"	d
CEPH_OSDMAP_REQUIRE_KRAKEN	rados.h	156;"	d
CEPH_OSDMAP_REQUIRE_LUMINOUS	rados.h	157;"	d
CEPH_OSDMAP_SEMIHIDDEN_FLAGS	rados.h	162;"	d
CEPH_OSDMAP_SORTBITWISE	rados.h	154;"	d
CEPH_OSD_ALLOC_HINT_FLAG_APPEND_ONLY	rados.h	/^	CEPH_OSD_ALLOC_HINT_FLAG_APPEND_ONLY = 16,$/;"	e	enum:__anon11
CEPH_OSD_ALLOC_HINT_FLAG_COMPRESSIBLE	rados.h	/^	CEPH_OSD_ALLOC_HINT_FLAG_COMPRESSIBLE = 256,$/;"	e	enum:__anon11
CEPH_OSD_ALLOC_HINT_FLAG_IMMUTABLE	rados.h	/^	CEPH_OSD_ALLOC_HINT_FLAG_IMMUTABLE = 32,$/;"	e	enum:__anon11
CEPH_OSD_ALLOC_HINT_FLAG_INCOMPRESSIBLE	rados.h	/^	CEPH_OSD_ALLOC_HINT_FLAG_INCOMPRESSIBLE = 512,$/;"	e	enum:__anon11
CEPH_OSD_ALLOC_HINT_FLAG_LONGLIVED	rados.h	/^	CEPH_OSD_ALLOC_HINT_FLAG_LONGLIVED = 128,$/;"	e	enum:__anon11
CEPH_OSD_ALLOC_HINT_FLAG_RANDOM_READ	rados.h	/^	CEPH_OSD_ALLOC_HINT_FLAG_RANDOM_READ = 8,$/;"	e	enum:__anon11
CEPH_OSD_ALLOC_HINT_FLAG_RANDOM_WRITE	rados.h	/^	CEPH_OSD_ALLOC_HINT_FLAG_RANDOM_WRITE = 2,$/;"	e	enum:__anon11
CEPH_OSD_ALLOC_HINT_FLAG_SEQUENTIAL_READ	rados.h	/^	CEPH_OSD_ALLOC_HINT_FLAG_SEQUENTIAL_READ = 4,$/;"	e	enum:__anon11
CEPH_OSD_ALLOC_HINT_FLAG_SEQUENTIAL_WRITE	rados.h	/^	CEPH_OSD_ALLOC_HINT_FLAG_SEQUENTIAL_WRITE = 1,$/;"	e	enum:__anon11
CEPH_OSD_ALLOC_HINT_FLAG_SHORTLIVED	rados.h	/^	CEPH_OSD_ALLOC_HINT_FLAG_SHORTLIVED = 64,$/;"	e	enum:__anon11
CEPH_OSD_AUTOOUT	rados.h	115;"	d
CEPH_OSD_BACKFILLFULL	rados.h	119;"	d
CEPH_OSD_BACKOFF_OP_ACK_BLOCK	rados.h	/^	CEPH_OSD_BACKOFF_OP_ACK_BLOCK = 2,$/;"	e	enum:__anon12
CEPH_OSD_BACKOFF_OP_BLOCK	rados.h	/^	CEPH_OSD_BACKOFF_OP_BLOCK = 1,$/;"	e	enum:__anon12
CEPH_OSD_BACKOFF_OP_UNBLOCK	rados.h	/^	CEPH_OSD_BACKOFF_OP_UNBLOCK = 3,$/;"	e	enum:__anon12
CEPH_OSD_CHECKSUM_OP_TYPE_CRC32C	rados.h	/^	CEPH_OSD_CHECKSUM_OP_TYPE_CRC32C   = 2$/;"	e	enum:__anon10
CEPH_OSD_CHECKSUM_OP_TYPE_XXHASH32	rados.h	/^	CEPH_OSD_CHECKSUM_OP_TYPE_XXHASH32 = 0,$/;"	e	enum:__anon10
CEPH_OSD_CHECKSUM_OP_TYPE_XXHASH64	rados.h	/^	CEPH_OSD_CHECKSUM_OP_TYPE_XXHASH64 = 1,$/;"	e	enum:__anon10
CEPH_OSD_CMPXATTR_MODE_STRING	rados.h	/^	CEPH_OSD_CMPXATTR_MODE_STRING = 1,$/;"	e	enum:__anon6
CEPH_OSD_CMPXATTR_MODE_U64	rados.h	/^	CEPH_OSD_CMPXATTR_MODE_U64    = 2$/;"	e	enum:__anon6
CEPH_OSD_CMPXATTR_OP_EQ	rados.h	/^	CEPH_OSD_CMPXATTR_OP_EQ  = 1,$/;"	e	enum:__anon5
CEPH_OSD_CMPXATTR_OP_GT	rados.h	/^	CEPH_OSD_CMPXATTR_OP_GT  = 3,$/;"	e	enum:__anon5
CEPH_OSD_CMPXATTR_OP_GTE	rados.h	/^	CEPH_OSD_CMPXATTR_OP_GTE = 4,$/;"	e	enum:__anon5
CEPH_OSD_CMPXATTR_OP_LT	rados.h	/^	CEPH_OSD_CMPXATTR_OP_LT  = 5,$/;"	e	enum:__anon5
CEPH_OSD_CMPXATTR_OP_LTE	rados.h	/^	CEPH_OSD_CMPXATTR_OP_LTE = 6$/;"	e	enum:__anon5
CEPH_OSD_CMPXATTR_OP_NE	rados.h	/^	CEPH_OSD_CMPXATTR_OP_NE  = 2,$/;"	e	enum:__anon5
CEPH_OSD_COPY_FROM_FLAG_FLUSH	rados.h	/^	CEPH_OSD_COPY_FROM_FLAG_FLUSH = 1,     \/* part of a flush operation *\/$/;"	e	enum:__anon7
CEPH_OSD_COPY_FROM_FLAG_IGNORE_CACHE	rados.h	/^	CEPH_OSD_COPY_FROM_FLAG_IGNORE_CACHE = 4, \/* ignore osd cache logic *\/$/;"	e	enum:__anon7
CEPH_OSD_COPY_FROM_FLAG_IGNORE_OVERLAY	rados.h	/^	CEPH_OSD_COPY_FROM_FLAG_IGNORE_OVERLAY = 2,  \/* ignore pool overlay *\/$/;"	e	enum:__anon7
CEPH_OSD_COPY_FROM_FLAG_MAP_SNAP_CLONE	rados.h	/^	CEPH_OSD_COPY_FROM_FLAG_MAP_SNAP_CLONE = 8, \/* map snap direct to$/;"	e	enum:__anon7
CEPH_OSD_COPY_FROM_FLAG_RWORDERED	rados.h	/^	CEPH_OSD_COPY_FROM_FLAG_RWORDERED = 16, \/* order with write *\/$/;"	e	enum:__anon7
CEPH_OSD_DEFAULT_PRIMARY_AFFINITY	rados.h	133;"	d
CEPH_OSD_DESTROYED	rados.h	120;"	d
CEPH_OSD_EXISTS	rados.h	113;"	d
CEPH_OSD_FLAG_ACK	rados.h	/^	CEPH_OSD_FLAG_ACK =            0x0001,  \/* want (or is) "ack" ack *\/$/;"	e	enum:__anon3
CEPH_OSD_FLAG_BALANCE_READS	rados.h	/^	CEPH_OSD_FLAG_BALANCE_READS =  0x0100,$/;"	e	enum:__anon3
CEPH_OSD_FLAG_ENFORCE_SNAPC	rados.h	/^	CEPH_OSD_FLAG_ENFORCE_SNAPC    =0x100000,  \/* use snapc provided even if$/;"	e	enum:__anon3
CEPH_OSD_FLAG_EXEC	rados.h	/^	CEPH_OSD_FLAG_EXEC =           0x0800,  \/* op may exec *\/$/;"	e	enum:__anon3
CEPH_OSD_FLAG_EXEC_PUBLIC	rados.h	/^	CEPH_OSD_FLAG_EXEC_PUBLIC =    0x1000,  \/* DEPRECATED op may exec (public) *\/$/;"	e	enum:__anon3
CEPH_OSD_FLAG_FLUSH	rados.h	/^	CEPH_OSD_FLAG_FLUSH =         0x40000,  \/* this is part of flush *\/$/;"	e	enum:__anon3
CEPH_OSD_FLAG_FULL_FORCE	rados.h	/^	CEPH_OSD_FLAG_FULL_FORCE = 0x1000000,  \/* force op despite full flag *\/$/;"	e	enum:__anon3
CEPH_OSD_FLAG_FULL_TRY	rados.h	/^	CEPH_OSD_FLAG_FULL_TRY =    0x800000,  \/* try op despite full flag *\/$/;"	e	enum:__anon3
CEPH_OSD_FLAG_IGNORE_CACHE	rados.h	/^	CEPH_OSD_FLAG_IGNORE_CACHE =   0x8000,  \/* ignore cache logic *\/$/;"	e	enum:__anon3
CEPH_OSD_FLAG_IGNORE_OVERLAY	rados.h	/^	CEPH_OSD_FLAG_IGNORE_OVERLAY =0x20000,  \/* ignore pool overlay *\/$/;"	e	enum:__anon3
CEPH_OSD_FLAG_IGNORE_REDIRECT	rados.h	/^	CEPH_OSD_FLAG_IGNORE_REDIRECT = 0x2000000,  \/* ignore redirection *\/$/;"	e	enum:__anon3
CEPH_OSD_FLAG_KNOWN_REDIR	rados.h	/^	CEPH_OSD_FLAG_KNOWN_REDIR = 0x400000,  \/* redirect bit is authoritative *\/$/;"	e	enum:__anon3
CEPH_OSD_FLAG_LOCALIZE_READS	rados.h	/^	CEPH_OSD_FLAG_LOCALIZE_READS = 0x2000,  \/* read from nearby replica, if any *\/$/;"	e	enum:__anon3
CEPH_OSD_FLAG_MAP_SNAP_CLONE	rados.h	/^	CEPH_OSD_FLAG_MAP_SNAP_CLONE =0x80000,  \/* map snap direct to clone id$/;"	e	enum:__anon3
CEPH_OSD_FLAG_ONDISK	rados.h	/^	CEPH_OSD_FLAG_ONDISK =         0x0004,  \/* want (or is) "ondisk" ack *\/$/;"	e	enum:__anon3
CEPH_OSD_FLAG_ONNVRAM	rados.h	/^	CEPH_OSD_FLAG_ONNVRAM =        0x0002,  \/* want (or is) "onnvram" ack *\/$/;"	e	enum:__anon3
CEPH_OSD_FLAG_ORDERSNAP	rados.h	/^	CEPH_OSD_FLAG_ORDERSNAP =      0x0040,  \/* EOLDSNAP if snapc is out of order *\/$/;"	e	enum:__anon3
CEPH_OSD_FLAG_PARALLELEXEC	rados.h	/^	CEPH_OSD_FLAG_PARALLELEXEC =   0x0200,  \/* execute op in parallel *\/$/;"	e	enum:__anon3
CEPH_OSD_FLAG_PEERSTAT_OLD	rados.h	/^	CEPH_OSD_FLAG_PEERSTAT_OLD =   0x0080,  \/* DEPRECATED msg includes osd_peer_stat *\/$/;"	e	enum:__anon3
CEPH_OSD_FLAG_PGOP	rados.h	/^	CEPH_OSD_FLAG_PGOP =           0x0400,  \/* pg op, no object *\/$/;"	e	enum:__anon3
CEPH_OSD_FLAG_READ	rados.h	/^	CEPH_OSD_FLAG_READ =           0x0010,  \/* op may read *\/$/;"	e	enum:__anon3
CEPH_OSD_FLAG_REDIRECTED	rados.h	/^	CEPH_OSD_FLAG_REDIRECTED   = 0x200000,  \/* op has been redirected *\/$/;"	e	enum:__anon3
CEPH_OSD_FLAG_RETRY	rados.h	/^	CEPH_OSD_FLAG_RETRY =          0x0008,  \/* resend attempt *\/$/;"	e	enum:__anon3
CEPH_OSD_FLAG_RWORDERED	rados.h	/^	CEPH_OSD_FLAG_RWORDERED =      0x4000,  \/* order wrt concurrent reads *\/$/;"	e	enum:__anon3
CEPH_OSD_FLAG_SKIPRWLOCKS	rados.h	/^	CEPH_OSD_FLAG_SKIPRWLOCKS =   0x10000,  \/* skip rw locks *\/$/;"	e	enum:__anon3
CEPH_OSD_FLAG_WRITE	rados.h	/^	CEPH_OSD_FLAG_WRITE =          0x0020,  \/* op may write *\/$/;"	e	enum:__anon3
CEPH_OSD_FULL	rados.h	117;"	d
CEPH_OSD_IN	rados.h	129;"	d
CEPH_OSD_MAX_PRIMARY_AFFINITY	rados.h	132;"	d
CEPH_OSD_NEARFULL	rados.h	118;"	d
CEPH_OSD_NEW	rados.h	116;"	d
CEPH_OSD_NODOWN	rados.h	122;"	d
CEPH_OSD_NOIN	rados.h	123;"	d
CEPH_OSD_NOOUT	rados.h	124;"	d
CEPH_OSD_NOUP	rados.h	121;"	d
CEPH_OSD_OP_FLAG_EXCL	rados.h	/^	CEPH_OSD_OP_FLAG_EXCL = 0x1,      \/* EXCL object create *\/$/;"	e	enum:__anon4
CEPH_OSD_OP_FLAG_FADVISE_DONTNEED	rados.h	/^	CEPH_OSD_OP_FLAG_FADVISE_DONTNEED   = 0x20,\/* data will not be accessed in the near future *\/$/;"	e	enum:__anon4
CEPH_OSD_OP_FLAG_FADVISE_NOCACHE	rados.h	/^	CEPH_OSD_OP_FLAG_FADVISE_NOCACHE   = 0x40, \/* data will be accessed only once by this client *\/$/;"	e	enum:__anon4
CEPH_OSD_OP_FLAG_FADVISE_RANDOM	rados.h	/^	CEPH_OSD_OP_FLAG_FADVISE_RANDOM     = 0x4, \/* the op is random *\/$/;"	e	enum:__anon4
CEPH_OSD_OP_FLAG_FADVISE_SEQUENTIAL	rados.h	/^	CEPH_OSD_OP_FLAG_FADVISE_SEQUENTIAL = 0x8, \/* the op is sequential *\/$/;"	e	enum:__anon4
CEPH_OSD_OP_FLAG_FADVISE_WILLNEED	rados.h	/^	CEPH_OSD_OP_FLAG_FADVISE_WILLNEED   = 0x10,\/* data will be accessed in the near future *\/$/;"	e	enum:__anon4
CEPH_OSD_OP_FLAG_FAILOK	rados.h	/^	CEPH_OSD_OP_FLAG_FAILOK = 0x2,    \/* continue despite failure *\/$/;"	e	enum:__anon4
CEPH_OSD_OP_MODE	rados.h	208;"	d
CEPH_OSD_OP_MODE_CACHE	rados.h	213;"	d
CEPH_OSD_OP_MODE_RD	rados.h	209;"	d
CEPH_OSD_OP_MODE_RMW	rados.h	211;"	d
CEPH_OSD_OP_MODE_SUB	rados.h	212;"	d
CEPH_OSD_OP_MODE_WR	rados.h	210;"	d
CEPH_OSD_OP_TYPE	rados.h	215;"	d
CEPH_OSD_OP_TYPE_ATTR	rados.h	217;"	d
CEPH_OSD_OP_TYPE_DATA	rados.h	216;"	d
CEPH_OSD_OP_TYPE_EXEC	rados.h	218;"	d
CEPH_OSD_OP_TYPE_PG	rados.h	219;"	d
CEPH_OSD_OUT	rados.h	130;"	d
CEPH_OSD_TMAP2OMAP_NULLOK	rados.h	/^	CEPH_OSD_TMAP2OMAP_NULLOK = 1,$/;"	e	enum:__anon8
CEPH_OSD_TMAP_CREATE	rados.h	416;"	d
CEPH_OSD_TMAP_CREATE	rados/librados.h	38;"	d
CEPH_OSD_TMAP_HDR	rados.h	414;"	d
CEPH_OSD_TMAP_HDR	rados/librados.h	36;"	d
CEPH_OSD_TMAP_RM	rados.h	417;"	d
CEPH_OSD_TMAP_RM	rados/librados.h	39;"	d
CEPH_OSD_TMAP_RMSLOPPY	rados.h	418;"	d
CEPH_OSD_TMAP_SET	rados.h	415;"	d
CEPH_OSD_TMAP_SET	rados/librados.h	37;"	d
CEPH_OSD_UP	rados.h	114;"	d
CEPH_OSD_WATCH_OP_LEGACY_WATCH	rados.h	/^	CEPH_OSD_WATCH_OP_LEGACY_WATCH = 1,$/;"	e	enum:__anon9
CEPH_OSD_WATCH_OP_PING	rados.h	/^	CEPH_OSD_WATCH_OP_PING = 7,$/;"	e	enum:__anon9
CEPH_OSD_WATCH_OP_RECONNECT	rados.h	/^	CEPH_OSD_WATCH_OP_RECONNECT = 5,$/;"	e	enum:__anon9
CEPH_OSD_WATCH_OP_UNWATCH	rados.h	/^	CEPH_OSD_WATCH_OP_UNWATCH = 0,$/;"	e	enum:__anon9
CEPH_OSD_WATCH_OP_WATCH	rados.h	/^	CEPH_OSD_WATCH_OP_WATCH = 3,$/;"	e	enum:__anon9
CEPH_O_CREAT	ceph_fs.h	394;"	d
CEPH_O_DIRECTORY	ceph_fs.h	397;"	d
CEPH_O_EXCL	ceph_fs.h	395;"	d
CEPH_O_NOFOLLOW	ceph_fs.h	398;"	d
CEPH_O_RDONLY	ceph_fs.h	391;"	d
CEPH_O_RDWR	ceph_fs.h	393;"	d
CEPH_O_TRUNC	ceph_fs.h	396;"	d
CEPH_O_WRONLY	ceph_fs.h	392;"	d
CEPH_PAGE_H	page.h	2;"	d
CEPH_PAGE_H	rados/page.h	2;"	d
CEPH_PAGE_MASK	page.h	15;"	d
CEPH_PAGE_MASK	rados/page.h	15;"	d
CEPH_PAGE_SHIFT	page.h	16;"	d
CEPH_PAGE_SHIFT	rados/page.h	16;"	d
CEPH_PAGE_SIZE	page.h	14;"	d
CEPH_PAGE_SIZE	rados/page.h	14;"	d
CEPH_PG_LAYOUT_CRUSH	rados.h	48;"	d
CEPH_PG_LAYOUT_HASH	rados.h	49;"	d
CEPH_PG_LAYOUT_HYBRID	rados.h	51;"	d
CEPH_PG_LAYOUT_LINEAR	rados.h	50;"	d
CEPH_PG_MAX_SIZE	rados.h	53;"	d
CEPH_PG_TYPE_ERASURE	rados.h	73;"	d
CEPH_PG_TYPE_REPLICATED	rados.h	71;"	d
CEPH_PORT_FIRST	msgr.h	21;"	d
CEPH_RADOS_API	rados/librados.h	86;"	d
CEPH_RADOS_API	rados/librados.h	88;"	d
CEPH_RADOS_H	rados.h	2;"	d
CEPH_RADOS_TYPES_H	rados/rados_types.h	2;"	d
CEPH_RADOS_TYPES_HPP	rados/rados_types.hpp	2;"	d
CEPH_RANGESET_H	rangeset.h	17;"	d
CEPH_RBD_API	rbd/librbd.h	52;"	d
CEPH_RBD_API	rbd/librbd.h	54;"	d
CEPH_RBD_FEATURES_H	rbd/features.h	2;"	d
CEPH_RBD_OBJECT_MAP_TYPES_H	rbd/object_map_types.h	4;"	d
CEPH_RBD_TYPES_H	rbd_types.h	14;"	d
CEPH_READDIR_FRAG_COMPLETE	ceph_fs.h	418;"	d
CEPH_READDIR_FRAG_END	ceph_fs.h	417;"	d
CEPH_READDIR_HASH_ORDER	ceph_fs.h	419;"	d
CEPH_READDIR_OFFSET_HASH	ceph_fs.h	420;"	d
CEPH_READDIR_REPLY_BITFLAGS	ceph_fs.h	412;"	d
CEPH_RELEASE_ARGONAUT	rados.h	175;"	d
CEPH_RELEASE_BOBTAIL	rados.h	176;"	d
CEPH_RELEASE_CUTTLEFISH	rados.h	177;"	d
CEPH_RELEASE_DUMPLING	rados.h	178;"	d
CEPH_RELEASE_EMPEROR	rados.h	179;"	d
CEPH_RELEASE_FIREFLY	rados.h	180;"	d
CEPH_RELEASE_GIANT	rados.h	181;"	d
CEPH_RELEASE_HAMMER	rados.h	182;"	d
CEPH_RELEASE_INFERNALIS	rados.h	183;"	d
CEPH_RELEASE_JEWEL	rados.h	184;"	d
CEPH_RELEASE_KRAKEN	rados.h	185;"	d
CEPH_RELEASE_LUMINOUS	rados.h	186;"	d
CEPH_RELEASE_MAX	rados.h	188;"	d
CEPH_RELEASE_MIMIC	rados.h	187;"	d
CEPH_REQ_FLAG_MASK	cephfs/ceph_statx.h	76;"	d
CEPH_SESSION_CLOSE	ceph_fs.h	/^	CEPH_SESSION_CLOSE,$/;"	e	enum:__anon45
CEPH_SESSION_FLUSHMSG	ceph_fs.h	/^	CEPH_SESSION_FLUSHMSG,$/;"	e	enum:__anon45
CEPH_SESSION_FLUSHMSG_ACK	ceph_fs.h	/^	CEPH_SESSION_FLUSHMSG_ACK,$/;"	e	enum:__anon45
CEPH_SESSION_FORCE_RO	ceph_fs.h	/^	CEPH_SESSION_FORCE_RO,$/;"	e	enum:__anon45
CEPH_SESSION_OPEN	ceph_fs.h	/^	CEPH_SESSION_OPEN,$/;"	e	enum:__anon45
CEPH_SESSION_RECALL_STATE	ceph_fs.h	/^	CEPH_SESSION_RECALL_STATE,$/;"	e	enum:__anon45
CEPH_SESSION_REJECT	ceph_fs.h	/^	CEPH_SESSION_REJECT,$/;"	e	enum:__anon45
CEPH_SESSION_RENEWCAPS	ceph_fs.h	/^	CEPH_SESSION_RENEWCAPS,$/;"	e	enum:__anon45
CEPH_SESSION_REQUEST_CLOSE	ceph_fs.h	/^	CEPH_SESSION_REQUEST_CLOSE,$/;"	e	enum:__anon45
CEPH_SESSION_REQUEST_FLUSH_MDLOG	ceph_fs.h	/^        CEPH_SESSION_REQUEST_FLUSH_MDLOG$/;"	e	enum:__anon45
CEPH_SESSION_REQUEST_OPEN	ceph_fs.h	/^	CEPH_SESSION_REQUEST_OPEN,$/;"	e	enum:__anon45
CEPH_SESSION_REQUEST_RENEWCAPS	ceph_fs.h	/^	CEPH_SESSION_REQUEST_RENEWCAPS,$/;"	e	enum:__anon45
CEPH_SESSION_STALE	ceph_fs.h	/^	CEPH_SESSION_STALE,$/;"	e	enum:__anon45
CEPH_SETATTR_ATIME	ceph_fs.h	379;"	d
CEPH_SETATTR_ATIME	cephfs/libcephfs.h	116;"	d
CEPH_SETATTR_ATIME_NOW	ceph_fs.h	385;"	d
CEPH_SETATTR_BTIME	ceph_fs.h	382;"	d
CEPH_SETATTR_BTIME	cephfs/libcephfs.h	119;"	d
CEPH_SETATTR_CTIME	ceph_fs.h	381;"	d
CEPH_SETATTR_CTIME	cephfs/libcephfs.h	118;"	d
CEPH_SETATTR_GID	ceph_fs.h	377;"	d
CEPH_SETATTR_GID	cephfs/libcephfs.h	114;"	d
CEPH_SETATTR_KILL_SGUID	ceph_fs.h	386;"	d
CEPH_SETATTR_MODE	ceph_fs.h	375;"	d
CEPH_SETATTR_MODE	cephfs/libcephfs.h	112;"	d
CEPH_SETATTR_MTIME	ceph_fs.h	378;"	d
CEPH_SETATTR_MTIME	cephfs/libcephfs.h	115;"	d
CEPH_SETATTR_MTIME_NOW	ceph_fs.h	384;"	d
CEPH_SETATTR_SIZE	ceph_fs.h	380;"	d
CEPH_SETATTR_SIZE	cephfs/libcephfs.h	117;"	d
CEPH_SETATTR_UID	ceph_fs.h	376;"	d
CEPH_SETATTR_UID	cephfs/libcephfs.h	113;"	d
CEPH_SNAPDIR	rados.h	28;"	d
CEPH_SNAP_OP_CREATE	ceph_fs.h	/^	CEPH_SNAP_OP_CREATE,$/;"	e	enum:__anon68
CEPH_SNAP_OP_DESTROY	ceph_fs.h	/^	CEPH_SNAP_OP_DESTROY,$/;"	e	enum:__anon68
CEPH_SNAP_OP_SPLIT	ceph_fs.h	/^	CEPH_SNAP_OP_SPLIT,$/;"	e	enum:__anon68
CEPH_SNAP_OP_UPDATE	ceph_fs.h	/^	CEPH_SNAP_OP_UPDATE,  \/* CREATE or DESTROY *\/$/;"	e	enum:__anon68
CEPH_SOCK_COMPAT_H	sock_compat.h	13;"	d
CEPH_SPINLOCK_H	Spinlock.h	17;"	d
CEPH_STATIC_ASSERT	ceph_features.h	253;"	d
CEPH_STATLITE_H	statlite.h	4;"	d
CEPH_STATX_ALL_STATS	cephfs/ceph_statx.h	63;"	d
CEPH_STATX_ATIME	cephfs/ceph_statx.h	54;"	d
CEPH_STATX_BASIC_STATS	cephfs/ceph_statx.h	60;"	d
CEPH_STATX_BLOCKS	cephfs/ceph_statx.h	59;"	d
CEPH_STATX_BTIME	cephfs/ceph_statx.h	61;"	d
CEPH_STATX_CTIME	cephfs/ceph_statx.h	56;"	d
CEPH_STATX_GID	cephfs/ceph_statx.h	52;"	d
CEPH_STATX_INO	cephfs/ceph_statx.h	57;"	d
CEPH_STATX_MODE	cephfs/ceph_statx.h	49;"	d
CEPH_STATX_MTIME	cephfs/ceph_statx.h	55;"	d
CEPH_STATX_NLINK	cephfs/ceph_statx.h	50;"	d
CEPH_STATX_RDEV	cephfs/ceph_statx.h	53;"	d
CEPH_STATX_SIZE	cephfs/ceph_statx.h	58;"	d
CEPH_STATX_UID	cephfs/ceph_statx.h	51;"	d
CEPH_STATX_VERSION	cephfs/ceph_statx.h	62;"	d
CEPH_STAT_CAP_ATIME	ceph_fs.h	727;"	d
CEPH_STAT_CAP_GID	ceph_fs.h	721;"	d
CEPH_STAT_CAP_INLINE_DATA	ceph_fs.h	734;"	d
CEPH_STAT_CAP_INODE	ceph_fs.h	717;"	d
CEPH_STAT_CAP_INODE_ALL	ceph_fs.h	729;"	d
CEPH_STAT_CAP_LAYOUT	ceph_fs.h	724;"	d
CEPH_STAT_CAP_MODE	ceph_fs.h	722;"	d
CEPH_STAT_CAP_MTIME	ceph_fs.h	725;"	d
CEPH_STAT_CAP_NLINK	ceph_fs.h	723;"	d
CEPH_STAT_CAP_SIZE	ceph_fs.h	726;"	d
CEPH_STAT_CAP_SYMLINK	ceph_fs.h	719;"	d
CEPH_STAT_CAP_TYPE	ceph_fs.h	718;"	d
CEPH_STAT_CAP_UID	ceph_fs.h	720;"	d
CEPH_STAT_CAP_XATTR	ceph_fs.h	728;"	d
CEPH_STAT_H	stat.h	2;"	d
CEPH_STAT_RSTAT	ceph_fs.h	736;"	d
CEPH_STRLIST_H	str_list.h	2;"	d
CEPH_STRMAP_H	str_map.h	18;"	d
CEPH_STR_HASH_LINUX	ceph_hash.h	4;"	d
CEPH_STR_HASH_RJENKINS	ceph_hash.h	5;"	d
CEPH_SUBSCRIBE_ONETIME	ceph_fs.h	219;"	d
CEPH_TYPES_H	types.h	15;"	d
CEPH_UNORDERED_MAP_H	unordered_map.h	2;"	d
CEPH_UNORDERED_SET_H	unordered_set.h	2;"	d
CEPH_USE_SIGPIPE_BLOCKER	sock_compat.h	34;"	d
CEPH_USE_SO_NOSIGPIPE	sock_compat.h	32;"	d
CEPH_UTIL_H	util.h	15;"	d
CEPH_UTIME_H	utime.h	16;"	d
CEPH_WATCH_EVENT_DISCONNECT	ceph_fs.h	/^	CEPH_WATCH_EVENT_DISCONNECT       = 3, \/* we were disconnected *\/$/;"	e	enum:__anon43
CEPH_WATCH_EVENT_NOTIFY	ceph_fs.h	/^	CEPH_WATCH_EVENT_NOTIFY		  = 1, \/* notifying watcher *\/$/;"	e	enum:__anon43
CEPH_WATCH_EVENT_NOTIFY_COMPLETE	ceph_fs.h	/^	CEPH_WATCH_EVENT_NOTIFY_COMPLETE  = 2, \/* notifier notified when done *\/$/;"	e	enum:__anon43
CEPH_XATTR_CREATE	ceph_fs.h	405;"	d
CEPH_XATTR_REMOVE	ceph_fs.h	407;"	d
CEPH_XATTR_REPLACE	ceph_fs.h	406;"	d
CEPH_XLIST_H	xlist.h	16;"	d
CLAIM_ALLOW_NONSHAREABLE	buffer.h	/^    const static unsigned int CLAIM_ALLOW_NONSHAREABLE = 1;$/;"	m	class:ceph::CEPH_BUFFER_API::list
CLAIM_ALLOW_NONSHAREABLE	rados/buffer.h	/^    const static unsigned int CLAIM_ALLOW_NONSHAREABLE = 1;$/;"	m	class:ceph::CEPH_BUFFER_API::list
CLAIM_DEFAULT	buffer.h	/^    const static unsigned int CLAIM_DEFAULT = 0;$/;"	m	class:ceph::CEPH_BUFFER_API::list
CLAIM_DEFAULT	rados/buffer.h	/^    const static unsigned int CLAIM_DEFAULT = 0;$/;"	m	class:ceph::CEPH_BUFFER_API::list
CLOCK_MONOTONIC_COARSE	compat.h	61;"	d
CLOCK_MONOTONIC_COARSE	compat.h	63;"	d
CLOCK_REALTIME_COARSE	compat.h	68;"	d
CLOCK_REALTIME_COARSE	compat.h	70;"	d
CLONE_MISSING	rados/rados_types.hpp	/^    CLONE_MISSING  = 1 << 2,$/;"	e	enum:inconsistent_snapset_t::__anon41
CLS_ERR	rados/objclass.h	31;"	d
CLS_INIT	rados/objclass.h	22;"	d
CLS_LOG	rados/objclass.h	29;"	d
CLS_METHOD_PROMOTE	rados/objclass.h	27;"	d
CLS_METHOD_RD	rados/objclass.h	25;"	d
CLS_METHOD_WR	rados/objclass.h	26;"	d
CLS_NAME	rados/objclass.h	19;"	d
CLS_VER	rados/objclass.h	14;"	d
COMPILE_ASSERT	cpp-btree/btree.h	160;"	d
CONST_DELIMS	str_map.h	20;"	d
CURRENT	elist.h	/^    MAGIC, CURRENT, CACHE_NEXT$/;"	e	enum:elist::mode_t
C_Contexts	Context.h	/^typedef C_ContextsBase<Context, Context> C_Contexts;$/;"	t
C_ContextsBase	Context.h	/^  C_ContextsBase(CephContext *cct_)$/;"	f	class:C_ContextsBase
C_ContextsBase	Context.h	/^class C_ContextsBase : public ContextInstanceType {$/;"	c
C_Gather	Context.h	/^typedef C_GatherBase<Context, Context> C_Gather;$/;"	t
C_GatherBase	Context.h	/^  C_GatherBase(CephContext *cct_, ContextType *onfinish_)$/;"	f	class:C_GatherBase
C_GatherBase	Context.h	/^class C_GatherBase : public ContextType {$/;"	c
C_GatherBuilder	Context.h	/^typedef C_GatherBuilderBase<Context, C_Gather > C_GatherBuilder;$/;"	t
C_GatherBuilderBase	Context.h	/^  C_GatherBuilderBase(CephContext *cct_)$/;"	f	class:C_GatherBuilderBase
C_GatherBuilderBase	Context.h	/^  C_GatherBuilderBase(CephContext *cct_, ContextType *finisher_)$/;"	f	class:C_GatherBuilderBase
C_GatherBuilderBase	Context.h	/^class C_GatherBuilderBase$/;"	c
C_GatherSub	Context.h	/^    C_GatherSub(C_GatherBase *g) : gather(g) {}$/;"	f	class:C_GatherBase::C_GatherSub
C_GatherSub	Context.h	/^  class C_GatherSub : public ContextInstanceType {$/;"	c	class:C_GatherBase
C_Lock	Context.h	/^  C_Lock(Mutex *l, Context *c) : lock(l), fin(c) {}$/;"	f	struct:C_Lock
C_Lock	Context.h	/^struct C_Lock : public Context {$/;"	s
C_NoopContext	Context.h	/^class C_NoopContext : public Context {$/;"	c
CompatSet	CompatSet.h	/^  CompatSet() : compat(), ro_compat(), incompat() { }$/;"	f	struct:CompatSet
CompatSet	CompatSet.h	/^  CompatSet(FeatureSet& _compat, FeatureSet& _ro_compat, FeatureSet& _incompat) :$/;"	f	struct:CompatSet
CompatSet	CompatSet.h	/^struct CompatSet {$/;"	s
CompileAssert	cpp-btree/btree.h	/^struct CompileAssert {$/;"	s	namespace:btree
ContainerContext	Context.h	/^  ContainerContext(T &obj) : obj(obj) {}$/;"	f	class:ContainerContext
ContainerContext	Context.h	/^class ContainerContext : public Context {$/;"	c
Context	Context.h	/^  Context() {}$/;"	f	class:Context
Context	Context.h	/^class Context {$/;"	c
Counter	counter.h	/^  Counter() {$/;"	f	class:Counter
Counter	counter.h	/^  Counter(Counter &&rhs) {}$/;"	f	class:Counter
Counter	counter.h	/^  Counter(const Counter &rhs) {$/;"	f	class:Counter
Counter	counter.h	/^class Counter {$/;"	c
DATA_DIGEST_MISMATCH	rados/rados_types.hpp	/^    DATA_DIGEST_MISMATCH = 1 << 4,$/;"	m	struct:librados::obj_err_t	typeref:enum:librados::obj_err_t::
DATA_DIGEST_MISMATCH_INFO	rados/rados_types.hpp	/^    DATA_DIGEST_MISMATCH_INFO = 1 << 9,$/;"	m	struct:librados::err_t	typeref:enum:librados::err_t::
DATA_DIGEST_MISMATCH_OI	rados/rados_types.hpp	/^    DATA_DIGEST_MISMATCH_OI = 1 << 9,   \/\/ Old$/;"	m	struct:librados::err_t	typeref:enum:librados::err_t::
DECODE_ERR_OLDVERSION	encoding.h	1060;"	d
DECODE_ERR_PAST	encoding.h	1063;"	d
DECODE_FINISH	encoding.h	1164;"	d
DECODE_OLDEST	encoding.h	1073;"	d
DECODE_START	encoding.h	1083;"	d
DECODE_START_LEGACY_COMPAT_LEN	encoding.h	1133;"	d
DECODE_START_LEGACY_COMPAT_LEN_16	encoding.h	1156;"	d
DECODE_START_LEGACY_COMPAT_LEN_32	encoding.h	1153;"	d
DEEP_ERRORS	rados/rados_types.hpp	/^  static constexpr uint64_t DEEP_ERRORS = DATA_DIGEST_MISMATCH|OMAP_DIGEST_MISMATCH;$/;"	m	namespace:librados
DEEP_ERRORS	rados/rados_types.hpp	/^  static constexpr uint64_t DEEP_ERRORS = SHARD_READ_ERR|DATA_DIGEST_MISMATCH_INFO|OMAP_DIGEST_MISMATCH_INFO|SHARD_EC_HASH_MISMATCH|SHARD_EC_SIZE_MISMATCH;$/;"	m	struct:librados::err_t
DEFINE_CEPH_FEATURE	ceph_features.h	14;"	d
DEFINE_CEPH_FEATURE_DEPRECATED	ceph_features.h	20;"	d
DEFINE_CEPH_FEATURE_RETIRED	ceph_features.h	27;"	d
DEFINE_MEMORY_POOLS_HELPER	mempool.h	/^  DEFINE_MEMORY_POOLS_HELPER(P)$/;"	e	enum:mempool::pool_index_t
DEFINE_MEMORY_POOLS_HELPER	mempool.h	146;"	d
DENC	denc.h	1760;"	d
DENC	utime.h	/^  DENC(utime_t, v, p) {$/;"	f	class:utime_t
DENC_DUMP_POST	denc.h	105;"	d
DENC_DUMP_POST	denc.h	82;"	d
DENC_DUMP_PRE	denc.h	104;"	d
DENC_DUMP_PRE	denc.h	77;"	d
DENC_FEATURED	denc.h	1778;"	d
DENC_FINISH	denc.h	1750;"	d
DENC_HELPERS	denc.h	1685;"	d
DENC_START	denc.h	1742;"	d
DIV_ROUND_UP	intarith.h	27;"	d
Distribution	Distribution.h	/^class Distribution {$/;"	c
EBLACKLISTED	rados.h	469;"	d
ENCODE_DUMP_POST	encoding.h	131;"	d
ENCODE_DUMP_PRE	encoding.h	129;"	d
ENCODE_FINISH	encoding.h	1058;"	d
ENCODE_FINISH_NEW_COMPAT	encoding.h	1049;"	d
ENCODE_START	encoding.h	1030;"	d
ENCODE_STR	denc.h	75;"	d
ENCODE_STRINGIFY	denc.h	76;"	d
ENODATA	compat.h	30;"	d
ENODATA	compat.h	47;"	d
ENODATA	compat.h	48;"	d
EOLDSNAPC	rados.h	468;"	d
EREMOTEIO	compat.h	84;"	d
ERESTART	compat.h	104;"	d
EVENT_SOCKET_TYPE_EVENTFD	event_type.h	22;"	d
EVENT_SOCKET_TYPE_NONE	event_type.h	20;"	d
EVENT_SOCKET_TYPE_PIPE	event_type.h	21;"	d
EVENT_TYPE_EVENTFD	rbd/librbd.h	/^  EVENT_TYPE_EVENTFD = 2$/;"	e	enum:__anon76
EVENT_TYPE_PIPE	rbd/librbd.h	/^  EVENT_TYPE_PIPE = 1,$/;"	e	enum:__anon76
EXTRA_CLONES	rados/rados_types.hpp	/^    EXTRA_CLONES = 1 << 9,$/;"	e	enum:inconsistent_snapset_t::__anon41
ExtType	denc.h	/^template<> struct ExtType<bool> {$/;"	s	namespace:_denc
ExtType	denc.h	/^template<typename T, typename=void> struct ExtType {$/;"	s	namespace:_denc
ExtType	denc.h	/^template<typename T> struct ExtType<$/;"	s	namespace:_denc
FIEMAP_EXTENT_DATA_ENCRYPTED	linux_fiemap.h	57;"	d
FIEMAP_EXTENT_DATA_INLINE	linux_fiemap.h	61;"	d
FIEMAP_EXTENT_DATA_TAIL	linux_fiemap.h	63;"	d
FIEMAP_EXTENT_DELALLOC	linux_fiemap.h	53;"	d
FIEMAP_EXTENT_ENCODED	linux_fiemap.h	55;"	d
FIEMAP_EXTENT_LAST	linux_fiemap.h	51;"	d
FIEMAP_EXTENT_MERGED	linux_fiemap.h	67;"	d
FIEMAP_EXTENT_NOT_ALIGNED	linux_fiemap.h	59;"	d
FIEMAP_EXTENT_SHARED	linux_fiemap.h	70;"	d
FIEMAP_EXTENT_UNKNOWN	linux_fiemap.h	52;"	d
FIEMAP_EXTENT_UNWRITTEN	linux_fiemap.h	65;"	d
FIEMAP_FLAGS_COMPAT	linux_fiemap.h	49;"	d
FIEMAP_FLAG_SYNC	linux_fiemap.h	46;"	d
FIEMAP_FLAG_XATTR	linux_fiemap.h	47;"	d
FIEMAP_MAX_OFFSET	linux_fiemap.h	44;"	d
FS_CEPH_FRAG_H	ceph_frag.h	2;"	d
FS_CEPH_HASH_H	ceph_hash.h	2;"	d
Feature	CompatSet.h	/^    Feature(uint64_t _id, const string& _name) : id(_id), name(_name) {}$/;"	f	struct:CompatSet::Feature
Feature	CompatSet.h	/^  struct Feature {$/;"	s	struct:CompatSet
FeatureSet	CompatSet.h	/^    FeatureSet() : mask(1), names() {}$/;"	f	class:CompatSet::FeatureSet
FeatureSet	CompatSet.h	/^  class FeatureSet {$/;"	c	struct:CompatSet
Fh	cephfs/libcephfs.h	/^typedef struct Fh Fh;$/;"	t	typeref:struct:Fh
FunctionContext	Context.h	/^  FunctionContext(boost::function<void(int)> &&callback)$/;"	f	class:FunctionContext
FunctionContext	Context.h	/^class FunctionContext : public Context {$/;"	c
GENERATE_ENUM_ENTRY	rados.h	350;"	d
GENERATE_ENUM_ENTRY	rados.h	352;"	d
GenContext	Context.h	/^  GenContext() {}$/;"	f	class:GenContext
GenContext	Context.h	/^class GenContext {$/;"	c
HAVE_FEATURE	ceph_features.h	34;"	d
HEADLESS_CLONE	rados/rados_types.hpp	/^    HEADLESS_CLONE = 1 << 5,$/;"	e	enum:inconsistent_snapset_t::__anon41
HEAD_MISMATCH	rados/rados_types.hpp	/^    HEAD_MISMATCH  = 1 << 4,$/;"	e	enum:inconsistent_snapset_t::__anon41
HEALTH_ERR	health.h	/^  HEALTH_ERR = 0,$/;"	e	enum:health_status_t
HEALTH_OK	health.h	/^  HEALTH_OK = 2,$/;"	e	enum:health_status_t
HEALTH_WARN	health.h	/^  HEALTH_WARN = 1,$/;"	e	enum:health_status_t
HINFO_CORRUPTED	rados/rados_types.hpp	/^    HINFO_CORRUPTED       = 1 << 20$/;"	m	struct:librados::err_t	typeref:enum:librados::err_t::
HINFO_INCONSISTENCY	rados/rados_types.hpp	/^    HINFO_INCONSISTENCY   = 1 << 10,$/;"	m	struct:librados::obj_err_t	typeref:enum:librados::obj_err_t::
HINFO_MISSING	rados/rados_types.hpp	/^    HINFO_MISSING         = 1 << 19,$/;"	m	struct:librados::err_t	typeref:enum:librados::err_t::
HOST_NAME_MAX	compat.h	89;"	d
HOST_NAME_MAX	compat.h	91;"	d
IFTODT	compat.h	132;"	d
INFO_CORRUPTED	rados/rados_types.hpp	/^    INFO_CORRUPTED       = 1 << 15,$/;"	m	struct:librados::err_t	typeref:enum:librados::err_t::
INFO_CORRUPTED	rados/rados_types.hpp	/^    INFO_CORRUPTED = 1 << 8,$/;"	e	enum:inconsistent_snapset_t::__anon41
INFO_MISSING	rados/rados_types.hpp	/^    INFO_MISSING         = 1 << 14,$/;"	m	struct:librados::err_t	typeref:enum:librados::err_t::
INFO_MISSING	rados/rados_types.hpp	/^    INFO_MISSING   = 1 << 7,$/;"	e	enum:inconsistent_snapset_t::__anon41
ISP2	intarith.h	41;"	d
IS_ERR	err.h	/^static inline long IS_ERR(const void *ptr)$/;"	f
IS_ERR_VALUE	err.h	8;"	d
Image	rbd/librbd.hpp	/^class CEPH_RBD_API Image$/;"	c	namespace:librbd
ImageOptions	rbd/librbd.hpp	/^class CEPH_RBD_API ImageOptions {$/;"	c	namespace:librbd
Inode	cephfs/libcephfs.h	/^typedef struct Inode Inode;$/;"	t	typeref:struct:Inode
IoCtx	rados/librados.hpp	/^  class CEPH_RADOS_API IoCtx$/;"	c	namespace:librados
LIBCEPHFS_VERSION	cephfs/libcephfs.h	40;"	d
LIBCEPHFS_VERSION_CODE	cephfs/libcephfs.h	41;"	d
LIBCEPHFS_VER_EXTRA	cephfs/libcephfs.h	38;"	d
LIBCEPHFS_VER_MAJOR	cephfs/libcephfs.h	36;"	d
LIBCEPHFS_VER_MINOR	cephfs/libcephfs.h	37;"	d
LIBRADOSSTRIPER_VERSION	radosstriper/libradosstriper.h	16;"	d
LIBRADOSSTRIPER_VERSION_CODE	radosstriper/libradosstriper.h	18;"	d
LIBRADOSSTRIPER_VER_EXTRA	radosstriper/libradosstriper.h	14;"	d
LIBRADOSSTRIPER_VER_MAJOR	radosstriper/libradosstriper.h	12;"	d
LIBRADOSSTRIPER_VER_MINOR	radosstriper/libradosstriper.h	13;"	d
LIBRADOS_ALLOC_HINT_FLAG_APPEND_ONLY	rados/librados.h	/^  LIBRADOS_ALLOC_HINT_FLAG_APPEND_ONLY = 16,$/;"	e	enum:__anon37
LIBRADOS_ALLOC_HINT_FLAG_COMPRESSIBLE	rados/librados.h	/^  LIBRADOS_ALLOC_HINT_FLAG_COMPRESSIBLE = 256,$/;"	e	enum:__anon37
LIBRADOS_ALLOC_HINT_FLAG_IMMUTABLE	rados/librados.h	/^  LIBRADOS_ALLOC_HINT_FLAG_IMMUTABLE = 32,$/;"	e	enum:__anon37
LIBRADOS_ALLOC_HINT_FLAG_INCOMPRESSIBLE	rados/librados.h	/^  LIBRADOS_ALLOC_HINT_FLAG_INCOMPRESSIBLE = 512,$/;"	e	enum:__anon37
LIBRADOS_ALLOC_HINT_FLAG_LONGLIVED	rados/librados.h	/^  LIBRADOS_ALLOC_HINT_FLAG_LONGLIVED = 128,$/;"	e	enum:__anon37
LIBRADOS_ALLOC_HINT_FLAG_RANDOM_READ	rados/librados.h	/^  LIBRADOS_ALLOC_HINT_FLAG_RANDOM_READ = 8,$/;"	e	enum:__anon37
LIBRADOS_ALLOC_HINT_FLAG_RANDOM_WRITE	rados/librados.h	/^  LIBRADOS_ALLOC_HINT_FLAG_RANDOM_WRITE = 2,$/;"	e	enum:__anon37
LIBRADOS_ALLOC_HINT_FLAG_SEQUENTIAL_READ	rados/librados.h	/^  LIBRADOS_ALLOC_HINT_FLAG_SEQUENTIAL_READ = 4,$/;"	e	enum:__anon37
LIBRADOS_ALLOC_HINT_FLAG_SEQUENTIAL_WRITE	rados/librados.h	/^  LIBRADOS_ALLOC_HINT_FLAG_SEQUENTIAL_WRITE = 1,$/;"	e	enum:__anon37
LIBRADOS_ALLOC_HINT_FLAG_SHORTLIVED	rados/librados.h	/^  LIBRADOS_ALLOC_HINT_FLAG_SHORTLIVED = 64,$/;"	e	enum:__anon37
LIBRADOS_ALL_NSPACES	rados/rados_types.h	24;"	d
LIBRADOS_CHECKSUM_TYPE_CRC32C	rados/librados.h	/^	LIBRADOS_CHECKSUM_TYPE_CRC32C   = 2$/;"	e	enum:__anon38
LIBRADOS_CHECKSUM_TYPE_XXHASH32	rados/librados.h	/^	LIBRADOS_CHECKSUM_TYPE_XXHASH32 = 0,$/;"	e	enum:__anon38
LIBRADOS_CHECKSUM_TYPE_XXHASH64	rados/librados.h	/^	LIBRADOS_CHECKSUM_TYPE_XXHASH64 = 1,$/;"	e	enum:__anon38
LIBRADOS_CMPXATTR_OP_EQ	rados/librados.h	/^	LIBRADOS_CMPXATTR_OP_EQ  = 1,$/;"	e	enum:__anon35
LIBRADOS_CMPXATTR_OP_GT	rados/librados.h	/^	LIBRADOS_CMPXATTR_OP_GT  = 3,$/;"	e	enum:__anon35
LIBRADOS_CMPXATTR_OP_GTE	rados/librados.h	/^	LIBRADOS_CMPXATTR_OP_GTE = 4,$/;"	e	enum:__anon35
LIBRADOS_CMPXATTR_OP_LT	rados/librados.h	/^	LIBRADOS_CMPXATTR_OP_LT  = 5,$/;"	e	enum:__anon35
LIBRADOS_CMPXATTR_OP_LTE	rados/librados.h	/^	LIBRADOS_CMPXATTR_OP_LTE = 6$/;"	e	enum:__anon35
LIBRADOS_CMPXATTR_OP_NE	rados/librados.h	/^	LIBRADOS_CMPXATTR_OP_NE  = 2,$/;"	e	enum:__anon35
LIBRADOS_CREATE_EXCLUSIVE	rados/librados.h	61;"	d
LIBRADOS_CREATE_IDEMPOTENT	rados/librados.h	62;"	d
LIBRADOS_LOCK_FLAG_RENEW	rados/librados.h	56;"	d
LIBRADOS_OPERATION_BALANCE_READS	rados/librados.h	/^  LIBRADOS_OPERATION_BALANCE_READS      = 1,$/;"	e	enum:__anon36
LIBRADOS_OPERATION_FULL_FORCE	rados/librados.h	/^  LIBRADOS_OPERATION_FULL_FORCE		= 128,$/;"	e	enum:__anon36
LIBRADOS_OPERATION_FULL_TRY	rados/librados.h	/^  LIBRADOS_OPERATION_FULL_TRY           = 64,$/;"	e	enum:__anon36
LIBRADOS_OPERATION_IGNORE_CACHE	rados/librados.h	/^  LIBRADOS_OPERATION_IGNORE_CACHE       = 8,$/;"	e	enum:__anon36
LIBRADOS_OPERATION_IGNORE_OVERLAY	rados/librados.h	/^  LIBRADOS_OPERATION_IGNORE_OVERLAY     = 32,$/;"	e	enum:__anon36
LIBRADOS_OPERATION_IGNORE_REDIRECT	rados/librados.h	/^  LIBRADOS_OPERATION_IGNORE_REDIRECT	= 256,$/;"	e	enum:__anon36
LIBRADOS_OPERATION_LOCALIZE_READS	rados/librados.h	/^  LIBRADOS_OPERATION_LOCALIZE_READS     = 2,$/;"	e	enum:__anon36
LIBRADOS_OPERATION_NOFLAG	rados/librados.h	/^  LIBRADOS_OPERATION_NOFLAG             = 0,$/;"	e	enum:__anon36
LIBRADOS_OPERATION_ORDER_READS_WRITES	rados/librados.h	/^  LIBRADOS_OPERATION_ORDER_READS_WRITES = 4,$/;"	e	enum:__anon36
LIBRADOS_OPERATION_SKIPRWLOCKS	rados/librados.h	/^  LIBRADOS_OPERATION_SKIPRWLOCKS        = 16,$/;"	e	enum:__anon36
LIBRADOS_OP_FLAG_EXCL	rados/librados.h	/^  LIBRADOS_OP_FLAG_EXCL               =  0x1,$/;"	e	enum:__anon34
LIBRADOS_OP_FLAG_FADVISE_DONTNEED	rados/librados.h	/^  LIBRADOS_OP_FLAG_FADVISE_DONTNEED   = 0x20,$/;"	e	enum:__anon34
LIBRADOS_OP_FLAG_FADVISE_NOCACHE	rados/librados.h	/^  LIBRADOS_OP_FLAG_FADVISE_NOCACHE    = 0x40,$/;"	e	enum:__anon34
LIBRADOS_OP_FLAG_FADVISE_RANDOM	rados/librados.h	/^  LIBRADOS_OP_FLAG_FADVISE_RANDOM     = 0x4,$/;"	e	enum:__anon34
LIBRADOS_OP_FLAG_FADVISE_SEQUENTIAL	rados/librados.h	/^  LIBRADOS_OP_FLAG_FADVISE_SEQUENTIAL = 0x8,$/;"	e	enum:__anon34
LIBRADOS_OP_FLAG_FADVISE_WILLNEED	rados/librados.h	/^  LIBRADOS_OP_FLAG_FADVISE_WILLNEED   = 0x10,$/;"	e	enum:__anon34
LIBRADOS_OP_FLAG_FAILOK	rados/librados.h	/^  LIBRADOS_OP_FLAG_FAILOK 	      = 0x2,$/;"	e	enum:__anon34
LIBRADOS_SNAP_DIR	rados/librados.h	166;"	d
LIBRADOS_SNAP_HEAD	rados/librados.h	165;"	d
LIBRADOS_SUPPORTS_SERVICES	rados/librados.h	51;"	d
LIBRADOS_SUPPORTS_WATCH	rados/librados.h	50;"	d
LIBRADOS_VERSION	rados/librados.h	46;"	d
LIBRADOS_VERSION_CODE	rados/librados.h	48;"	d
LIBRADOS_VER_EXTRA	rados/librados.h	44;"	d
LIBRADOS_VER_MAJOR	rados/librados.h	42;"	d
LIBRADOS_VER_MINOR	rados/librados.h	43;"	d
LIBRBD_SUPPORTS_AIO_FLUSH	rbd/librbd.h	42;"	d
LIBRBD_SUPPORTS_AIO_OPEN	rbd/librbd.h	43;"	d
LIBRBD_SUPPORTS_COMPARE_AND_WRITE	rbd/librbd.h	44;"	d
LIBRBD_SUPPORTS_INVALIDATE	rbd/librbd.h	46;"	d
LIBRBD_SUPPORTS_IOVEC	rbd/librbd.h	47;"	d
LIBRBD_SUPPORTS_LOCKING	rbd/librbd.h	45;"	d
LIBRBD_SUPPORTS_WATCH	rbd/librbd.h	48;"	d
LIBRBD_SUPPORTS_WRITESAME	rbd/librbd.h	49;"	d
LIBRBD_VERSION	rbd/librbd.h	38;"	d
LIBRBD_VERSION_CODE	rbd/librbd.h	40;"	d
LIBRBD_VER_EXTRA	rbd/librbd.h	36;"	d
LIBRBD_VER_MAJOR	rbd/librbd.h	34;"	d
LIBRBD_VER_MINOR	rbd/librbd.h	35;"	d
LIBRGW_FILE_VERSION	rados/rgw_file.h	32;"	d
LIBRGW_FILE_VERSION_CODE	rados/rgw_file.h	33;"	d
LIBRGW_FILE_VER_EXTRA	rados/rgw_file.h	30;"	d
LIBRGW_FILE_VER_MAJOR	rados/rgw_file.h	28;"	d
LIBRGW_FILE_VER_MINOR	rados/rgw_file.h	29;"	d
LIBRGW_VERSION	rados/librgw.h	25;"	d
LIBRGW_VERSION_CODE	rados/librgw.h	26;"	d
LIBRGW_VER_EXTRA	rados/librgw.h	23;"	d
LIBRGW_VER_MAJOR	rados/librgw.h	21;"	d
LIBRGW_VER_MINOR	rados/librgw.h	22;"	d
LOG_AUTHPRIV	compat.h	129;"	d
LOG_FTP	compat.h	130;"	d
LRU	lru.h	/^  LRU() : num_pinned(0), midpoint(0.6) {}$/;"	f	class:LRU
LRU	lru.h	/^class LRU {$/;"	c
LRUList	lru.h	/^  typedef xlist<LRUObject *> LRUList;$/;"	t	class:LRU
LRUObject	lru.h	/^  LRUObject() : lru(), lru_link(this), lru_pinned(false) { }$/;"	f	class:LRUObject
LRUObject	lru.h	/^class LRUObject {$/;"	c
LambdaContext	Context.h	/^  LambdaContext(T &&t) : t(std::forward<T>(t)) {}$/;"	f	struct:LambdaContext
LambdaContext	Context.h	/^struct LambdaContext : public Context {$/;"	s
LambdaGenContext	Context.h	/^  LambdaGenContext(F &&f) : f(std::forward<F>(f)) {}$/;"	f	struct:LambdaGenContext
LambdaGenContext	Context.h	/^struct LambdaGenContext : GenContext<T> {$/;"	s
ListObject	rados/librados.hpp	/^  class CEPH_RADOS_API ListObject$/;"	c	namespace:librados
Locker	Spinlock.h	/^    Locker(const Spinlock& s) : spinlock(s) {$/;"	f	class:Spinlock::Locker
Locker	Spinlock.h	/^  class Locker {$/;"	c	class:Spinlock
MAGIC	elist.h	/^    MAGIC, CURRENT, CACHE_NEXT$/;"	e	enum:elist::mode_t
MAX	intarith.h	23;"	d
MAX	interval_set.h	37;"	d
MAX_DENTRY_LEN	fs_types.h	71;"	d
MAX_ERRNO	err.h	7;"	d
MEMPOOL_CLASS_HELPERS	mempool.h	468;"	d
MEMPOOL_DECLARE_FACTORY	mempool.h	447;"	d
MEMPOOL_DEFINE_FACTORY	mempool.h	454;"	d
MEMPOOL_DEFINE_OBJECT_FACTORY	mempool.h	479;"	d
MIN	intarith.h	19;"	d
MIN	interval_set.h	34;"	d
MIRROR_IMAGE_STATUS_STATE_ERROR	rbd/librbd.h	/^  MIRROR_IMAGE_STATUS_STATE_ERROR           = 1,$/;"	e	enum:__anon82
MIRROR_IMAGE_STATUS_STATE_REPLAYING	rbd/librbd.h	/^  MIRROR_IMAGE_STATUS_STATE_REPLAYING       = 4,$/;"	e	enum:__anon82
MIRROR_IMAGE_STATUS_STATE_STARTING_REPLAY	rbd/librbd.h	/^  MIRROR_IMAGE_STATUS_STATE_STARTING_REPLAY = 3,$/;"	e	enum:__anon82
MIRROR_IMAGE_STATUS_STATE_STOPPED	rbd/librbd.h	/^  MIRROR_IMAGE_STATUS_STATE_STOPPED         = 6,$/;"	e	enum:__anon82
MIRROR_IMAGE_STATUS_STATE_STOPPING_REPLAY	rbd/librbd.h	/^  MIRROR_IMAGE_STATUS_STATE_STOPPING_REPLAY = 5,$/;"	e	enum:__anon82
MIRROR_IMAGE_STATUS_STATE_SYNCING	rbd/librbd.h	/^  MIRROR_IMAGE_STATUS_STATE_SYNCING         = 2,$/;"	e	enum:__anon82
MIRROR_IMAGE_STATUS_STATE_UNKNOWN	rbd/librbd.h	/^  MIRROR_IMAGE_STATUS_STATE_UNKNOWN         = 0,$/;"	e	enum:__anon82
MSG_DONTWAIT	compat.h	136;"	d
MSG_MORE	compat.h	51;"	d
MSG_MORE	sock_compat.h	23;"	d
MSG_NOSIGNAL	sock_compat.h	30;"	d
MultiAioCompletion	radosstriper/libradosstriper.hpp	/^    MultiAioCompletion(MultiAioCompletionImpl *pc_) : pc(pc_) {}$/;"	f	struct:libradosstriper::MultiAioCompletion
MultiAioCompletion	radosstriper/libradosstriper.hpp	/^  struct MultiAioCompletion {$/;"	s	namespace:libradosstriper
NDEBUG	cpp-btree/btree.h	119;"	d
NO_SHARD	types.h	/^  const static shard_id_t NO_SHARD;$/;"	m	struct:shard_id_t
NObjectIterator	rados/librados.hpp	/^    NObjectIterator(): impl(NULL) {}$/;"	f	class:librados::NObjectIterator
NObjectIterator	rados/librados.hpp	/^  class CEPH_RADOS_API NObjectIterator : public std::iterator <std::forward_iterator_tag, ListObject> {$/;"	c	namespace:librados
NObjectIterator	rados/librados.hpp	/^  class CEPH_RADOS_API NObjectIterator;$/;"	m	namespace:librados	typeref:class:librados::CEPH_RADOS_API
OBJECT_EXISTS	rbd/object_map_types.h	/^static const uint8_t OBJECT_EXISTS       = 1;$/;"	v
OBJECT_EXISTS_CLEAN	rbd/object_map_types.h	/^static const uint8_t OBJECT_EXISTS_CLEAN = 3;$/;"	v
OBJECT_NONEXISTENT	rbd/object_map_types.h	/^static const uint8_t OBJECT_NONEXISTENT  = 0;$/;"	v
OBJECT_PENDING	rbd/object_map_types.h	/^static const uint8_t OBJECT_PENDING      = 2;$/;"	v
OBJ_SIZE_INFO_MISMATCH	rados/rados_types.hpp	/^    OBJ_SIZE_INFO_MISMATCH      = 1 << 18,$/;"	m	struct:librados::err_t	typeref:enum:librados::err_t::
OBJ_SIZE_OI_MISMATCH	rados/rados_types.hpp	/^    OBJ_SIZE_OI_MISMATCH      = 1 << 18, \/\/ Old$/;"	m	struct:librados::err_t	typeref:enum:librados::err_t::
OI_ATTR_CORRUPTED	rados/rados_types.hpp	/^    OI_ATTR_CORRUPTED       = 1 << 15, \/\/ Old$/;"	m	struct:librados::err_t	typeref:enum:librados::err_t::
OI_ATTR_MISSING	rados/rados_types.hpp	/^    OI_ATTR_MISSING         = 1 << 14, \/\/ Old$/;"	m	struct:librados::err_t	typeref:enum:librados::err_t::
OI_CORRUPTED	rados/rados_types.hpp	/^    OI_CORRUPTED = 1 << 8,    \/\/ Old$/;"	e	enum:inconsistent_snapset_t::__anon41
OI_MISSING	rados/rados_types.hpp	/^    OI_MISSING   = 1 << 7,    \/\/ Old$/;"	e	enum:inconsistent_snapset_t::__anon41
OMAP_DIGEST_MISMATCH	rados/rados_types.hpp	/^    OMAP_DIGEST_MISMATCH = 1 << 5,$/;"	m	struct:librados::obj_err_t	typeref:enum:librados::obj_err_t::
OMAP_DIGEST_MISMATCH_INFO	rados/rados_types.hpp	/^    OMAP_DIGEST_MISMATCH_INFO = 1 << 10,$/;"	m	struct:librados::err_t	typeref:enum:librados::err_t::
OMAP_DIGEST_MISMATCH_OI	rados/rados_types.hpp	/^    OMAP_DIGEST_MISMATCH_OI = 1 << 10,  \/\/ Old$/;"	m	struct:librados::err_t	typeref:enum:librados::err_t::
OPERATION_BALANCE_READS	rados/librados.hpp	/^    OPERATION_BALANCE_READS      = LIBRADOS_OPERATION_BALANCE_READS,$/;"	e	enum:librados::ObjectOperationGlobalFlags
OPERATION_FULL_FORCE	rados/librados.hpp	/^    OPERATION_FULL_FORCE	 = LIBRADOS_OPERATION_FULL_FORCE,$/;"	e	enum:librados::ObjectOperationGlobalFlags
OPERATION_FULL_TRY	rados/librados.hpp	/^    OPERATION_FULL_TRY           = LIBRADOS_OPERATION_FULL_TRY,$/;"	e	enum:librados::ObjectOperationGlobalFlags
OPERATION_IGNORE_CACHE	rados/librados.hpp	/^    OPERATION_IGNORE_CACHE       = LIBRADOS_OPERATION_IGNORE_CACHE,$/;"	e	enum:librados::ObjectOperationGlobalFlags
OPERATION_IGNORE_OVERLAY	rados/librados.hpp	/^    OPERATION_IGNORE_OVERLAY     = LIBRADOS_OPERATION_IGNORE_OVERLAY,$/;"	e	enum:librados::ObjectOperationGlobalFlags
OPERATION_IGNORE_REDIRECT	rados/librados.hpp	/^    OPERATION_IGNORE_REDIRECT	 = LIBRADOS_OPERATION_IGNORE_REDIRECT,$/;"	e	enum:librados::ObjectOperationGlobalFlags
OPERATION_LOCALIZE_READS	rados/librados.hpp	/^    OPERATION_LOCALIZE_READS     = LIBRADOS_OPERATION_LOCALIZE_READS,$/;"	e	enum:librados::ObjectOperationGlobalFlags
OPERATION_NOFLAG	rados/librados.hpp	/^    OPERATION_NOFLAG             = LIBRADOS_OPERATION_NOFLAG,$/;"	e	enum:librados::ObjectOperationGlobalFlags
OPERATION_ORDER_READS_WRITES	rados/librados.hpp	/^    OPERATION_ORDER_READS_WRITES = LIBRADOS_OPERATION_ORDER_READS_WRITES,$/;"	e	enum:librados::ObjectOperationGlobalFlags
OPERATION_SKIPRWLOCKS	rados/librados.hpp	/^    OPERATION_SKIPRWLOCKS        = LIBRADOS_OPERATION_SKIPRWLOCKS,$/;"	e	enum:librados::ObjectOperationGlobalFlags
OP_EXCL	rados/librados.hpp	/^    OP_EXCL =   LIBRADOS_OP_FLAG_EXCL,$/;"	e	enum:librados::ObjectOperationFlags
OP_FADVISE_DONTNEED	rados/librados.hpp	/^    OP_FADVISE_DONTNEED = LIBRADOS_OP_FLAG_FADVISE_DONTNEED,$/;"	e	enum:librados::ObjectOperationFlags
OP_FADVISE_NOCACHE	rados/librados.hpp	/^    OP_FADVISE_NOCACHE = LIBRADOS_OP_FLAG_FADVISE_NOCACHE,$/;"	e	enum:librados::ObjectOperationFlags
OP_FADVISE_RANDOM	rados/librados.hpp	/^    OP_FADVISE_RANDOM = LIBRADOS_OP_FLAG_FADVISE_RANDOM,$/;"	e	enum:librados::ObjectOperationFlags
OP_FADVISE_SEQUENTIAL	rados/librados.hpp	/^    OP_FADVISE_SEQUENTIAL = LIBRADOS_OP_FLAG_FADVISE_SEQUENTIAL,$/;"	e	enum:librados::ObjectOperationFlags
OP_FADVISE_WILLNEED	rados/librados.hpp	/^    OP_FADVISE_WILLNEED = LIBRADOS_OP_FLAG_FADVISE_WILLNEED,$/;"	e	enum:librados::ObjectOperationFlags
OP_FAILOK	rados/librados.hpp	/^    OP_FAILOK = LIBRADOS_OP_FLAG_FAILOK,$/;"	e	enum:librados::ObjectOperationFlags
OSD_WRITETOOBIG	rados.h	199;"	d
O_DIRECT	types.h	77;"	d
O_DSYNC	compat.h	55;"	d
O_LARGEFILE	compat.h	99;"	d
ObjectCursor	rados/librados.hpp	/^  class CEPH_RADOS_API ObjectCursor$/;"	c	namespace:librados
ObjectItem	rados/librados.hpp	/^  class CEPH_RADOS_API ObjectItem$/;"	c	namespace:librados
ObjectOperation	rados/librados.hpp	/^  class CEPH_RADOS_API ObjectOperation$/;"	c	namespace:librados
ObjectOperationCompletion	rados/librados.hpp	/^  class CEPH_RADOS_API ObjectOperationCompletion {$/;"	c	namespace:librados
ObjectOperationFlags	rados/librados.hpp	/^  enum ObjectOperationFlags {$/;"	g	namespace:librados
ObjectOperationGlobalFlags	rados/librados.hpp	/^  enum ObjectOperationGlobalFlags {$/;"	g	namespace:librados
ObjectReadOperation	rados/librados.hpp	/^    ObjectReadOperation() {}$/;"	f	class:librados::ObjectReadOperation
ObjectReadOperation	rados/librados.hpp	/^  class CEPH_RADOS_API ObjectReadOperation : public ObjectOperation$/;"	c	namespace:librados
ObjectWriteOperation	rados/librados.hpp	/^    ObjectWriteOperation() : unused(NULL) {}$/;"	f	class:librados::ObjectWriteOperation
ObjectWriteOperation	rados/librados.hpp	/^  class CEPH_RADOS_API ObjectWriteOperation : public ObjectOperation$/;"	c	namespace:librados
OnExitManager	on_exit.h	/^    OnExitManager() {$/;"	f	class:OnExitManager
OnExitManager	on_exit.h	/^class OnExitManager {$/;"	c
P	mempool.h	171;"	d
P	mempool.h	176;"	d
P	mempool.h	389;"	d
P	mempool.h	439;"	d
P2ALIGN	intarith.h	55;"	d
P2NPHASE	intarith.h	70;"	d
P2PHASE	intarith.h	62;"	d
P2ROUNDUP	intarith.h	77;"	d
POOL_OP_AUID_CHANGE	ceph_fs.h	/^  POOL_OP_AUID_CHANGE			= 0x03,$/;"	e	enum:__anon44
POOL_OP_CREATE	ceph_fs.h	/^  POOL_OP_CREATE			= 0x01,$/;"	e	enum:__anon44
POOL_OP_CREATE_SNAP	ceph_fs.h	/^  POOL_OP_CREATE_SNAP			= 0x11,$/;"	e	enum:__anon44
POOL_OP_CREATE_UNMANAGED_SNAP	ceph_fs.h	/^  POOL_OP_CREATE_UNMANAGED_SNAP		= 0x21,$/;"	e	enum:__anon44
POOL_OP_DELETE	ceph_fs.h	/^  POOL_OP_DELETE			= 0x02,$/;"	e	enum:__anon44
POOL_OP_DELETE_SNAP	ceph_fs.h	/^  POOL_OP_DELETE_SNAP			= 0x12,$/;"	e	enum:__anon44
POOL_OP_DELETE_UNMANAGED_SNAP	ceph_fs.h	/^  POOL_OP_DELETE_UNMANAGED_SNAP		= 0x22,$/;"	e	enum:__anon44
PROCPREFIX	compat.h	19;"	d
PROCPREFIX	compat.h	26;"	d
PTR_ERR	err.h	/^static inline long PTR_ERR(const void *ptr)$/;"	f
PlacementGroup	rados/librados.hpp	/^  struct CEPH_RADOS_API PlacementGroup {$/;"	s	namespace:librados
PoolAsyncCompletion	rados/librados.hpp	/^    PoolAsyncCompletion(PoolAsyncCompletionImpl *pc_) : pc(pc_) {}$/;"	f	struct:librados::PoolAsyncCompletion
PoolAsyncCompletion	rados/librados.hpp	/^  struct CEPH_RADOS_API PoolAsyncCompletion {$/;"	s	namespace:librados
PrCtl	coredumpctl.h	/^  PrCtl() {}$/;"	f	struct:PrCtl
PrCtl	coredumpctl.h	/^  PrCtl(int new_state = 0) {$/;"	f	struct:PrCtl
PrCtl	coredumpctl.h	/^struct PrCtl {$/;"	s
ProgressContext	rbd/librbd.hpp	/^  class CEPH_RBD_API ProgressContext$/;"	c	namespace:librbd
RADOS_RGW_FILE_H	rados/rgw_file.h	15;"	d
RBD	rbd/librbd.hpp	/^class CEPH_RBD_API RBD$/;"	c	namespace:librbd
RBD_CHILDREN	rbd_types.h	59;"	d
RBD_COMP_NONE	rbd_types.h	97;"	d
RBD_CRYPT_NONE	rbd_types.h	98;"	d
RBD_DATA_PREFIX	rbd_types.h	30;"	d
RBD_DIRECTORY	rbd_types.h	42;"	d
RBD_FEATURES_ALL	rbd/features.h	42;"	d
RBD_FEATURES_DEFAULT	rbd/features.h	13;"	d
RBD_FEATURES_DISABLE_ONLY	rbd/features.h	58;"	d
RBD_FEATURES_INCOMPATIBLE	rbd/features.h	30;"	d
RBD_FEATURES_MUTABLE	rbd/features.h	52;"	d
RBD_FEATURES_RW_INCOMPATIBLE	rbd/features.h	35;"	d
RBD_FEATURES_SINGLE_CLIENT	rbd/features.h	62;"	d
RBD_FEATURE_DATA_POOL	rbd/features.h	11;"	d
RBD_FEATURE_DEEP_FLATTEN	rbd/features.h	9;"	d
RBD_FEATURE_EXCLUSIVE_LOCK	rbd/features.h	6;"	d
RBD_FEATURE_FAST_DIFF	rbd/features.h	8;"	d
RBD_FEATURE_JOURNALING	rbd/features.h	10;"	d
RBD_FEATURE_LAYERING	rbd/features.h	4;"	d
RBD_FEATURE_NAME_DATA_POOL	rbd/features.h	26;"	d
RBD_FEATURE_NAME_DEEP_FLATTEN	rbd/features.h	24;"	d
RBD_FEATURE_NAME_EXCLUSIVE_LOCK	rbd/features.h	21;"	d
RBD_FEATURE_NAME_FAST_DIFF	rbd/features.h	23;"	d
RBD_FEATURE_NAME_JOURNALING	rbd/features.h	25;"	d
RBD_FEATURE_NAME_LAYERING	rbd/features.h	19;"	d
RBD_FEATURE_NAME_OBJECT_MAP	rbd/features.h	22;"	d
RBD_FEATURE_NAME_STRIPINGV2	rbd/features.h	20;"	d
RBD_FEATURE_OBJECT_MAP	rbd/features.h	7;"	d
RBD_FEATURE_STRIPINGV2	rbd/features.h	5;"	d
RBD_FLAG_FAST_DIFF_INVALID	rbd/librbd.h	58;"	d
RBD_FLAG_OBJECT_MAP_INVALID	rbd/librbd.h	57;"	d
RBD_GROUP_DIRECTORY	rbd_types.h	106;"	d
RBD_GROUP_HEADER_PREFIX	rbd_types.h	104;"	d
RBD_HEADER_PREFIX	rbd_types.h	28;"	d
RBD_HEADER_SIGNATURE	rbd_types.h	101;"	d
RBD_HEADER_TEXT	rbd_types.h	100;"	d
RBD_HEADER_VERSION	rbd_types.h	102;"	d
RBD_ID_PREFIX	rbd_types.h	31;"	d
RBD_IMAGE_OPTION_DATA_POOL	rbd/librbd.h	/^  RBD_IMAGE_OPTION_DATA_POOL = 10$/;"	e	enum:__anon85
RBD_IMAGE_OPTION_FEATURES	rbd/librbd.h	/^  RBD_IMAGE_OPTION_FEATURES = 1,$/;"	e	enum:__anon85
RBD_IMAGE_OPTION_FEATURES_CLEAR	rbd/librbd.h	/^  RBD_IMAGE_OPTION_FEATURES_CLEAR = 9,$/;"	e	enum:__anon85
RBD_IMAGE_OPTION_FEATURES_SET	rbd/librbd.h	/^  RBD_IMAGE_OPTION_FEATURES_SET = 8,$/;"	e	enum:__anon85
RBD_IMAGE_OPTION_FORMAT	rbd/librbd.h	/^  RBD_IMAGE_OPTION_FORMAT = 0,$/;"	e	enum:__anon85
RBD_IMAGE_OPTION_JOURNAL_ORDER	rbd/librbd.h	/^  RBD_IMAGE_OPTION_JOURNAL_ORDER = 5,$/;"	e	enum:__anon85
RBD_IMAGE_OPTION_JOURNAL_POOL	rbd/librbd.h	/^  RBD_IMAGE_OPTION_JOURNAL_POOL = 7,$/;"	e	enum:__anon85
RBD_IMAGE_OPTION_JOURNAL_SPLAY_WIDTH	rbd/librbd.h	/^  RBD_IMAGE_OPTION_JOURNAL_SPLAY_WIDTH = 6,$/;"	e	enum:__anon85
RBD_IMAGE_OPTION_ORDER	rbd/librbd.h	/^  RBD_IMAGE_OPTION_ORDER = 2,$/;"	e	enum:__anon85
RBD_IMAGE_OPTION_STRIPE_COUNT	rbd/librbd.h	/^  RBD_IMAGE_OPTION_STRIPE_COUNT = 4,$/;"	e	enum:__anon85
RBD_IMAGE_OPTION_STRIPE_UNIT	rbd/librbd.h	/^  RBD_IMAGE_OPTION_STRIPE_UNIT = 3,$/;"	e	enum:__anon85
RBD_INFO	rbd_types.h	43;"	d
RBD_LOCK_MODE_EXCLUSIVE	rbd/librbd.h	/^  RBD_LOCK_MODE_EXCLUSIVE = 0,$/;"	e	enum:__anon84
RBD_LOCK_MODE_SHARED	rbd/librbd.h	/^  RBD_LOCK_MODE_SHARED = 1,$/;"	e	enum:__anon84
RBD_LOCK_NAME	rbd_types.h	60;"	d
RBD_MAX_BLOCK_NAME_PREFIX_LENGTH	rbd_types.h	95;"	d
RBD_MAX_BLOCK_NAME_SIZE	rbd/librbd.h	78;"	d
RBD_MAX_BLOCK_NAME_SIZE	rbd_types.h	76;"	d
RBD_MAX_IMAGE_ID_LENGTH	rbd_types.h	84;"	d
RBD_MAX_IMAGE_NAME_SIZE	rbd/librbd.h	77;"	d
RBD_MAX_OBJ_NAME_SIZE	rbd_types.h	75;"	d
RBD_MIRRORING	rbd_types.h	66;"	d
RBD_MIRROR_IMAGE_DISABLED	rbd/librbd.h	/^  RBD_MIRROR_IMAGE_DISABLED = 2$/;"	e	enum:__anon80
RBD_MIRROR_IMAGE_DISABLING	rbd/librbd.h	/^  RBD_MIRROR_IMAGE_DISABLING = 0,$/;"	e	enum:__anon80
RBD_MIRROR_IMAGE_ENABLED	rbd/librbd.h	/^  RBD_MIRROR_IMAGE_ENABLED = 1,$/;"	e	enum:__anon80
RBD_MIRROR_INSTANCE_PREFIX	rbd_types.h	73;"	d
RBD_MIRROR_LEADER	rbd_types.h	72;"	d
RBD_MIRROR_MODE_DISABLED	rbd/librbd.h	/^  RBD_MIRROR_MODE_DISABLED, \/* mirroring is disabled *\/$/;"	e	enum:__anon78
RBD_MIRROR_MODE_IMAGE	rbd/librbd.h	/^  RBD_MIRROR_MODE_IMAGE,    \/* mirroring enabled on a per-image basis *\/$/;"	e	enum:__anon78
RBD_MIRROR_MODE_POOL	rbd/librbd.h	/^  RBD_MIRROR_MODE_POOL      \/* mirroring enabled on all journaled images *\/$/;"	e	enum:__anon78
RBD_OBJECT_MAP_PREFIX	rbd_types.h	29;"	d
RBD_PROTECTION_STATUS_LAST	rbd_types.h	/^  RBD_PROTECTION_STATUS_LAST         = 3$/;"	e	enum:__anon33
RBD_PROTECTION_STATUS_PROTECTED	rbd_types.h	/^  RBD_PROTECTION_STATUS_PROTECTED    = 2,$/;"	e	enum:__anon33
RBD_PROTECTION_STATUS_UNPROTECTED	rbd_types.h	/^  RBD_PROTECTION_STATUS_UNPROTECTED  = 0,$/;"	e	enum:__anon33
RBD_PROTECTION_STATUS_UNPROTECTING	rbd_types.h	/^  RBD_PROTECTION_STATUS_UNPROTECTING = 1,$/;"	e	enum:__anon33
RBD_SNAP_REMOVE_FLATTEN	rbd/librbd.h	81;"	d
RBD_SNAP_REMOVE_FORCE	rbd/librbd.h	82;"	d
RBD_SNAP_REMOVE_UNPROTECT	rbd/librbd.h	80;"	d
RBD_SUFFIX	rbd_types.h	41;"	d
RBD_TRASH	rbd_types.h	108;"	d
RBD_TRASH_IMAGE_SOURCE_MIRRORING	rbd/librbd.h	/^  RBD_TRASH_IMAGE_SOURCE_MIRRORING = 1$/;"	e	enum:__anon86
RBD_TRASH_IMAGE_SOURCE_USER	rbd/librbd.h	/^  RBD_TRASH_IMAGE_SOURCE_USER = 0,$/;"	e	enum:__anon86
RGW_CLOSE_FLAG_NONE	rados/rgw_file.h	280;"	d
RGW_CLOSE_FLAG_RELE	rados/rgw_file.h	281;"	d
RGW_COMMIT_FLAG_NONE	rados/rgw_file.h	353;"	d
RGW_CREATE_FLAG_NONE	rados/rgw_file.h	174;"	d
RGW_DIRENT_OFFSET_FLAG_NONE	rados/rgw_file.h	231;"	d
RGW_FH_RELE_FLAG_NONE	rados/rgw_file.h	115;"	d
RGW_FSYNC_FLAG_NONE	rados/rgw_file.h	344;"	d
RGW_FS_TYPE_DIRECTORY	rados/rgw_file.h	/^  RGW_FS_TYPE_DIRECTORY,$/;"	e	enum:rgw_fh_type
RGW_FS_TYPE_FILE	rados/rgw_file.h	/^  RGW_FS_TYPE_FILE,$/;"	e	enum:rgw_fh_type
RGW_FS_TYPE_NIL	rados/rgw_file.h	/^  RGW_FS_TYPE_NIL = 0,$/;"	e	enum:rgw_fh_type
RGW_GETATTR_FLAG_NONE	rados/rgw_file.h	241;"	d
RGW_LOOKUP_FLAG_CREATE	rados/rgw_file.h	94;"	d
RGW_LOOKUP_FLAG_DIR	rados/rgw_file.h	96;"	d
RGW_LOOKUP_FLAG_FILE	rados/rgw_file.h	97;"	d
RGW_LOOKUP_FLAG_NONE	rados/rgw_file.h	93;"	d
RGW_LOOKUP_FLAG_RCB	rados/rgw_file.h	95;"	d
RGW_LOOKUP_TYPE_FLAGS	rados/rgw_file.h	99;"	d
RGW_MKDIR_FLAG_NONE	rados/rgw_file.h	184;"	d
RGW_MOUNT_FLAG_NONE	rados/rgw_file.h	123;"	d
RGW_OPEN_FLAG_CREATE	rados/rgw_file.h	269;"	d
RGW_OPEN_FLAG_NONE	rados/rgw_file.h	268;"	d
RGW_OPEN_FLAG_STATELESS	rados/rgw_file.h	271;"	d
RGW_OPEN_FLAG_V3	rados/rgw_file.h	270;"	d
RGW_READDIR_FLAG_DOTDOT	rados/rgw_file.h	217;"	d
RGW_READDIR_FLAG_NONE	rados/rgw_file.h	216;"	d
RGW_READ_FLAG_NONE	rados/rgw_file.h	289;"	d
RGW_REG_INVALIDATE_FLAG_NONE	rados/rgw_file.h	136;"	d
RGW_RENAME_FLAG_NONE	rados/rgw_file.h	194;"	d
RGW_SETATTR_ATIME	rados/rgw_file.h	167;"	d
RGW_SETATTR_CTIME	rados/rgw_file.h	169;"	d
RGW_SETATTR_FLAG_NONE	rados/rgw_file.h	250;"	d
RGW_SETATTR_GID	rados/rgw_file.h	165;"	d
RGW_SETATTR_MODE	rados/rgw_file.h	163;"	d
RGW_SETATTR_MTIME	rados/rgw_file.h	166;"	d
RGW_SETATTR_SIZE	rados/rgw_file.h	168;"	d
RGW_SETATTR_UID	rados/rgw_file.h	164;"	d
RGW_STATFS_FLAG_NONE	rados/rgw_file.h	154;"	d
RGW_TRUNCATE_FLAG_NONE	rados/rgw_file.h	259;"	d
RGW_UIO_BUFQ	rados/rgw_file.h	309;"	d
RGW_UIO_FREE	rados/rgw_file.h	308;"	d
RGW_UIO_GIFT	rados/rgw_file.h	307;"	d
RGW_UIO_NONE	rados/rgw_file.h	306;"	d
RGW_UMOUNT_FLAG_NONE	rados/rgw_file.h	146;"	d
RGW_UNLINK_FLAG_NONE	rados/rgw_file.h	204;"	d
RGW_WRITE_FLAG_NONE	rados/rgw_file.h	299;"	d
ROUND_UP_TO	intarith.h	31;"	d
Rados	rados/librados.hpp	/^  class CEPH_RADOS_API Rados$/;"	c	namespace:librados
RadosStriper	radosstriper/libradosstriper.hpp	/^  class RadosStriper$/;"	c	namespace:libradosstriper
RunOnDelete	Context.h	/^  RunOnDelete(Context *to_run) : to_run(to_run) {}$/;"	f	struct:RunOnDelete
RunOnDelete	Context.h	/^struct RunOnDelete {$/;"	s
RunOnDeleteRef	Context.h	/^typedef ceph::shared_ptr<RunOnDelete> RunOnDeleteRef;$/;"	t
SCOPE_GUARD	scope_guard.h	16;"	d
SHALLOW_ERRORS	rados/rados_types.hpp	/^  static constexpr uint64_t SHALLOW_ERRORS = OBJECT_INFO_INCONSISTENCY|SIZE_MISMATCH|ATTR_VALUE_MISMATCH|ATTR_NAME_MISMATCH|SNAPSET_INCONSISTENCY|HINFO_INCONSISTENCY;$/;"	m	namespace:librados
SHALLOW_ERRORS	rados/rados_types.hpp	/^  static constexpr uint64_t SHALLOW_ERRORS = SHARD_MISSING|SHARD_STAT_ERR|SIZE_MISMATCH_INFO|INFO_MISSING|INFO_CORRUPTED|SNAPSET_MISSING|SNAPSET_CORRUPTED|OBJ_SIZE_INFO_MISMATCH|HINFO_MISSING|HINFO_CORRUPTED;$/;"	m	struct:librados::err_t
SHARD_EC_HASH_MISMATCH	rados/rados_types.hpp	/^    SHARD_EC_HASH_MISMATCH  = 1 << 12,$/;"	m	struct:librados::err_t	typeref:enum:librados::err_t::
SHARD_EC_SIZE_MISMATCH	rados/rados_types.hpp	/^    SHARD_EC_SIZE_MISMATCH  = 1 << 13,$/;"	m	struct:librados::err_t	typeref:enum:librados::err_t::
SHARD_READ_ERR	rados/rados_types.hpp	/^    SHARD_READ_ERR       = 1 << 3,$/;"	m	struct:librados::err_t	typeref:enum:librados::err_t::
SHARD_STAT_ERR	rados/rados_types.hpp	/^    SHARD_STAT_ERR       = 1 << 2,$/;"	m	struct:librados::err_t	typeref:enum:librados::err_t::
SHIFT_ROUND_UP	intarith.h	35;"	d
SIZE_MISMATCH	rados/rados_types.hpp	/^    SIZE_MISMATCH        = 1 << 6,$/;"	m	struct:librados::obj_err_t	typeref:enum:librados::obj_err_t::
SIZE_MISMATCH	rados/rados_types.hpp	/^    SIZE_MISMATCH  = 1 << 6,$/;"	e	enum:inconsistent_snapset_t::__anon41
SIZE_MISMATCH_INFO	rados/rados_types.hpp	/^    SIZE_MISMATCH_INFO        = 1 << 11,$/;"	m	struct:librados::err_t	typeref:enum:librados::err_t::
SIZE_MISMATCH_OI	rados/rados_types.hpp	/^    SIZE_MISMATCH_OI        = 1 << 11,  \/\/ Old$/;"	m	struct:librados::err_t	typeref:enum:librados::err_t::
SNAPSET_CORRUPTED	rados/rados_types.hpp	/^    SNAPSET_CORRUPTED       = 1 << 17,$/;"	m	struct:librados::err_t	typeref:enum:librados::err_t::
SNAPSET_CORRUPTED	rados/rados_types.hpp	/^    SNAPSET_CORRUPTED = 1 << 1,$/;"	e	enum:inconsistent_snapset_t::__anon41
SNAPSET_INCONSISTENCY	rados/rados_types.hpp	/^    SNAPSET_INCONSISTENCY   = 1 << 9,$/;"	m	struct:librados::obj_err_t	typeref:enum:librados::obj_err_t::
SNAPSET_MISSING	rados/rados_types.hpp	/^    SNAPSET_MISSING         = 1 << 16,$/;"	m	struct:librados::err_t	typeref:enum:librados::err_t::
SNAPSET_MISSING	rados/rados_types.hpp	/^    SNAPSET_MISSING = 1 << 0,$/;"	e	enum:inconsistent_snapset_t::__anon41
SNAP_DIR	rados/rados_types.hpp	/^  SNAP_DIR = (uint64_t)(-1)$/;"	e	enum:librados::__anon40
SNAP_ERROR	rados/rados_types.hpp	/^    SNAP_ERROR  = 1 << 3,$/;"	e	enum:inconsistent_snapset_t::__anon41
SNAP_HEAD	rados/rados_types.hpp	/^  SNAP_HEAD = (uint64_t)(-2),$/;"	e	enum:librados::__anon40
SS_ATTR_CORRUPTED	rados/rados_types.hpp	/^    SS_ATTR_CORRUPTED       = 1 << 17, \/\/ Old$/;"	m	struct:librados::err_t	typeref:enum:librados::err_t::
SS_ATTR_MISSING	rados/rados_types.hpp	/^    SS_ATTR_MISSING         = 1 << 16, \/\/ Old$/;"	m	struct:librados::err_t	typeref:enum:librados::err_t::
SYSERROR	error.h	22;"	d
S_ISVALIDATIME	statlite.h	53;"	d
S_ISVALIDBLKSIZE	statlite.h	51;"	d
S_ISVALIDBLOCKS	statlite.h	52;"	d
S_ISVALIDCTIME	statlite.h	55;"	d
S_ISVALIDMTIME	statlite.h	54;"	d
S_ISVALIDSIZE	statlite.h	50;"	d
S_REQUIREATIME	statlite.h	46;"	d
S_REQUIREBLKSIZE	statlite.h	44;"	d
S_REQUIREBLOCKS	statlite.h	45;"	d
S_REQUIRECTIME	statlite.h	48;"	d
S_REQUIREMTIME	statlite.h	47;"	d
S_REQUIRESIZE	statlite.h	43;"	d
S_STATLITE_ATIME	statlite.h	39;"	d
S_STATLITE_BLKSIZE	statlite.h	37;"	d
S_STATLITE_BLOCKS	statlite.h	38;"	d
S_STATLITE_CTIME	statlite.h	41;"	d
S_STATLITE_MTIME	statlite.h	40;"	d
S_STATLITE_SIZE	statlite.h	36;"	d
Spinlock	Spinlock.h	/^  Spinlock() {$/;"	f	class:Spinlock
Spinlock	Spinlock.h	/^class Spinlock {$/;"	c
TEMP_FAILURE_RETRY	compat.h	108;"	d
TEXT_BLUE	color.h	9;"	d
TEXT_CYAN	color.h	11;"	d
TEXT_GREEN	color.h	7;"	d
TEXT_MAGENTA	color.h	10;"	d
TEXT_NORMAL	color.h	4;"	d
TEXT_RED	color.h	6;"	d
TEXT_YELLOW	color.h	8;"	d
UTIL_BTREE_BTREE_CONTAINER_H__	cpp-btree/btree_container.h	16;"	d
UTIL_BTREE_BTREE_H__	cpp-btree/btree.h	101;"	d
UTIL_BTREE_BTREE_MAP_H__	cpp-btree/btree_map.h	23;"	d
UTIL_BTREE_BTREE_SET_H__	cpp-btree/btree_set.h	21;"	d
UpdateWatchCtx	rbd/librbd.hpp	/^class CEPH_RBD_API UpdateWatchCtx {$/;"	c	namespace:librbd
UserPerm	cephfs/libcephfs.h	/^typedef struct UserPerm UserPerm;$/;"	t	typeref:struct:UserPerm
VOIDPTR_RADOS_T	cephfs/libcephfs.h	212;"	d
VOIDPTR_RADOS_T	rados/librados.h	178;"	d
VOID_TEMP_FAILURE_RETRY	compat.h	117;"	d
VOID_TEMP_FAILURE_RETRY	compat.h	120;"	d
WRITE_CLASS_DENC	denc.h	1522;"	d
WRITE_CLASS_DENC_BOUNDED	denc.h	1523;"	d
WRITE_CLASS_DENC_FEATURED	denc.h	1542;"	d
WRITE_CLASS_DENC_FEATURED_BOUNDED	denc.h	1543;"	d
WRITE_CLASS_ENCODER	encoding.h	156;"	d
WRITE_CLASS_ENCODER_FEATURES	encoding.h	166;"	d
WRITE_CLASS_ENCODER_OPTIONAL_FEATURES	encoding.h	171;"	d
WRITE_CLASS_MEMBER_ENCODER	encoding.h	161;"	d
WRITE_CMP_OPERATORS_1	cmp.h	16;"	d
WRITE_CMP_OPERATORS_2	cmp.h	38;"	d
WRITE_CMP_OPERATORS_3	cmp.h	65;"	d
WRITE_CMP_OPERATORS_4	cmp.h	95;"	d
WRITE_CMP_OPERATORS_5	cmp.h	131;"	d
WRITE_CMP_OPERATORS_7	cmp.h	168;"	d
WRITE_EQ_OPERATORS_1	cmp.h	8;"	d
WRITE_EQ_OPERATORS_2	cmp.h	30;"	d
WRITE_EQ_OPERATORS_3	cmp.h	57;"	d
WRITE_EQ_OPERATORS_4	cmp.h	87;"	d
WRITE_EQ_OPERATORS_5	cmp.h	123;"	d
WRITE_EQ_OPERATORS_7	cmp.h	161;"	d
WRITE_INTTYPE_ENCODER	encoding.h	108;"	d
WRITE_RAW_ENCODER	encoding.h	77;"	d
WatchCtx	rados/librados.hpp	/^  class CEPH_RADOS_API WatchCtx {$/;"	c	namespace:librados
WatchCtx2	rados/librados.hpp	/^  class CEPH_RADOS_API WatchCtx2 {$/;"	c	namespace:librados
Wrapper	Context.h	/^  Wrapper(Context *to_run, T val) : to_run(to_run), val(val) {}$/;"	f	struct:Wrapper
Wrapper	Context.h	/^struct Wrapper : public Context {$/;"	s
_ASSERT_H	assert.h	116;"	d
_ASSERT_H	assert.h	117;"	d
_BACKWARD_BACKWARD_WARNING_H	encoding.h	299;"	d
_BACKWARD_BACKWARD_WARNING_H	types.h	43;"	d
_CEPH_ASSERT_VOID_CAST	assert.h	76;"	d
_CEPH_ASSERT_VOID_CAST	assert.h	78;"	d
_CEPH_INCLUDE_MEMPOOL_H	mempool.h	16;"	d
_CEPH_UUID_H	uuid.h	2;"	d
_DECLARE_CLASS_DENC	denc.h	1524;"	d
_DECLARE_CLASS_DENC_FEATURED	denc.h	1544;"	d
_ENC_DEC_H	denc.h	25;"	d
_LINUX_FIEMAP_H	linux_fiemap.h	11;"	d
_XOPEN_SOURCE	buffer.h	23;"	d
_XOPEN_SOURCE	rados/buffer.h	23;"	d
__ASSERT_FUNCTION	assert.h	121;"	d
__ASSERT_FUNCTION	assert.h	122;"	d
__CEPH_ASSERT_FUNCTION	assert.h	58;"	d
__CEPH_ASSERT_FUNCTION	assert.h	60;"	d
__CEPH_ASSERT_FUNCTION	assert.h	62;"	d
__CEPH_CMP_H	cmp.h	2;"	d
__CEPH_FEATURES	ceph_features.h	2;"	d
__CEPH_FORALL_OSD_OPS	rados.h	/^__CEPH_FORALL_OSD_OPS(GENERATE_ENUM_ENTRY)$/;"	e	enum:__anon2
__CEPH_FORALL_OSD_OPS	rados.h	228;"	d
__CEPH_NO_PRETTY_FUNC	assert.h	48;"	d
__CEPH_OSD_OP	rados.h	225;"	d
__CEPH_OSD_OP1	rados.h	222;"	d
__CEPH_STRINGIFY_H	stringify.h	2;"	d
__DECODE_START_LEGACY_COMPAT_LEN	encoding.h	1096;"	d
__EndObjectIterator	rados/librados.hpp	/^    static const NObjectIterator __EndObjectIterator;$/;"	m	class:librados::NObjectIterator
__GNUC_PREREQ	assert.h	15;"	d
__LIBRADOSSTRIPER_HPP	radosstriper/libradosstriper.hpp	2;"	d
__LIBRADOS_HPP	rados/librados.hpp	2;"	d
__LIBRBD_HPP	rbd/librbd.hpp	16;"	d
__STRING	assert.h	10;"	d
__STRING	compat.h	131;"	d
____build_time_check_for_reserved_bits	ceph_features.h	/^static inline void ____build_time_check_for_reserved_bits(void) {$/;"	f
__be16	int_types.h	/^typedef __u16 __bitwise__ __be16;$/;"	t
__be32	int_types.h	/^typedef __u32 __bitwise__ __be32;$/;"	t
__be64	int_types.h	/^typedef __u64 __bitwise__ __be64;$/;"	t
__bitwise__	int_types.h	44;"	d
__le16	int_types.h	/^typedef __u16 __bitwise__ __le16;$/;"	t
__le16	types.h	29;"	d
__le16	types.h	35;"	d
__le32	int_types.h	/^typedef __u32 __bitwise__ __le32;$/;"	t
__le32	types.h	30;"	d
__le32	types.h	36;"	d
__le64	int_types.h	/^typedef __u64 __bitwise__ __le64;$/;"	t
__le64	types.h	31;"	d
__le64	types.h	37;"	d
__padding	mempool.h	/^  char __padding[128 - sizeof(std::atomic<size_t>)*2];$/;"	m	struct:mempool::shard_t
__s16	int_types.h	/^typedef int16_t __s16;$/;"	t
__s32	int_types.h	/^typedef int32_t __s32;$/;"	t
__s64	int_types.h	/^typedef int64_t __s64;$/;"	t
__s8	int_types.h	/^typedef int8_t __s8;$/;"	t
__u16	int_types.h	/^typedef uint16_t __u16;$/;"	t
__u32	int_types.h	/^typedef uint32_t __u32;$/;"	t
__u64	int_types.h	/^typedef uint64_t __u64;$/;"	t
__u8	int_types.h	/^typedef uint8_t __u8;$/;"	t
_back	xlist.h	/^  item *_front, *_back;$/;"	m	class:xlist
_buffers	buffer.h	/^    std::list<ptr> _buffers;$/;"	m	class:ceph::CEPH_BUFFER_API::list
_buffers	rados/buffer.h	/^    std::list<ptr> _buffers;$/;"	m	class:ceph::CEPH_BUFFER_API::list
_count	counter.h	/^  static std::atomic<uint64_t> &_count() {$/;"	f	class:Counter
_data	bitmapper.h	/^  char *_data;$/;"	m	class:bitmapper
_denc	denc.h	/^namespace _denc {$/;"	n
_enc	frag.h	/^  _frag_t _enc;  $/;"	m	class:frag_t
_frag_t	frag.h	/^typedef uint32_t _frag_t;$/;"	t
_front	xlist.h	/^  item *_front, *_back;$/;"	m	class:xlist
_head	elist.h	/^  item _head;$/;"	m	class:elist
_increments	counter.h	/^  static std::atomic<uint64_t> &_increments() {$/;"	f	class:Counter
_inodeno_t	fs_types.h	/^typedef uint64_t _inodeno_t;$/;"	t
_item	xlist.h	/^    T _item;$/;"	m	struct:xlist::item
_iter	interval_set.h	/^        typename Map::const_iterator _iter;$/;"	m	class:interval_set::const_iterator
_iter	interval_set.h	/^        typename Map::iterator _iter;$/;"	m	class:interval_set::iterator
_len	bitmapper.h	/^  int _len;$/;"	m	class:bitmapper
_len	buffer.h	/^    unsigned _len;$/;"	m	class:ceph::CEPH_BUFFER_API::list
_len	buffer.h	/^    unsigned _off, _len;$/;"	m	class:ceph::CEPH_BUFFER_API::ptr
_len	rados/buffer.h	/^    unsigned _len;$/;"	m	class:ceph::CEPH_BUFFER_API::list
_len	rados/buffer.h	/^    unsigned _off, _len;$/;"	m	class:ceph::CEPH_BUFFER_API::ptr
_list	xlist.h	/^    xlist *_list;$/;"	m	struct:xlist::item
_lock	Spinlock.h	/^  mutable ceph_spinlock_t _lock;$/;"	m	class:Spinlock
_memcopy_count	buffer.h	/^    unsigned _memcopy_count; \/\/the total of memcopy using rebuild().$/;"	m	class:ceph::CEPH_BUFFER_API::list
_memcopy_count	rados/buffer.h	/^    unsigned _memcopy_count; \/\/the total of memcopy using rebuild().$/;"	m	class:ceph::CEPH_BUFFER_API::list
_next	elist.h	/^    item *_prev, *_next;$/;"	m	struct:elist::item
_next	xlist.h	/^    item *_prev, *_next;$/;"	m	struct:xlist::item
_off	buffer.h	/^    unsigned _off, _len;$/;"	m	class:ceph::CEPH_BUFFER_API::ptr
_off	rados/buffer.h	/^    unsigned _off, _len;$/;"	m	class:ceph::CEPH_BUFFER_API::ptr
_prev	elist.h	/^    item *_prev, *_next;$/;"	m	struct:elist::item
_prev	xlist.h	/^    item *_prev, *_next;$/;"	m	struct:xlist::item
_rangeset_base	rangeset.h	/^struct _rangeset_base {$/;"	s
_raw	buffer.h	/^    raw *_raw;$/;"	m	class:ceph::CEPH_BUFFER_API::ptr
_raw	rados/buffer.h	/^    raw *_raw;$/;"	m	class:ceph::CEPH_BUFFER_API::ptr
_set	frag.h	/^  std::set<frag_t> _set;$/;"	m	class:fragset_t
_set_ino	filepath.h	/^  void _set_ino(inodeno_t i) { ino = i; }$/;"	f	class:filepath
_size	interval_set.h	/^  int64_t _size;$/;"	m	class:interval_set
_size	rangeset.h	/^  inodeno_t _size;$/;"	m	class:rangeset
_size	xlist.h	/^  size_t _size;$/;"	m	class:xlist
_snapid_t	cephfs/libcephfs.h	/^typedef struct _snapid_t {$/;"	s
_splits	frag.h	/^  compact_map<frag_t,int32_t> _splits;$/;"	m	class:fragtree_t
a_traits	denc.h	/^  typedef denc_traits<A> a_traits;$/;"	t	struct:denc_traits
absolute	filepath.h	/^  bool absolute() const { return ino == 1; }$/;"	f	class:filepath
action	ceph_fs.h	/^	__u8 action;            \/* CEPH_MDS_LEASE_* *\/$/;"	m	struct:ceph_mds_lease
activate	Context.h	/^  void activate() {$/;"	f	class:C_GatherBase
activate	Context.h	/^  void activate() {$/;"	f	class:C_GatherBuilderBase
activated	Context.h	/^  bool activated;$/;"	m	class:C_GatherBase
activated	Context.h	/^  bool activated;$/;"	m	class:C_GatherBuilderBase
add	Context.h	/^  void add(ContextType* c) {$/;"	f	class:C_ContextsBase
add	Distribution.h	/^  void add(int val, float pr) {$/;"	f	class:Distribution
add_callback	on_exit.h	/^    void add_callback(callback_t func, void *arg) {$/;"	f	class:OnExitManager
addr	msgr.h	/^	struct ceph_entity_addr addr;$/;"	m	struct:ceph_entity_inst	typeref:struct:ceph_entity_inst::ceph_entity_addr
addr	rados/rados_types.h	/^  char addr[256];$/;"	m	struct:obj_watch_t
address	rados/librados.hpp	/^    std::string address;$/;"	m	struct:librados::__anon42
address	rbd/librbd.hpp	/^    std::string address;$/;"	m	struct:librbd::__anon70
adjust	lru.h	/^  void adjust() {$/;"	f	class:LRU
advance	buffer.h	/^      void advance(size_t len) {$/;"	f	class:ceph::CEPH_BUFFER_API::ptr::iterator
advance	rados/buffer.h	/^      void advance(size_t len) {$/;"	f	class:ceph::CEPH_BUFFER_API::ptr::iterator
alloc_hint	rados.h	/^		} __attribute__ ((packed)) alloc_hint;$/;"	m	union:ceph_osd_op::__anon13	typeref:struct:ceph_osd_op::__anon13::__anon27
alloc_internal	compact_map.h	/^  void alloc_internal() {$/;"	f	class:compact_map_base
alloc_internal	compact_set.h	/^  void alloc_internal() {$/;"	f	class:compact_set_base
alloc_ptr	alloc_ptr.h	/^      alloc_ptr(U&& u) : ptr(std::forward<U>(u)) {}$/;"	f	class:alloc_ptr
alloc_ptr	alloc_ptr.h	/^    alloc_ptr() : ptr() {}$/;"	f	class:alloc_ptr
alloc_ptr	alloc_ptr.h	/^    alloc_ptr(alloc_ptr<pointer>&& rhs) : ptr(std::move(rhs.ptr)) {}$/;"	f	class:alloc_ptr
alloc_ptr	alloc_ptr.h	/^class alloc_ptr$/;"	c
allocate	mempool.h	/^  T* allocate(size_t n, void *p = nullptr) {$/;"	f	class:mempool::pool_allocator
allocate_aligned	mempool.h	/^  T* allocate_aligned(size_t n, size_t align, void *p = nullptr) {$/;"	f	class:mempool::pool_allocator
allocator_type	cpp-btree/btree.h	/^  typedef Alloc allocator_type;$/;"	t	struct:btree::btree_common_params
allocator_type	cpp-btree/btree.h	/^  typedef typename Params::allocator_type allocator_type;$/;"	t	class:btree::btree
allocator_type	cpp-btree/btree_container.h	/^  typedef typename Tree::allocator_type allocator_type;$/;"	t	class:btree::btree_container
allocator_type	cpp-btree/btree_container.h	/^  typedef typename Tree::allocator_type allocator_type;$/;"	t	class:btree::btree_map_container
allocator_type	cpp-btree/btree_container.h	/^  typedef typename Tree::allocator_type allocator_type;$/;"	t	class:btree::btree_multi_container
allocator_type	cpp-btree/btree_container.h	/^  typedef typename Tree::allocator_type allocator_type;$/;"	t	class:btree::btree_unique_container
allocator_type	cpp-btree/btree_map.h	/^  typedef typename btree_type::allocator_type allocator_type;$/;"	t	class:btree::btree_map
allocator_type	cpp-btree/btree_map.h	/^  typedef typename btree_type::allocator_type allocator_type;$/;"	t	class:btree::btree_multimap
allocator_type	cpp-btree/btree_set.h	/^  typedef typename btree_type::allocator_type allocator_type;$/;"	t	class:btree::btree_multiset
allocator_type	cpp-btree/btree_set.h	/^  typedef typename btree_type::allocator_type allocator_type;$/;"	t	class:btree::btree_set
allocator_type	mempool.h	/^  typedef pool_allocator<pool_ix, T> allocator_type;$/;"	t	class:mempool::pool_allocator
append	buffer.h	/^      void append(const bufferlist& l) {$/;"	f	class:ceph::CEPH_BUFFER_API::list::contiguous_appender
append	buffer.h	/^      void append(const bufferptr& p) {$/;"	f	class:ceph::CEPH_BUFFER_API::list::contiguous_appender
append	buffer.h	/^      void append(const char *buf, size_t len) {$/;"	f	class:ceph::CEPH_BUFFER_API::list::page_aligned_appender
append	buffer.h	/^      void append(const char *p, size_t l) {$/;"	f	class:ceph::CEPH_BUFFER_API::list::contiguous_appender
append	buffer.h	/^    void append(const std::string& s) {$/;"	f	class:ceph::CEPH_BUFFER_API::list
append	filepath.h	/^  void append(const filepath& a) {$/;"	f	class:filepath
append	rados/buffer.h	/^      void append(const bufferlist& l) {$/;"	f	class:ceph::CEPH_BUFFER_API::list::contiguous_appender
append	rados/buffer.h	/^      void append(const bufferptr& p) {$/;"	f	class:ceph::CEPH_BUFFER_API::list::contiguous_appender
append	rados/buffer.h	/^      void append(const char *buf, size_t len) {$/;"	f	class:ceph::CEPH_BUFFER_API::list::page_aligned_appender
append	rados/buffer.h	/^      void append(const char *p, size_t l) {$/;"	f	class:ceph::CEPH_BUFFER_API::list::contiguous_appender
append	rados/buffer.h	/^    void append(const std::string& s) {$/;"	f	class:ceph::CEPH_BUFFER_API::list
append_buffer	buffer.h	/^    ptr append_buffer;  \/\/ where i put small appends.$/;"	m	class:ceph::CEPH_BUFFER_API::list
append_buffer	rados/buffer.h	/^    ptr append_buffer;  \/\/ where i put small appends.$/;"	m	class:ceph::CEPH_BUFFER_API::list
arg	on_exit.h	/^      void *arg;$/;"	m	struct:OnExitManager::cb
argc	rados.h	/^			__u8 argc;$/;"	m	struct:ceph_osd_op::__anon13::__anon16
args	ceph_fs.h	/^	union ceph_mds_request_args args;$/;"	m	struct:ceph_mds_request_head	typeref:union:ceph_mds_request_head::ceph_mds_request_args
args	ceph_fs.h	/^	union ceph_mds_request_args_legacy args;$/;"	m	struct:ceph_mds_request_head_legacy	typeref:union:ceph_mds_request_head_legacy::ceph_mds_request_args_legacy
asctime	utime.h	/^  ostream& asctime(ostream& out) const {$/;"	f	class:utime_t
assert	assert.h	110;"	d
assert	assert.h	124;"	d
assert_ver	rados.h	/^		} __attribute__ ((packed)) assert_ver;$/;"	m	union:ceph_osd_op::__anon13	typeref:struct:ceph_osd_op::__anon13::__anon21
assert_warn	assert.h	81;"	d
assertf	assert.h	142;"	d
at_buffer_head	buffer.h	/^    bool at_buffer_head() const { return _off == 0; }$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
at_buffer_head	rados/buffer.h	/^    bool at_buffer_head() const { return _off == 0; }$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
atime	ceph_fs.h	/^			struct ceph_timespec mtime, atime, ctime;$/;"	m	struct:ceph_mds_caps_body_legacy::__anon66::__anon67	typeref:struct:ceph_mds_caps_body_legacy::__anon66::__anon67::
atime	ceph_fs.h	/^		struct ceph_timespec atime;$/;"	m	struct:ceph_mds_request_args::__anon57	typeref:struct:ceph_mds_request_args::__anon57::ceph_timespec
atime	ceph_fs.h	/^		struct ceph_timespec atime;$/;"	m	struct:ceph_mds_request_args_legacy::__anon48	typeref:struct:ceph_mds_request_args_legacy::__anon48::ceph_timespec
atime	ceph_fs.h	/^	struct ceph_timespec mtime, atime;$/;"	m	struct:ceph_mds_cap_reconnect_v1	typeref:struct:ceph_mds_cap_reconnect_v1::
attrs	rados/rados_types.hpp	/^  std::map<std::string, ceph::bufferlist> attrs;$/;"	m	struct:librados::shard_info_t
auid	ceph_fs.h	/^	__le64 auid;$/;"	m	struct:ceph_mon_poolop
auid_t	rados/librados.hpp	/^  typedef uint64_t auid_t;$/;"	t	namespace:librados
auth	ceph_fs.h	/^	__le32 auth;            \/* auth mds, if this is a delegation point *\/$/;"	m	struct:ceph_mds_reply_dirfrag
authorizer_len	msgr.h	/^	__le32 authorizer_len;$/;"	m	struct:ceph_msg_connect
authorizer_len	msgr.h	/^	__le32 authorizer_len;$/;"	m	struct:ceph_msg_connect_reply
authorizer_protocol	msgr.h	/^	__le32 authorizer_protocol;$/;"	m	struct:ceph_msg_connect
avail_percent	util.h	/^  int avail_percent;$/;"	m	struct:ceph_data_stats
average_bytes_per_value	cpp-btree/btree.h	/^  static double average_bytes_per_value() {$/;"	f	class:btree::btree
average_bytes_per_value	cpp-btree/btree_container.h	/^  static double average_bytes_per_value() {$/;"	f	class:btree::btree_container
b_traits	denc.h	/^  typedef denc_traits<B> b_traits;$/;"	t	struct:denc_traits
back	buffer.h	/^    const ptr& back() const { return _buffers.back(); }$/;"	f	class:ceph::CEPH_BUFFER_API::list
back	elist.h	/^  T back(size_t o=0) {$/;"	f	class:elist
back	rados/buffer.h	/^    const ptr& back() const { return _buffers.back(); }$/;"	f	class:ceph::CEPH_BUFFER_API::list
back	xlist.h	/^  T back() { return static_cast<T>(_back->_item); }$/;"	f	class:xlist
back	xlist.h	/^  const T back() const { return static_cast<const T>(_back->_item); }$/;"	f	class:xlist
bad_alloc	buffer.h	/^  struct bad_alloc : public error {$/;"	s	namespace:ceph::CEPH_BUFFER_API
bad_alloc	rados/buffer.h	/^  struct bad_alloc : public error {$/;"	s	namespace:ceph::CEPH_BUFFER_API
base_fields	cpp-btree/btree.h	/^  struct base_fields {$/;"	s	class:btree::btree_node
base_fields	cpp-btree/btree.h	/^  typedef typename node_type::base_fields base_fields;$/;"	t	class:btree::btree
begin	buffer.h	/^    const_iterator begin() const {$/;"	f	class:ceph::CEPH_BUFFER_API::list
begin	buffer.h	/^    iterator begin() {$/;"	f	class:ceph::CEPH_BUFFER_API::list
begin	buffer.h	/^    iterator begin(size_t offset=0) const {$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
begin	compact_map.h	/^  const_iterator begin() const {$/;"	f	class:compact_map_base
begin	compact_map.h	/^  iterator begin() {$/;"	f	class:compact_map_base
begin	compact_set.h	/^  const_iterator begin() const {$/;"	f	class:compact_set_base
begin	compact_set.h	/^  iterator begin() {$/;"	f	class:compact_set_base
begin	cpp-btree/btree.h	/^  const_iterator begin() const {$/;"	f	class:btree::btree
begin	cpp-btree/btree.h	/^  iterator begin() {$/;"	f	class:btree::btree
begin	cpp-btree/btree_container.h	/^  const_iterator begin() const { return tree_.begin(); }$/;"	f	class:btree::btree_container
begin	cpp-btree/btree_container.h	/^  iterator begin() { return tree_.begin(); }$/;"	f	class:btree::btree_container
begin	elist.h	/^  iterator begin(size_t o=0) {$/;"	f	class:elist
begin	frag.h	/^  std::set<frag_t>::iterator begin() { return _set.begin(); }$/;"	f	class:fragset_t
begin	interval_set.h	/^  typename interval_set<T,Map>::const_iterator begin() const {$/;"	f	class:interval_set
begin	interval_set.h	/^  typename interval_set<T,Map>::iterator begin() {$/;"	f	class:interval_set
begin	rados/buffer.h	/^    const_iterator begin() const {$/;"	f	class:ceph::CEPH_BUFFER_API::list
begin	rados/buffer.h	/^    iterator begin() {$/;"	f	class:ceph::CEPH_BUFFER_API::list
begin	rados/buffer.h	/^    iterator begin(size_t offset=0) const {$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
begin	rangeset.h	/^  iterator begin() {$/;"	f	class:rangeset
begin	xlist.h	/^  const_iterator begin() const { return const_iterator(_front); }$/;"	f	class:xlist
begin	xlist.h	/^  iterator begin() { return iterator(_front); }$/;"	f	class:xlist
begin_cache_next	elist.h	/^  iterator begin_cache_next(size_t o=0) {$/;"	f	class:elist
begin_deep	buffer.h	/^    iterator begin_deep(size_t offset=0) const {$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
begin_deep	rados/buffer.h	/^    iterator begin_deep(size_t offset=0) const {$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
begin_use_current	elist.h	/^  iterator begin_use_current(size_t o=0) {$/;"	f	class:elist
big_	cpp-btree/btree.h	/^struct big_ {$/;"	s	namespace:btree
binary_search_compare_to	cpp-btree/btree.h	/^  int binary_search_compare_to($/;"	f	class:btree::btree_node
binary_search_compare_to_type	cpp-btree/btree.h	/^    key_type, self_type, key_compare> binary_search_compare_to_type;$/;"	t	class:btree::btree_node
binary_search_plain_compare	cpp-btree/btree.h	/^  int binary_search_plain_compare($/;"	f	class:btree::btree_node
binary_search_plain_compare_type	cpp-btree/btree.h	/^    key_type, self_type, key_compare> binary_search_plain_compare_type;$/;"	t	class:btree::btree_node
binary_search_type	cpp-btree/btree.h	/^    binary_search_plain_compare_type>::type binary_search_type;$/;"	t	class:btree::btree_node
bitmapper	bitmapper.h	/^  bitmapper() : _data(0), _len(0) { }$/;"	f	class:bitmapper
bitmapper	bitmapper.h	/^  bitmapper(char *data, int len) : _data(data), _len(len) { }$/;"	f	class:bitmapper
bitmapper	bitmapper.h	/^class bitmapper {$/;"	c
bits	bitmapper.h	/^  int bits() const { return _len * 8; }$/;"	f	class:bitmapper
bits	filepath.h	/^  mutable vector<string> bits;$/;"	m	class:filepath
bits	frag.h	/^  unsigned bits() const { return ceph_frag_bits(_enc); }$/;"	f	class:frag_t
bl	buffer.h	/^      bl_t* bl;$/;"	m	class:ceph::CEPH_BUFFER_API::list::iterator_impl
bl	rados/buffer.h	/^      bl_t* bl;$/;"	m	class:ceph::CEPH_BUFFER_API::list::iterator_impl
bl_t	buffer.h	/^					list>::type bl_t;$/;"	t	class:ceph::CEPH_BUFFER_API::list::iterator_impl
bl_t	rados/buffer.h	/^					list>::type bl_t;$/;"	t	class:ceph::CEPH_BUFFER_API::list::iterator_impl
blobhash	blobhash.h	/^class blobhash {$/;"	c
block_name	rbd_types.h	/^	char block_name[RBD_MAX_BLOCK_NAME_SIZE];$/;"	m	struct:rbd_obj_header_ondisk
block_name_prefix	rbd/librbd.h	/^  char block_name_prefix[RBD_MAX_BLOCK_NAME_SIZE]; \/* deprecated *\/$/;"	m	struct:__anon77
bno	object.h	/^  uint64_t ino, bno;$/;"	m	struct:file_object_t
bool_compare	cpp-btree/btree.h	/^  static bool bool_compare(const Compare &comp, const Key &x, const Key &y) {$/;"	f	struct:btree::btree_key_comparer
bottom	lru.h	/^  LRUList top, bottom, pintail;$/;"	m	class:LRU
bound_encode	denc.h	/^    bound_encode(const container& s, size_t& p) {$/;"	f	struct:_denc::container_base
bound_encode	denc.h	/^    bound_encode(const container& s, size_t& p, uint64_t f) {$/;"	f	struct:_denc::container_base
bound_encode	denc.h	/^  bound_encode(const boost::optional<T>& v, size_t& p) {$/;"	f	struct:denc_traits
bound_encode	denc.h	/^  bound_encode(const boost::optional<T>& v, size_t& p, uint64_t f) {$/;"	f	struct:denc_traits
bound_encode	denc.h	/^  bound_encode(const container& s, size_t& p) {$/;"	f	struct:denc_traits
bound_encode	denc.h	/^  bound_encode(const container& s, size_t& p, uint64_t f) {$/;"	f	struct:denc_traits
bound_encode	denc.h	/^  bound_encode(const std::pair<A,B>& v, size_t& p) {$/;"	f	struct:denc_traits
bound_encode	denc.h	/^  bound_encode(const std::pair<A,B>& v, size_t& p, uint64_t f) {$/;"	f	struct:denc_traits
bound_encode	denc.h	/^  static void bound_encode(const T &o, size_t& p, uint64_t f=0) {$/;"	f	struct:denc_traits
bound_encode	denc.h	/^  static void bound_encode(const boost::none_t& v, size_t& p) {$/;"	f	struct:denc_traits
bound_encode	denc.h	/^  static void bound_encode(const bufferlist& v, size_t& p, uint64_t f=0) {$/;"	f	struct:denc_traits
bound_encode	denc.h	/^  static void bound_encode(const bufferptr& v, size_t& p, uint64_t f=0) {$/;"	f	struct:denc_traits
bound_encode	denc.h	/^  static void bound_encode(const value_type& s, size_t& p, uint64_t f=0) {$/;"	f	struct:denc_traits
bound_encode	fs_types.h	/^  static void bound_encode(const inodeno_t &o, size_t& p) {$/;"	f	struct:denc_traits
bound_encode	health.h	/^  static void bound_encode(const bufferptr& v, size_t& p, uint64_t f=0) {$/;"	f	struct:denc_traits
bound_encode	interval_set.h	/^  static void bound_encode(const interval_set<T,Map>& v, size_t& p) {$/;"	f	struct:denc_traits
bound_encode	interval_set.h	/^  void bound_encode(size_t& p) const {$/;"	f	class:interval_set
bound_encode	object.h	/^  static void bound_encode(const snapid_t& o, size_t& p) {$/;"	f	struct:denc_traits
bound_encode_helper_fb	denc.h	/^  static void bound_encode_helper_fb(const T& s, size_t& p, uint64_t f,$/;"	f	struct:denc_traits
bound_encode_helper_fnb	denc.h	/^  static void bound_encode_helper_fnb(const T& s, size_t& p, uint64_t f,$/;"	f	struct:denc_traits
bound_encode_helper_nfb	denc.h	/^  static void bound_encode_helper_nfb(const T& s, size_t& p,$/;"	f	struct:denc_traits
bound_encode_helper_nfnb	denc.h	/^  static void bound_encode_helper_nfnb(const T& s, size_t& p,$/;"	f	struct:denc_traits
bounded	denc.h	/^    static constexpr bool bounded = (denc_traits<T>::bounded &&$/;"	m	struct:_denc::tuple_traits
bounded	denc.h	/^    static constexpr bool bounded = false;$/;"	m	struct:_denc::container_base
bounded	denc.h	/^    static constexpr bool bounded = true;$/;"	m	struct:_denc::tuple_traits
bounded	denc.h	/^  static constexpr bool bounded = a_traits::bounded && b_traits::bounded;$/;"	m	struct:denc_traits
bounded	denc.h	/^  static constexpr bool bounded = false;$/;"	m	struct:denc_traits
bounded	denc.h	/^  static constexpr bool bounded = traits::bounded;$/;"	m	struct:denc_traits
bounded	denc.h	/^  static constexpr bool bounded = true;$/;"	m	struct:denc_traits
bounded	fs_types.h	/^  static constexpr bool bounded = true;$/;"	m	struct:denc_traits
bounded	health.h	/^  static constexpr bool bounded = true;$/;"	m	struct:denc_traits
bounded	interval_set.h	/^  static constexpr bool bounded = false;$/;"	m	struct:denc_traits
bounded	object.h	/^  static constexpr bool bounded = true;$/;"	m	struct:denc_traits
bp	buffer.h	/^      const ptr *bp;     \/\/\/< parent ptr$/;"	m	class:ceph::CEPH_BUFFER_API::ptr::iterator
bp	buffer.h	/^      ptr bp;$/;"	m	class:ceph::CEPH_BUFFER_API::list::contiguous_appender
bp	rados/buffer.h	/^      const ptr *bp;     \/\/\/< parent ptr$/;"	m	class:ceph::CEPH_BUFFER_API::ptr::iterator
bp	rados/buffer.h	/^      ptr bp;$/;"	m	class:ceph::CEPH_BUFFER_API::list::contiguous_appender
btime	ceph_fs.h	/^		struct ceph_timespec btime;$/;"	m	struct:ceph_mds_request_args::__anon57	typeref:struct:ceph_mds_request_args::__anon57::ceph_timespec
btree	cpp-btree/btree.h	/^class btree : public Params::key_compare {$/;"	c	namespace:btree
btree	cpp-btree/btree.h	/^namespace btree {$/;"	n
btree	cpp-btree/btree_container.h	/^namespace btree {$/;"	n
btree	cpp-btree/btree_map.h	/^namespace btree {$/;"	n
btree	cpp-btree/btree_set.h	/^namespace btree {$/;"	n
btree_binary_search_compare_to	cpp-btree/btree.h	/^struct btree_binary_search_compare_to {$/;"	s	namespace:btree
btree_binary_search_plain_compare	cpp-btree/btree.h	/^struct btree_binary_search_plain_compare {$/;"	s	namespace:btree
btree_common_params	cpp-btree/btree.h	/^struct btree_common_params {$/;"	s	namespace:btree
btree_compare_keys	cpp-btree/btree.h	/^static bool btree_compare_keys($/;"	f	namespace:btree
btree_container	cpp-btree/btree_container.h	/^  btree_container(const key_compare &comp, const allocator_type &alloc)$/;"	f	class:btree::btree_container
btree_container	cpp-btree/btree_container.h	/^  btree_container(const self_type &x)$/;"	f	class:btree::btree_container
btree_container	cpp-btree/btree_container.h	/^class btree_container {$/;"	c	namespace:btree
btree_internal_locate_compare_to	cpp-btree/btree.h	/^struct btree_internal_locate_compare_to {$/;"	s	namespace:btree
btree_internal_locate_plain_compare	cpp-btree/btree.h	/^struct btree_internal_locate_plain_compare {$/;"	s	namespace:btree
btree_is_key_compare_to	cpp-btree/btree.h	/^struct btree_is_key_compare_to$/;"	s	namespace:btree
btree_iterator	cpp-btree/btree.h	/^  btree_iterator()$/;"	f	struct:btree::btree_iterator
btree_iterator	cpp-btree/btree.h	/^  btree_iterator(Node *n, int p)$/;"	f	struct:btree::btree_iterator
btree_iterator	cpp-btree/btree.h	/^  btree_iterator(const iterator &x)$/;"	f	struct:btree::btree_iterator
btree_iterator	cpp-btree/btree.h	/^struct btree_iterator {$/;"	s	namespace:btree
btree_key_compare_to_adapter	cpp-btree/btree.h	/^  btree_key_compare_to_adapter($/;"	f	struct:btree::btree_key_compare_to_adapter
btree_key_compare_to_adapter	cpp-btree/btree.h	/^  btree_key_compare_to_adapter() { }$/;"	f	struct:btree::btree_key_compare_to_adapter
btree_key_compare_to_adapter	cpp-btree/btree.h	/^  btree_key_compare_to_adapter() {}$/;"	f	struct:btree::btree_key_compare_to_adapter
btree_key_compare_to_adapter	cpp-btree/btree.h	/^  btree_key_compare_to_adapter(const Compare &c) : Compare(c) { }$/;"	f	struct:btree::btree_key_compare_to_adapter
btree_key_compare_to_adapter	cpp-btree/btree.h	/^  btree_key_compare_to_adapter(const btree_key_compare_to_adapter<Compare> &c)$/;"	f	struct:btree::btree_key_compare_to_adapter
btree_key_compare_to_adapter	cpp-btree/btree.h	/^  btree_key_compare_to_adapter(const std::greater<std::string>&) {}$/;"	f	struct:btree::btree_key_compare_to_adapter
btree_key_compare_to_adapter	cpp-btree/btree.h	/^  btree_key_compare_to_adapter(const std::less<std::string>&) {}$/;"	f	struct:btree::btree_key_compare_to_adapter
btree_key_compare_to_adapter	cpp-btree/btree.h	/^struct btree_key_compare_to_adapter : Compare {$/;"	s	namespace:btree
btree_key_compare_to_adapter	cpp-btree/btree.h	/^struct btree_key_compare_to_adapter<std::greater<std::string> >$/;"	s	namespace:btree
btree_key_compare_to_adapter	cpp-btree/btree.h	/^struct btree_key_compare_to_adapter<std::less<std::string> >$/;"	s	namespace:btree
btree_key_compare_to_tag	cpp-btree/btree.h	/^struct btree_key_compare_to_tag {$/;"	s	namespace:btree
btree_key_comparer	cpp-btree/btree.h	/^  btree_key_comparer() {}$/;"	f	struct:btree::btree_key_comparer
btree_key_comparer	cpp-btree/btree.h	/^  btree_key_comparer(Compare c) : comp(c) {}$/;"	f	struct:btree::btree_key_comparer
btree_key_comparer	cpp-btree/btree.h	/^struct btree_key_comparer {$/;"	s	namespace:btree
btree_key_comparer	cpp-btree/btree.h	/^struct btree_key_comparer<Key, Compare, true> {$/;"	s	namespace:btree
btree_linear_search_compare_to	cpp-btree/btree.h	/^struct btree_linear_search_compare_to {$/;"	s	namespace:btree
btree_linear_search_plain_compare	cpp-btree/btree.h	/^struct btree_linear_search_plain_compare {$/;"	s	namespace:btree
btree_map	cpp-btree/btree_map.h	/^  btree_map(InputIterator b, InputIterator e,$/;"	f	class:btree::btree_map
btree_map	cpp-btree/btree_map.h	/^  btree_map(const key_compare &comp = key_compare(),$/;"	f	class:btree::btree_map
btree_map	cpp-btree/btree_map.h	/^  btree_map(const self_type &x)$/;"	f	class:btree::btree_map
btree_map	cpp-btree/btree_map.h	/^class btree_map : public btree_map_container<$/;"	c	namespace:btree
btree_map_container	cpp-btree/btree_container.h	/^  btree_map_container(InputIterator b, InputIterator e,$/;"	f	class:btree::btree_map_container
btree_map_container	cpp-btree/btree_container.h	/^  btree_map_container(const key_compare &comp = key_compare(),$/;"	f	class:btree::btree_map_container
btree_map_container	cpp-btree/btree_container.h	/^  btree_map_container(const self_type &x)$/;"	f	class:btree::btree_map_container
btree_map_container	cpp-btree/btree_container.h	/^class btree_map_container : public btree_unique_container<Tree> {$/;"	c	namespace:btree
btree_map_params	cpp-btree/btree.h	/^struct btree_map_params$/;"	s	namespace:btree
btree_multi_container	cpp-btree/btree_container.h	/^  btree_multi_container(InputIterator b, InputIterator e,$/;"	f	class:btree::btree_multi_container
btree_multi_container	cpp-btree/btree_container.h	/^  btree_multi_container(const key_compare &comp = key_compare(),$/;"	f	class:btree::btree_multi_container
btree_multi_container	cpp-btree/btree_container.h	/^  btree_multi_container(const self_type &x)$/;"	f	class:btree::btree_multi_container
btree_multi_container	cpp-btree/btree_container.h	/^class btree_multi_container : public btree_container<Tree> {$/;"	c	namespace:btree
btree_multimap	cpp-btree/btree_map.h	/^  btree_multimap(InputIterator b, InputIterator e,$/;"	f	class:btree::btree_multimap
btree_multimap	cpp-btree/btree_map.h	/^  btree_multimap(const key_compare &comp = key_compare(),$/;"	f	class:btree::btree_multimap
btree_multimap	cpp-btree/btree_map.h	/^  btree_multimap(const self_type &x)$/;"	f	class:btree::btree_multimap
btree_multimap	cpp-btree/btree_map.h	/^class btree_multimap : public btree_multi_container<$/;"	c	namespace:btree
btree_multiset	cpp-btree/btree_set.h	/^  btree_multiset(InputIterator b, InputIterator e,$/;"	f	class:btree::btree_multiset
btree_multiset	cpp-btree/btree_set.h	/^  btree_multiset(const key_compare &comp = key_compare(),$/;"	f	class:btree::btree_multiset
btree_multiset	cpp-btree/btree_set.h	/^  btree_multiset(const self_type &x)$/;"	f	class:btree::btree_multiset
btree_multiset	cpp-btree/btree_set.h	/^class btree_multiset : public btree_multi_container<$/;"	c	namespace:btree
btree_node	cpp-btree/btree.h	/^class btree_node {$/;"	c	namespace:btree
btree_set	cpp-btree/btree_set.h	/^  btree_set(InputIterator b, InputIterator e,$/;"	f	class:btree::btree_set
btree_set	cpp-btree/btree_set.h	/^  btree_set(const key_compare &comp = key_compare(),$/;"	f	class:btree::btree_set
btree_set	cpp-btree/btree_set.h	/^  btree_set(const self_type &x)$/;"	f	class:btree::btree_set
btree_set	cpp-btree/btree_set.h	/^class btree_set : public btree_unique_container<$/;"	c	namespace:btree
btree_set_params	cpp-btree/btree.h	/^struct btree_set_params$/;"	s	namespace:btree
btree_swap_helper	cpp-btree/btree.h	/^inline void btree_swap_helper(T &a, T &b) {$/;"	f	namespace:btree
btree_type	cpp-btree/btree_map.h	/^  typedef btree<params_type> btree_type;$/;"	t	class:btree::btree_map
btree_type	cpp-btree/btree_map.h	/^  typedef btree<params_type> btree_type;$/;"	t	class:btree::btree_multimap
btree_type	cpp-btree/btree_set.h	/^  typedef btree<params_type> btree_type;$/;"	t	class:btree::btree_multiset
btree_type	cpp-btree/btree_set.h	/^  typedef btree<params_type> btree_type;$/;"	t	class:btree::btree_set
btree_unique_container	cpp-btree/btree_container.h	/^  btree_unique_container(InputIterator b, InputIterator e,$/;"	f	class:btree::btree_unique_container
btree_unique_container	cpp-btree/btree_container.h	/^  btree_unique_container(const key_compare &comp = key_compare(),$/;"	f	class:btree::btree_unique_container
btree_unique_container	cpp-btree/btree_container.h	/^  btree_unique_container(const self_type &x)$/;"	f	class:btree::btree_unique_container
btree_unique_container	cpp-btree/btree_container.h	/^class btree_unique_container : public btree_container<Tree> {$/;"	c	namespace:btree
btree_upper_bound_adapter	cpp-btree/btree.h	/^  btree_upper_bound_adapter(Compare c) : Compare(c) {}$/;"	f	struct:btree::btree_upper_bound_adapter
btree_upper_bound_adapter	cpp-btree/btree.h	/^struct btree_upper_bound_adapter : public Compare {$/;"	s	namespace:btree
btree_upper_bound_compare_to_adapter	cpp-btree/btree.h	/^  btree_upper_bound_compare_to_adapter(CompareTo c) : CompareTo(c) {}$/;"	f	struct:btree::btree_upper_bound_compare_to_adapter
btree_upper_bound_compare_to_adapter	cpp-btree/btree.h	/^struct btree_upper_bound_compare_to_adapter : public CompareTo {$/;"	s	namespace:btree
bucket	rados/rgw_file.h	/^  uint64_t bucket;$/;"	m	struct:rgw_fh_hk
buf	buffer.h	/^    char buf[256];$/;"	m	struct:ceph::CEPH_BUFFER_API::malformed_input
buf	object.h	/^  mutable char buf[34];$/;"	m	struct:file_object_t
buf	rados/buffer.h	/^    char buf[256];$/;"	m	struct:ceph::CEPH_BUFFER_API::malformed_input
buffer	buffer.h	/^      ptr buffer;$/;"	m	class:ceph::CEPH_BUFFER_API::list::page_aligned_appender
buffer	buffer_fwd.h	/^  namespace buffer {$/;"	n	namespace:ceph
buffer	rados/buffer.h	/^      ptr buffer;$/;"	m	class:ceph::CEPH_BUFFER_API::list::page_aligned_appender
buffer	rados/buffer_fwd.h	/^  namespace buffer {$/;"	n	namespace:ceph
buffers	buffer.h	/^    const std::list<ptr>& buffers() const { return _buffers; }$/;"	f	class:ceph::CEPH_BUFFER_API::list
buffers	rados/buffer.h	/^    const std::list<ptr>& buffers() const { return _buffers; }$/;"	f	class:ceph::CEPH_BUFFER_API::list
build_indices	denc.h	/^  struct build_indices {$/;"	s	namespace:_denc
build_indices	denc.h	/^  struct build_indices<0> {$/;"	s	namespace:_denc
build_indices	denc.h	/^  struct build_indices<1> {$/;"	s	namespace:_denc
build_indices_helper	denc.h	/^  struct build_indices_helper<N, I, Is...> {$/;"	s	namespace:_denc
build_indices_helper	denc.h	/^  struct build_indices_helper<N, N, Is...> {$/;"	s	namespace:_denc
by	ceph_fs.h	/^	__le32 by;                     \/* ...by this many bits *\/$/;"	m	struct:ceph_frag_tree_split
byte_avail	util.h	/^  uint64_t byte_avail;$/;"	m	struct:ceph_data_stats
byte_total	util.h	/^  uint64_t byte_total;$/;"	m	struct:ceph_data_stats
byte_u_t	types.h	/^  explicit byte_u_t(uint64_t _v) : v(_v) {};$/;"	f	struct:byte_u_t
byte_u_t	types.h	/^struct byte_u_t {$/;"	s
byte_used	util.h	/^  uint64_t byte_used;$/;"	m	struct:ceph_data_stats
bytes	bitmapper.h	/^  int bytes() const { return _len; }$/;"	f	class:bitmapper
bytes	mempool.h	/^  ssize_t bytes = 0;$/;"	m	struct:mempool::stats_t
bytes	mempool.h	/^  std::atomic<size_t> bytes = {0};$/;"	m	struct:mempool::shard_t
bytes	uuid.h	/^  char *bytes() const {$/;"	f	struct:uuid_d
bytes_used	cpp-btree/btree.h	/^  size_type bytes_used() const {$/;"	f	class:btree::btree
bytes_used	cpp-btree/btree_container.h	/^  size_type bytes_used() const { return tree_.bytes_used(); }$/;"	f	class:btree::btree_container
c_cursor	rados/librados.hpp	/^    rados_object_list_cursor c_cursor;$/;"	m	class:librados::ObjectCursor
c_gather	Context.h	/^  GatherType *c_gather;$/;"	m	class:C_GatherBuilderBase
c_str	filepath.h	/^  const char *c_str() const { return path.c_str(); }$/;"	f	class:filepath
c_str	object.h	/^  const char *c_str() const {$/;"	f	struct:file_object_t
callback_t	on_exit.h	/^    typedef void (*callback_t)(void *arg);$/;"	t	class:OnExitManager
callback_t	rados/librados.hpp	/^  typedef void (*callback_t)(completion_t cb, void *arg);$/;"	t	namespace:librados
callback_t	rbd/librbd.hpp	/^  typedef void (*callback_t)(completion_t cb, void *arg);$/;"	t	namespace:librbd
caller_gid	ceph_fs.h	/^	__le32 caller_uid, caller_gid;$/;"	m	struct:ceph_mds_request_head
caller_gid	ceph_fs.h	/^	__le32 caller_uid, caller_gid;$/;"	m	struct:ceph_mds_request_head_legacy
caller_uid	ceph_fs.h	/^	__le32 caller_uid, caller_gid;$/;"	m	struct:ceph_mds_request_head
caller_uid	ceph_fs.h	/^	__le32 caller_uid, caller_gid;$/;"	m	struct:ceph_mds_request_head_legacy
cap_id	ceph_fs.h	/^	__le64 cap_id;$/;"	m	struct:ceph_mds_cap_item
cap_id	ceph_fs.h	/^	__le64 cap_id;$/;"	m	struct:ceph_mds_cap_peer
cap_id	ceph_fs.h	/^	__le64 cap_id;$/;"	m	struct:ceph_mds_cap_reconnect
cap_id	ceph_fs.h	/^	__le64 cap_id;$/;"	m	struct:ceph_mds_cap_reconnect_v1
cap_id	ceph_fs.h	/^	__le64 cap_id;$/;"	m	struct:ceph_mds_caps_head
cap_id	ceph_fs.h	/^	__le64 cap_id;$/;"	m	struct:ceph_mds_reply_cap
cap_id	ceph_fs.h	/^	__le64 ino, cap_id;            \/* ino and unique cap id *\/$/;"	m	struct:ceph_mds_request_release
caps	ceph_fs.h	/^	__le32 caps, wanted, dirty; \/* latest issued\/wanted\/dirty *\/$/;"	m	struct:ceph_mds_caps_head
caps	ceph_fs.h	/^	__le32 caps, wanted;           \/* caps issued, wanted *\/$/;"	m	struct:ceph_mds_reply_cap
caps	ceph_fs.h	/^	__le32 caps, wanted;           \/* new issued, wanted *\/$/;"	m	struct:ceph_mds_request_release
cb	on_exit.h	/^    struct cb {$/;"	s	class:OnExitManager
cct	Context.h	/^  CephContext *cct;$/;"	m	class:C_ContextsBase
cct	Context.h	/^  CephContext *cct;$/;"	m	class:C_GatherBase
cct	Context.h	/^  CephContext *cct;$/;"	m	class:C_GatherBuilderBase
ceph	assert.h	/^namespace ceph {$/;"	n
ceph	buffer.h	/^namespace ceph {$/;"	n
ceph	buffer_fwd.h	/^namespace ceph {$/;"	n
ceph	fs_types.h	/^namespace ceph {$/;"	n
ceph	krbd.h	/^namespace ceph {$/;"	n
ceph	memory.h	/^namespace ceph {$/;"	n
ceph	page.h	/^namespace ceph {$/;"	n
ceph	rados/buffer.h	/^namespace ceph {$/;"	n
ceph	rados/buffer_fwd.h	/^namespace ceph {$/;"	n
ceph	rados/memory.h	/^namespace ceph {$/;"	n
ceph	rados/page.h	/^namespace ceph {$/;"	n
ceph	types.h	/^namespace ceph {$/;"	n
ceph	unordered_map.h	/^namespace ceph {$/;"	n
ceph	unordered_set.h	/^namespace ceph {$/;"	n
ceph_abort	assert.h	99;"	d
ceph_abort_msg	assert.h	101;"	d
ceph_assert	assert.h	128;"	d
ceph_assert_always	assert.h	135;"	d
ceph_assertf	assert.h	146;"	d
ceph_assertf_always	assert.h	153;"	d
ceph_client_mount	ceph_fs.h	/^struct ceph_client_mount {$/;"	s
ceph_crc32c	crc32c.h	/^static inline uint32_t ceph_crc32c(uint32_t crc, unsigned char const *data, unsigned length)$/;"	f
ceph_crc32c	rados/crc32c.h	/^static inline uint32_t ceph_crc32c(uint32_t crc, unsigned char const *data, unsigned length)$/;"	f
ceph_crc32c_func_t	crc32c.h	/^typedef uint32_t (*ceph_crc32c_func_t)(uint32_t crc, unsigned char const *data, unsigned length);$/;"	t
ceph_crc32c_func_t	rados/crc32c.h	/^typedef uint32_t (*ceph_crc32c_func_t)(uint32_t crc, unsigned char const *data, unsigned length);$/;"	t
ceph_data_stats	util.h	/^  ceph_data_stats() :$/;"	f	struct:ceph_data_stats
ceph_data_stats	util.h	/^struct ceph_data_stats$/;"	s
ceph_data_stats_t	util.h	/^typedef struct ceph_data_stats ceph_data_stats_t;$/;"	t	typeref:struct:ceph_data_stats
ceph_deleg_cb_t	cephfs/libcephfs.h	/^typedef void (*ceph_deleg_cb_t)(struct Fh *fh, void *priv);$/;"	t
ceph_demangle	demangle.h	/^static std::string ceph_demangle(const char* name)$/;"	f
ceph_dir_layout	ceph_fs.h	/^struct ceph_dir_layout {$/;"	s
ceph_entity_addr	msgr.h	/^struct ceph_entity_addr {$/;"	s
ceph_entity_inst	msgr.h	/^struct ceph_entity_inst {$/;"	s
ceph_entity_name	msgr.h	/^struct ceph_entity_name {$/;"	s
ceph_eversion	rados.h	/^struct ceph_eversion {$/;"	s
ceph_file_layout	ceph_fs.h	/^struct ceph_file_layout {$/;"	s
ceph_file_layout	cephfs/libcephfs.h	/^struct ceph_file_layout {$/;"	s
ceph_filelock	ceph_fs.h	/^struct ceph_filelock {$/;"	s
ceph_frag_bits	ceph_frag.h	/^static inline __u32 ceph_frag_bits(__u32 f)$/;"	f
ceph_frag_contains_frag	ceph_frag.h	/^static inline int ceph_frag_contains_frag(__u32 f, __u32 sub)$/;"	f
ceph_frag_contains_value	ceph_frag.h	/^static inline int ceph_frag_contains_value(__u32 f, __u32 v)$/;"	f
ceph_frag_is_left_child	ceph_frag.h	/^static inline int ceph_frag_is_left_child(__u32 f)$/;"	f
ceph_frag_is_leftmost	ceph_frag.h	/^static inline int ceph_frag_is_leftmost(__u32 f)$/;"	f
ceph_frag_is_right_child	ceph_frag.h	/^static inline int ceph_frag_is_right_child(__u32 f)$/;"	f
ceph_frag_is_rightmost	ceph_frag.h	/^static inline int ceph_frag_is_rightmost(__u32 f)$/;"	f
ceph_frag_left_child	ceph_frag.h	/^static inline __u32 ceph_frag_left_child(__u32 f)$/;"	f
ceph_frag_make	ceph_frag.h	/^static inline __u32 ceph_frag_make(__u32 b, __u32 v)$/;"	f
ceph_frag_make_child	ceph_frag.h	/^static inline __u32 ceph_frag_make_child(__u32 f, int by, int i)$/;"	f
ceph_frag_mask	ceph_frag.h	/^static inline __u32 ceph_frag_mask(__u32 f)$/;"	f
ceph_frag_mask_shift	ceph_frag.h	/^static inline __u32 ceph_frag_mask_shift(__u32 f)$/;"	f
ceph_frag_next	ceph_frag.h	/^static inline __u32 ceph_frag_next(__u32 f)$/;"	f
ceph_frag_parent	ceph_frag.h	/^static inline __u32 ceph_frag_parent(__u32 f)$/;"	f
ceph_frag_right_child	ceph_frag.h	/^static inline __u32 ceph_frag_right_child(__u32 f)$/;"	f
ceph_frag_sibling	ceph_frag.h	/^static inline __u32 ceph_frag_sibling(__u32 f)$/;"	f
ceph_frag_tree_head	ceph_fs.h	/^struct ceph_frag_tree_head {$/;"	s
ceph_frag_tree_split	ceph_fs.h	/^struct ceph_frag_tree_split {$/;"	s
ceph_frag_value	ceph_frag.h	/^static inline __u32 ceph_frag_value(__u32 f)$/;"	f
ceph_fsid	rados.h	/^struct ceph_fsid {$/;"	s
ceph_fsid_compare	rados.h	/^static inline int ceph_fsid_compare(const struct ceph_fsid *a,$/;"	f
ceph_le	byteorder.h	/^struct ceph_le {$/;"	s
ceph_mds_cap_item	ceph_fs.h	/^struct ceph_mds_cap_item {$/;"	s
ceph_mds_cap_peer	ceph_fs.h	/^struct ceph_mds_cap_peer {$/;"	s
ceph_mds_cap_reconnect	ceph_fs.h	/^struct ceph_mds_cap_reconnect {$/;"	s
ceph_mds_cap_reconnect_v1	ceph_fs.h	/^struct ceph_mds_cap_reconnect_v1 {$/;"	s
ceph_mds_cap_release	ceph_fs.h	/^struct ceph_mds_cap_release {$/;"	s
ceph_mds_caps_body_legacy	ceph_fs.h	/^struct ceph_mds_caps_body_legacy {$/;"	s
ceph_mds_caps_head	ceph_fs.h	/^struct ceph_mds_caps_head {$/;"	s
ceph_mds_getmap	ceph_fs.h	/^struct ceph_mds_getmap {$/;"	s
ceph_mds_lease	ceph_fs.h	/^struct ceph_mds_lease {$/;"	s
ceph_mds_reply_cap	ceph_fs.h	/^struct ceph_mds_reply_cap {$/;"	s
ceph_mds_reply_dirfrag	ceph_fs.h	/^struct ceph_mds_reply_dirfrag {$/;"	s
ceph_mds_reply_head	ceph_fs.h	/^struct ceph_mds_reply_head {$/;"	s
ceph_mds_reply_lease	ceph_fs.h	/^struct ceph_mds_reply_lease {$/;"	s
ceph_mds_request_args	ceph_fs.h	/^union ceph_mds_request_args {$/;"	u
ceph_mds_request_args_legacy	ceph_fs.h	/^union ceph_mds_request_args_legacy {$/;"	u
ceph_mds_request_head	ceph_fs.h	/^struct ceph_mds_request_head {$/;"	s
ceph_mds_request_head_legacy	ceph_fs.h	/^struct ceph_mds_request_head_legacy {$/;"	s
ceph_mds_request_release	ceph_fs.h	/^struct ceph_mds_request_release {$/;"	s
ceph_mds_session_head	ceph_fs.h	/^struct ceph_mds_session_head {$/;"	s
ceph_mds_snap_head	ceph_fs.h	/^struct ceph_mds_snap_head {$/;"	s
ceph_mds_snap_realm	ceph_fs.h	/^struct ceph_mds_snap_realm {$/;"	s
ceph_mds_snaprealm_reconnect	ceph_fs.h	/^struct ceph_mds_snaprealm_reconnect {$/;"	s
ceph_mon_poolop	ceph_fs.h	/^struct ceph_mon_poolop {$/;"	s
ceph_mon_poolop_reply	ceph_fs.h	/^struct ceph_mon_poolop_reply {$/;"	s
ceph_mon_request_header	ceph_fs.h	/^struct ceph_mon_request_header {$/;"	s
ceph_mon_statfs	ceph_fs.h	/^struct ceph_mon_statfs {$/;"	s
ceph_mon_statfs_reply	ceph_fs.h	/^struct ceph_mon_statfs_reply {$/;"	s
ceph_mon_subscribe_ack	ceph_fs.h	/^struct ceph_mon_subscribe_ack {$/;"	s
ceph_mon_subscribe_item	ceph_fs.h	/^struct ceph_mon_subscribe_item {$/;"	s
ceph_mon_unmanaged_snap	ceph_fs.h	/^struct ceph_mon_unmanaged_snap {$/;"	s
ceph_msg_connect	msgr.h	/^struct ceph_msg_connect {$/;"	s
ceph_msg_connect_reply	msgr.h	/^struct ceph_msg_connect_reply {$/;"	s
ceph_msg_footer	msgr.h	/^struct ceph_msg_footer {$/;"	s
ceph_msg_footer_old	msgr.h	/^struct ceph_msg_footer_old {$/;"	s
ceph_msg_header	msgr.h	/^struct ceph_msg_header {$/;"	s
ceph_msg_header_old	msgr.h	/^struct ceph_msg_header_old {$/;"	s
ceph_object_layout	rados.h	/^struct ceph_object_layout {$/;"	s
ceph_osd_getmap	ceph_fs.h	/^struct ceph_osd_getmap {$/;"	s
ceph_osd_op	rados.h	/^struct ceph_osd_op {$/;"	s
ceph_osd_op_mode_cache	rados.h	/^static inline int ceph_osd_op_mode_cache(int op)$/;"	f
ceph_osd_op_mode_modify	rados.h	/^static inline int ceph_osd_op_mode_modify(int op)$/;"	f
ceph_osd_op_mode_read	rados.h	/^static inline int ceph_osd_op_mode_read(int op)$/;"	f
ceph_osd_op_mode_subop	rados.h	/^static inline int ceph_osd_op_mode_subop(int op)$/;"	f
ceph_osd_op_type_attr	rados.h	/^static inline int ceph_osd_op_type_attr(int op)$/;"	f
ceph_osd_op_type_data	rados.h	/^static inline int ceph_osd_op_type_data(int op)$/;"	f
ceph_osd_op_type_exec	rados.h	/^static inline int ceph_osd_op_type_exec(int op)$/;"	f
ceph_osd_op_type_pg	rados.h	/^static inline int ceph_osd_op_type_pg(int op)$/;"	f
ceph_osd_op_uses_extent	rados.h	/^static inline int ceph_osd_op_uses_extent(int op)$/;"	f
ceph_osd_reply_head	rados.h	/^struct ceph_osd_reply_head {$/;"	s
ceph_pg	rados.h	/^struct ceph_pg {$/;"	s
ceph_pthread_getname	compat.h	160;"	d
ceph_pthread_getname	compat.h	163;"	d
ceph_pthread_setname	compat.h	141;"	d
ceph_pthread_setname	compat.h	147;"	d
ceph_pthread_setname	compat.h	151;"	d
ceph_pthread_setname	compat.h	154;"	d
ceph_seq_cmp	msgr.h	/^static inline __s32 ceph_seq_cmp(__u32 a, __u32 b)$/;"	f
ceph_seq_t	msgr.h	/^typedef __u32 ceph_seq_t;$/;"	t
ceph_snapid_t	rados.h	/^typedef __le64 ceph_snapid_t;$/;"	t
ceph_spin_destroy	Spinlock.h	/^static inline int ceph_spin_destroy(ceph_spinlock_t *l)$/;"	f
ceph_spin_init	Spinlock.h	/^static inline int ceph_spin_init(ceph_spinlock_t *l)$/;"	f
ceph_spin_lock	Spinlock.h	/^static inline int ceph_spin_lock(ceph_spinlock_t *l)$/;"	f
ceph_spin_unlock	Spinlock.h	/^static inline int ceph_spin_unlock(ceph_spinlock_t *l)$/;"	f
ceph_spinlock_t	Spinlock.h	/^} ceph_spinlock_t;$/;"	t	typeref:struct:__anon1
ceph_stable_mod	rados.h	/^static inline int ceph_stable_mod(int x, int b, int bmask)$/;"	f
ceph_statfs	ceph_fs.h	/^struct ceph_statfs {$/;"	s
ceph_statx	cephfs/ceph_statx.h	/^struct ceph_statx {$/;"	s
ceph_tid_t	types.h	/^typedef uint64_t ceph_tid_t; \/\/ transaction id$/;"	t
ceph_timespec	rados.h	/^struct ceph_timespec {$/;"	s
ceph_to_hostos_errno	types.h	449;"	d
checksum	rados.h	/^		} __attribute__ ((packed)) checksum;$/;"	m	union:ceph_osd_op::__anon13	typeref:struct:ceph_osd_op::__anon13::__anon29
child	cpp-btree/btree.h	/^  btree_node* child(int i) const { return fields_.children[i]; }$/;"	f	class:btree::btree_node
children	cpp-btree/btree.h	/^    btree_node *children[kNodeValues + 1];$/;"	m	struct:btree::btree_node::internal_fields
chunk_size	rados.h	/^			__le32 chunk_size;$/;"	m	struct:ceph_osd_op::__anon13::__anon29
class_len	rados.h	/^			__u8 class_len;$/;"	m	struct:ceph_osd_op::__anon13::__anon16
clear	Distribution.h	/^  void clear() {$/;"	f	class:Distribution
clear	bitmapper.h	/^  void clear(int b) {$/;"	f	class:bitmapper
clear	buffer.h	/^    void clear() {$/;"	f	class:ceph::CEPH_BUFFER_API::list
clear	compact_map.h	/^  void clear() {$/;"	f	class:compact_map_base
clear	compact_set.h	/^  void clear() {$/;"	f	class:compact_set_base
clear	cpp-btree/btree_container.h	/^  void clear() {$/;"	f	class:btree::btree_container
clear	elist.h	/^  void clear() {$/;"	f	class:elist
clear	filepath.h	/^  void clear() {$/;"	f	class:filepath
clear	frag.h	/^  void clear() {$/;"	f	class:fragtree_t
clear	interval_set.h	/^  void clear() {$/;"	f	class:interval_set
clear	object.h	/^  void clear() {$/;"	f	struct:object_t
clear	rados/buffer.h	/^    void clear() {$/;"	f	class:ceph::CEPH_BUFFER_API::list
clear	xlist.h	/^  void clear() {$/;"	f	class:xlist
clear_list	elist.h	/^  void clear_list() {$/;"	f	class:elist
client	ceph_fs.h	/^	__le64 client; \/* which client holds the lock *\/$/;"	m	struct:ceph_filelock
client	rados/librados.hpp	/^    RadosClient *client;$/;"	m	class:librados::Rados
client	rados/librados.hpp	/^    std::string client;$/;"	m	struct:librados::__anon42
client	rbd/librbd.hpp	/^    std::string client;$/;"	m	struct:librbd::__anon70
client_inc	rados.h	/^	__le32 client_inc;                \/* client incarnation *\/$/;"	m	struct:ceph_osd_reply_head
client_name	rbd/librbd.h	/^  char *client_name;$/;"	m	struct:__anon79
client_name	rbd/librbd.hpp	/^    std::string client_name;$/;"	m	struct:librbd::__anon71
client_t	types.h	/^  client_t(int64_t _v = -2) : v(_v) {}$/;"	f	struct:client_t
client_t	types.h	/^struct client_t {$/;"	s
clone_info_t	rados/rados_types.hpp	/^  clone_info_t() : cloneid(0), size(0) {}$/;"	f	struct:librados::clone_info_t
clone_info_t	rados/rados_types.hpp	/^struct clone_info_t {$/;"	s	namespace:librados
clone_missing	rados/rados_types.hpp	/^  bool clone_missing() const  {$/;"	f	struct:inconsistent_snapset_t
cloneid	rados/rados_types.hpp	/^  snap_t cloneid;$/;"	m	struct:librados::clone_info_t
clonerange	rados.h	/^		} __attribute__ ((packed)) clonerange;$/;"	m	union:ceph_osd_op::__anon13	typeref:struct:ceph_osd_op::__anon13::__anon22
clones	rados/rados_types.hpp	/^  std::vector<clone_info_t> clones;   \/\/ ascending$/;"	m	struct:librados::snap_set_t
clones	rados/rados_types.hpp	/^  std::vector<snap_t> clones;$/;"	m	struct:inconsistent_snapset_t
cls	rados.h	/^		} __attribute__ ((packed)) cls;$/;"	m	union:ceph_osd_op::__anon13	typeref:struct:ceph_osd_op::__anon13::__anon16
cls_handle_t	rados/objclass.h	/^typedef void *cls_handle_t;$/;"	t
cls_method_context_t	rados/objclass.h	/^typedef void* cls_method_context_t;$/;"	t
cls_method_cxx_call_t	rados/objclass.h	/^typedef int (*cls_method_cxx_call_t)(cls_method_context_t ctx,$/;"	t
cls_method_handle_t	rados/objclass.h	/^typedef void *cls_method_handle_t;$/;"	t
cluster_name	rbd/librbd.h	/^  char *cluster_name;$/;"	m	struct:__anon79
cluster_name	rbd/librbd.hpp	/^    std::string cluster_name;$/;"	m	struct:librbd::__anon71
cluster_stat_t	rados/librados.hpp	/^  typedef struct rados_cluster_stat_t cluster_stat_t;$/;"	t	namespace:librados	typeref:struct:librados::rados_cluster_stat_t
cmp_mode	rados.h	/^			__u8 cmp_mode;     \/* CEPH_OSD_CMPXATTR_MODE_* *\/$/;"	m	struct:ceph_osd_op::__anon13::__anon15
cmp_op	rados.h	/^			__u8 cmp_op;       \/* CEPH_OSD_CMPXATTR_OP_* *\/$/;"	m	struct:ceph_osd_op::__anon13::__anon15
code	buffer.h	/^    int code;$/;"	m	struct:ceph::CEPH_BUFFER_API::error_code
code	rados/buffer.h	/^    int code;$/;"	m	struct:ceph::CEPH_BUFFER_API::error_code
code	types.h	/^  int32_t code;$/;"	m	struct:errorcode32_t
comp	cpp-btree/btree.h	/^  Compare comp;$/;"	m	struct:btree::btree_key_comparer
comp_type	rbd_types.h	/^		__u8 comp_type;$/;"	m	struct:rbd_obj_header_ondisk::__anon32
compact_map	compact_map.h	/^class compact_map : public compact_map_base<Key, T, std::map<Key,T,Compare,Alloc> > {$/;"	c
compact_map_base	compact_map.h	/^  compact_map_base() {}$/;"	f	class:compact_map_base
compact_map_base	compact_map.h	/^  compact_map_base(const compact_map_base& o) {$/;"	f	class:compact_map_base
compact_map_base	compact_map.h	/^class compact_map_base {$/;"	c
compact_multimap	compact_map.h	/^class compact_multimap : public compact_map_base<Key, T, std::multimap<Key,T,Compare,Alloc> > {$/;"	c
compact_set	compact_set.h	/^class compact_set : public compact_set_base<T, std::set<T, Compare, Alloc> > {$/;"	c
compact_set_base	compact_set.h	/^  compact_set_base() {}$/;"	f	class:compact_set_base
compact_set_base	compact_set.h	/^  compact_set_base(const compact_set_base& o) {$/;"	f	class:compact_set_base
compact_set_base	compact_set.h	/^class compact_set_base {$/;"	c
compare	CompatSet.h	/^  int compare(const CompatSet& other) {$/;"	f	struct:CompatSet
compare_keys	cpp-btree/btree.h	/^  bool compare_keys(const key_type &x, const key_type &y) const {$/;"	f	class:btree::btree
compat	CompatSet.h	/^  FeatureSet compat;$/;"	m	struct:CompatSet
compat_version	msgr.h	/^	__le16 compat_version;$/;"	m	struct:ceph_msg_header
complete	Context.h	/^  virtual void complete(int r) {$/;"	f	class:Context
complete	Context.h	/^  void complete(C &&t) {$/;"	f	class:GenContext
completion_t	rados/librados.hpp	/^  typedef void *completion_t;$/;"	t	namespace:librados
completion_t	rbd/librbd.hpp	/^  typedef void *completion_t;$/;"	t	namespace:librbd
config_t	rados/librados.hpp	/^  typedef void *config_t;$/;"	t	namespace:librados
connect_seq	msgr.h	/^	__le32 connect_seq;  \/* count connections initiated in this session *\/$/;"	m	struct:ceph_msg_connect
connect_seq	msgr.h	/^	__le32 connect_seq;$/;"	m	struct:ceph_msg_connect_reply
const_iterator	buffer.h	/^    typedef iterator_impl<true> const_iterator;$/;"	t	class:ceph::CEPH_BUFFER_API::list
const_iterator	compact_map.h	/^      const_iterator() { }$/;"	f	class:compact_map_base::const_iterator
const_iterator	compact_map.h	/^      const_iterator(const compact_map_base* m) : const_iterator_base<typename Map::const_iterator>(m) { }$/;"	f	class:compact_map_base::const_iterator
const_iterator	compact_map.h	/^      const_iterator(const compact_map_base* m, const typename Map::const_iterator& i)$/;"	f	class:compact_map_base::const_iterator
const_iterator	compact_map.h	/^      const_iterator(const iterator_base<typename Map::const_iterator>& o)$/;"	f	class:compact_map_base::const_iterator
const_iterator	compact_map.h	/^  class const_iterator : public const_iterator_base<typename Map::const_iterator> {$/;"	c	class:compact_map_base
const_iterator	compact_set.h	/^      const_iterator() { }$/;"	f	class:compact_set_base::const_iterator
const_iterator	compact_set.h	/^      const_iterator(const compact_set_base* s) : iterator_base<typename Set::const_iterator>(s) { }$/;"	f	class:compact_set_base::const_iterator
const_iterator	compact_set.h	/^      const_iterator(const compact_set_base* s, const typename Set::const_iterator& i)$/;"	f	class:compact_set_base::const_iterator
const_iterator	compact_set.h	/^      const_iterator(const iterator_base<typename Set::const_iterator>& o)$/;"	f	class:compact_set_base::const_iterator
const_iterator	compact_set.h	/^  class const_iterator : public iterator_base<typename Set::const_iterator> {$/;"	c	class:compact_set_base
const_iterator	cpp-btree/btree.h	/^    const_node, const_reference, const_pointer> const_iterator;$/;"	t	struct:btree::btree_iterator
const_iterator	cpp-btree/btree.h	/^  typedef typename iterator::const_iterator const_iterator;$/;"	t	class:btree::btree
const_iterator	cpp-btree/btree_container.h	/^  typedef typename Tree::const_iterator const_iterator;$/;"	t	class:btree::btree_container
const_iterator	cpp-btree/btree_container.h	/^  typedef typename Tree::const_iterator const_iterator;$/;"	t	class:btree::btree_multi_container
const_iterator	cpp-btree/btree_container.h	/^  typedef typename Tree::const_iterator const_iterator;$/;"	t	class:btree::btree_unique_container
const_iterator	interval_set.h	/^        const_iterator(const iterator &i)$/;"	f	class:interval_set::const_iterator
const_iterator	interval_set.h	/^        explicit const_iterator(typename Map::const_iterator iter)$/;"	f	class:interval_set::const_iterator
const_iterator	interval_set.h	/^  class const_iterator : public std::iterator <std::forward_iterator_tag, T>$/;"	c	class:interval_set
const_iterator	rados/buffer.h	/^    typedef iterator_impl<true> const_iterator;$/;"	t	class:ceph::CEPH_BUFFER_API::list
const_iterator	xlist.h	/^    const_iterator(item *i = 0) : cur(i) {}$/;"	f	class:xlist::const_iterator
const_iterator	xlist.h	/^  class const_iterator: std::iterator<std::forward_iterator_tag, T> {$/;"	c	class:xlist
const_iterator_base	compact_map.h	/^    const_iterator_base() : map(0) { }$/;"	f	class:compact_map_base::const_iterator_base
const_iterator_base	compact_map.h	/^    const_iterator_base(const compact_map_base *m, const It& i) : map(m), it(i) { }$/;"	f	class:compact_map_base::const_iterator_base
const_iterator_base	compact_map.h	/^    const_iterator_base(const compact_map_base* m) : map(m) { }$/;"	f	class:compact_map_base::const_iterator_base
const_iterator_base	compact_map.h	/^    const_iterator_base(const const_iterator_base& o) {$/;"	f	class:compact_map_base::const_iterator_base
const_iterator_base	compact_map.h	/^  class const_iterator_base {$/;"	c	class:compact_map_base
const_node	cpp-btree/btree.h	/^  typedef const Node const_node;$/;"	t	struct:btree::btree_iterator
const_pointer	cpp-btree/btree.h	/^  typedef const value_type* const_pointer;$/;"	t	struct:btree::btree_map_params
const_pointer	cpp-btree/btree.h	/^  typedef const value_type* const_pointer;$/;"	t	struct:btree::btree_set_params
const_pointer	cpp-btree/btree.h	/^  typedef typename Params::const_pointer const_pointer;$/;"	t	class:btree::btree
const_pointer	cpp-btree/btree.h	/^  typedef typename Params::const_pointer const_pointer;$/;"	t	class:btree::btree_node
const_pointer	cpp-btree/btree.h	/^  typedef typename params_type::const_pointer const_pointer;$/;"	t	struct:btree::btree_iterator
const_pointer	cpp-btree/btree_container.h	/^  typedef typename Tree::const_pointer const_pointer;$/;"	t	class:btree::btree_container
const_pointer	mempool.h	/^  typedef const value_type * const_pointer;$/;"	t	class:mempool::pool_allocator
const_reference	cpp-btree/btree.h	/^  typedef const value_type& const_reference;$/;"	t	struct:btree::btree_map_params
const_reference	cpp-btree/btree.h	/^  typedef const value_type& const_reference;$/;"	t	struct:btree::btree_set_params
const_reference	cpp-btree/btree.h	/^  typedef typename Params::const_reference const_reference;$/;"	t	class:btree::btree
const_reference	cpp-btree/btree.h	/^  typedef typename Params::const_reference const_reference;$/;"	t	class:btree::btree_node
const_reference	cpp-btree/btree.h	/^  typedef typename params_type::const_reference const_reference;$/;"	t	struct:btree::btree_iterator
const_reference	cpp-btree/btree_container.h	/^  typedef typename Tree::const_reference const_reference;$/;"	t	class:btree::btree_container
const_reference	mempool.h	/^  typedef const value_type& const_reference;$/;"	t	class:mempool::pool_allocator
const_reference	xlist.h	/^  typedef item* const_reference;$/;"	t	class:xlist
const_reverse_iterator	compact_map.h	/^      const_reverse_iterator() { }$/;"	f	class:compact_map_base::const_reverse_iterator
const_reverse_iterator	compact_map.h	/^      const_reverse_iterator(const compact_map_base* m) : const_iterator_base<typename Map::const_reverse_iterator>(m) { }$/;"	f	class:compact_map_base::const_reverse_iterator
const_reverse_iterator	compact_map.h	/^      const_reverse_iterator(const compact_map_base* m, const typename Map::const_reverse_iterator& i)$/;"	f	class:compact_map_base::const_reverse_iterator
const_reverse_iterator	compact_map.h	/^      const_reverse_iterator(const iterator_base<typename Map::const_reverse_iterator>& o)$/;"	f	class:compact_map_base::const_reverse_iterator
const_reverse_iterator	compact_map.h	/^  class const_reverse_iterator : public const_iterator_base<typename Map::const_reverse_iterator> {$/;"	c	class:compact_map_base
const_reverse_iterator	compact_set.h	/^      const_reverse_iterator() { }$/;"	f	class:compact_set_base::const_reverse_iterator
const_reverse_iterator	compact_set.h	/^      const_reverse_iterator(const compact_set_base* s) : iterator_base<typename Set::const_reverse_iterator>(s) { }$/;"	f	class:compact_set_base::const_reverse_iterator
const_reverse_iterator	compact_set.h	/^      const_reverse_iterator(const compact_set_base* s, const typename Set::const_reverse_iterator& i)$/;"	f	class:compact_set_base::const_reverse_iterator
const_reverse_iterator	compact_set.h	/^      const_reverse_iterator(const iterator_base<typename Set::const_reverse_iterator>& o)$/;"	f	class:compact_set_base::const_reverse_iterator
const_reverse_iterator	compact_set.h	/^  class const_reverse_iterator : public iterator_base<typename Set::const_reverse_iterator> {$/;"	c	class:compact_set_base
const_reverse_iterator	cpp-btree/btree.h	/^  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:btree::btree
const_reverse_iterator	cpp-btree/btree_container.h	/^  typedef typename Tree::const_reverse_iterator const_reverse_iterator;$/;"	t	class:btree::btree_container
construct	mempool.h	/^  template<class U, class... Args> void construct(U* p,Args&&... args) {$/;"	f	class:mempool::pool_allocator
construct	mempool.h	/^  void construct(T* p, const T& val) {$/;"	f	class:mempool::pool_allocator
container_base	denc.h	/^  struct container_base {$/;"	s	namespace:_denc
container_details_base	denc.h	/^  struct container_details_base : public reserve_switch<Container> {$/;"	s	namespace:_denc
container_has_reserve	denc.h	/^  class container_has_reserve {$/;"	c	namespace:_denc
contains	CompatSet.h	/^    bool contains(const Feature& f) const {$/;"	f	class:CompatSet::FeatureSet
contains	CompatSet.h	/^    bool contains(uint64_t f) const {$/;"	f	class:CompatSet::FeatureSet
contains	frag.h	/^  bool contains(frag_t f) const {$/;"	f	class:fragset_t
contains	frag.h	/^  bool contains(frag_t sub) const { return ceph_frag_contains_frag(_enc, sub._enc); }$/;"	f	class:frag_t
contains	frag.h	/^  bool contains(frag_t x) const {$/;"	f	class:fragtree_t
contains	frag.h	/^  bool contains(unsigned v) const { return ceph_frag_contains_value(_enc, v); }$/;"	f	class:frag_t
contains	interval_set.h	/^  bool contains(T i, T *pstart=0, T *plen=0) const {$/;"	f	class:interval_set
contains	interval_set.h	/^  bool contains(T start, T len) const {$/;"	f	class:interval_set
contains	rangeset.h	/^  bool contains(T val) {$/;"	f	class:rangeset
contexts	Context.h	/^  std::list<ContextType*> contexts;$/;"	m	class:C_ContextsBase
contiguous_appender	buffer.h	/^      contiguous_appender(bufferlist *l, size_t len, bool d)$/;"	f	class:ceph::CEPH_BUFFER_API::list::contiguous_appender
contiguous_appender	buffer.h	/^    class contiguous_appender {$/;"	c	class:ceph::CEPH_BUFFER_API::list
contiguous_appender	rados/buffer.h	/^      contiguous_appender(bufferlist *l, size_t len, bool d)$/;"	f	class:ceph::CEPH_BUFFER_API::list::contiguous_appender
contiguous_appender	rados/buffer.h	/^    class contiguous_appender {$/;"	c	class:ceph::CEPH_BUFFER_API::list
cookie	rados.h	/^			__le64 cookie;$/;"	m	struct:ceph_osd_op::__anon13::__anon19
cookie	rados.h	/^			__le64 cookie;$/;"	m	struct:ceph_osd_op::__anon13::__anon20
cookie	rados/librados.hpp	/^    std::string cookie;$/;"	m	struct:librados::__anon42
cookie	rados/rados_types.h	/^  uint64_t cookie;$/;"	m	struct:obj_watch_t
cookie	rbd/librbd.hpp	/^    std::string cookie;$/;"	m	struct:librbd::__anon70
copy_from	rados.h	/^		} __attribute__ ((packed)) copy_from;$/;"	m	union:ceph_osd_op::__anon13	typeref:struct:ceph_osd_op::__anon13::__anon24
copy_from_legacy_head	ceph_fs.h	/^copy_from_legacy_head(struct ceph_mds_request_head *head,$/;"	f
copy_get	rados.h	/^		} __attribute__ ((packed)) copy_get;$/;"	m	union:ceph_osd_op::__anon13	typeref:struct:ceph_osd_op::__anon13::__anon23
copy_to_legacy_head	ceph_fs.h	/^copy_to_legacy_head(struct ceph_mds_request_head_legacy *legacy,$/;"	f
copy_to_timeval	utime.h	/^  void copy_to_timeval(struct timeval *v) const {$/;"	f	class:utime_t
count	compact_map.h	/^  size_t count (const Key& k) const {$/;"	f	class:compact_map_base
count	compact_set.h	/^  size_t count(const T& t) const {$/;"	f	class:compact_set_base
count	counter.h	/^  static uint64_t count() {$/;"	f	class:Counter
count	cpp-btree/btree.h	/^    field_type count;$/;"	m	struct:btree::btree_node::base_fields
count	cpp-btree/btree.h	/^  int count() const { return fields_.count; }$/;"	f	class:btree::btree_node
count	cpp-btree/btree_container.h	/^  size_type count(const key_type &key) const {$/;"	f	class:btree::btree_multi_container
count	cpp-btree/btree_container.h	/^  size_type count(const key_type &key) const {$/;"	f	class:btree::btree_unique_container
count	rados.h	/^			__le64 count;$/;"	m	struct:ceph_osd_op::__anon13::__anon17
count_multi	cpp-btree/btree.h	/^  size_type count_multi(const key_type &key) const {$/;"	f	class:btree::btree
count_unique	cpp-btree/btree.h	/^  size_type count_unique(const key_type &key) const {$/;"	f	class:btree::btree
crc	buffer.h	/^    uint32_t crc;$/;"	m	class:ceph::CEPH_BUFFER_API::hash
crc	msgr.h	/^	__le32 crc;       \/* header crc32c *\/$/;"	m	struct:ceph_msg_header
crc	msgr.h	/^	__le32 crc;       \/* header crc32c *\/$/;"	m	struct:ceph_msg_header_old
crc	rados/buffer.h	/^    uint32_t crc;$/;"	m	class:ceph::CEPH_BUFFER_API::hash
created	ceph_fs.h	/^	__le64 created;       \/* snap: when created *\/$/;"	m	struct:ceph_mds_snap_realm
crypt_type	rbd_types.h	/^		__u8 crypt_type;$/;"	m	struct:rbd_obj_header_ondisk::__anon32
ctime	ceph_fs.h	/^			struct ceph_timespec mtime, atime, ctime;$/;"	m	struct:ceph_mds_caps_body_legacy::__anon66::__anon67	typeref:struct:ceph_mds_caps_body_legacy::__anon66::__anon67::
ctx	rbd/librbd.hpp	/^  image_ctx_t ctx;$/;"	m	class:librbd::Image
cur	elist.h	/^    item *cur, *next;$/;"	m	class:elist::iterator
cur	xlist.h	/^    item *cur;$/;"	m	class:xlist::const_iterator
cur	xlist.h	/^    item *cur;$/;"	m	class:xlist::iterator
current	rangeset.h	/^  T current;$/;"	m	class:rangeset_iterator
d_dirent	statlite.h	/^ struct dirent     d_dirent;  \/* dirent struct for this entry *\/$/;"	m	struct:dirent_lite	typeref:struct:dirent_lite::dirent
d_dirent	statlite.h	/^ struct dirent     d_dirent;  \/* dirent struct for this entry *\/$/;"	m	struct:dirent_plus	typeref:struct:dirent_plus::dirent
d_stat	statlite.h	/^ struct stat       d_stat;    \/* attributes for this entry *\/$/;"	m	struct:dirent_plus	typeref:struct:dirent_plus::stat
d_stat	statlite.h	/^ struct statlite   d_stat;    \/* attributes for this entry *\/$/;"	m	struct:dirent_lite	typeref:struct:dirent_lite::statlite
d_stat_err	statlite.h	/^ int               d_stat_err;\/* errno for d_stat, or 0 *\/$/;"	m	struct:dirent_lite
d_stat_err	statlite.h	/^ int               d_stat_err;\/* errno for d_stat, or 0 *\/$/;"	m	struct:dirent_plus
data	ceph_fs.h	/^	char data[0];$/;"	m	struct:ceph_mon_poolop_reply
data	cpp-btree/btree.h	/^    Data data;$/;"	m	struct:btree::btree::empty_base_handle
data_crc	msgr.h	/^	__le32 front_crc, middle_crc, data_crc;$/;"	m	struct:ceph_msg_footer
data_crc	msgr.h	/^	__le32 front_crc, middle_crc, data_crc;$/;"	m	struct:ceph_msg_footer_old
data_digest	rados/rados_types.hpp	/^  uint32_t data_digest = 0;$/;"	m	struct:librados::shard_info_t
data_digest_present	rados/rados_types.hpp	/^  bool data_digest_present = false;$/;"	m	struct:librados::shard_info_t
data_len	msgr.h	/^	__le32 data_len;  \/* bytes of data payload *\/$/;"	m	struct:ceph_msg_header
data_len	msgr.h	/^	__le32 data_len;  \/* bytes of data payload *\/$/;"	m	struct:ceph_msg_header_old
data_length	rados.h	/^			__le64 data_length;$/;"	m	struct:ceph_osd_op::__anon13::__anon28
data_off	msgr.h	/^	__le16 data_off;  \/* sender: include full offset;$/;"	m	struct:ceph_msg_header
data_off	msgr.h	/^	__le16 data_off;  \/* sender: include full offset;$/;"	m	struct:ceph_msg_header_old
data_type	cpp-btree/btree.h	/^  typedef Data data_type;$/;"	t	struct:btree::btree_map_params
data_type	cpp-btree/btree.h	/^  typedef std::false_type data_type;$/;"	t	struct:btree::btree_set_params
data_type	cpp-btree/btree.h	/^  typedef typename Params::data_type data_type;$/;"	t	class:btree::btree
data_type	cpp-btree/btree.h	/^  typedef typename Params::data_type data_type;$/;"	t	class:btree::btree_node
data_type	cpp-btree/btree_container.h	/^  typedef typename Tree::data_type data_type;$/;"	t	class:btree::btree_map_container
data_type	cpp-btree/btree_map.h	/^  typedef typename btree_type::data_type data_type;$/;"	t	class:btree::btree_multimap
days_from_0	timegm.h	/^static int32_t days_from_0(int32_t year) {$/;"	f
days_from_1970	timegm.h	/^int32_t static days_from_1970(int32_t year) {$/;"	f
days_from_1jan	timegm.h	/^static int32_t days_from_1jan(int32_t year,int32_t month,int32_t day) {$/;"	f
deallocate	mempool.h	/^  void deallocate(T* p, size_t n) {$/;"	f	class:mempool::pool_allocator
deallocate_aligned	mempool.h	/^  void deallocate_aligned(T* p, size_t n) {$/;"	f	class:mempool::pool_allocator
decode	CompatSet.h	/^    void decode(bufferlist::iterator& bl) {$/;"	f	class:CompatSet::FeatureSet
decode	CompatSet.h	/^  void decode(bufferlist::iterator& bl) {$/;"	f	struct:CompatSet
decode	btree_map.h	/^inline void decode(btree::btree_map<T,U>& m, bufferlist::iterator& p)$/;"	f
decode	compact_map.h	/^  void decode(bufferlist::iterator& p) {$/;"	f	class:compact_map_base
decode	compact_map.h	/^inline void decode(compact_map_base<Key, T, Map>& m, bufferlist::iterator& p) {$/;"	f
decode	compact_set.h	/^  void decode(bufferlist::iterator& p) {$/;"	f	class:compact_set_base
decode	compact_set.h	/^inline void decode(compact_set_base<T, Set>& m, bufferlist::iterator& p) {$/;"	f
decode	denc.h	/^			       !traits::need_contiguous>::type decode($/;"	f
decode	denc.h	/^			       traits::need_contiguous>::type decode($/;"	f
decode	denc.h	/^    decode(container& s, buffer::list::iterator& p) {$/;"	f	struct:_denc::container_base
decode	denc.h	/^    decode(std::pair<A,B>& v, buffer::list::iterator& p,$/;"	f	struct:denc_traits
decode	denc.h	/^    static void decode(T& v, bufferlist::iterator& p) {$/;"	f	struct:_denc::has_legacy_denc
decode	denc.h	/^    static void decode(container& s, buffer::ptr::iterator& p, uint64_t f = 0) {$/;"	f	struct:_denc::container_base
decode	denc.h	/^  decode(boost::optional<T>& v, buffer::list::iterator& p) {$/;"	f	struct:denc_traits
decode	denc.h	/^  decode(container& s, buffer::list::iterator& p) {$/;"	f	struct:denc_traits
decode	denc.h	/^  decode(container& s, buffer::list::iterator& p, uint64_t f = 0) {$/;"	f	struct:denc_traits
decode	denc.h	/^  static void decode(T& o, buffer::list::iterator &p) {$/;"	f	struct:denc_traits
decode	denc.h	/^  static void decode(T& o, buffer::ptr::iterator &p,$/;"	f	struct:denc_traits
decode	denc.h	/^  static void decode(boost::optional<T>& v, buffer::ptr::iterator& p,$/;"	f	struct:denc_traits
decode	denc.h	/^  static void decode(bufferlist& v, buffer::list::iterator& p) {$/;"	f	struct:denc_traits
decode	denc.h	/^  static void decode(bufferlist& v, buffer::ptr::iterator& p, uint64_t f=0) {$/;"	f	struct:denc_traits
decode	denc.h	/^  static void decode(bufferptr& v, buffer::list::iterator& p) {$/;"	f	struct:denc_traits
decode	denc.h	/^  static void decode(bufferptr& v, buffer::ptr::iterator& p, uint64_t f=0) {$/;"	f	struct:denc_traits
decode	denc.h	/^  static void decode(container& s, buffer::ptr::iterator& p, uint64_t f = 0) {$/;"	f	struct:denc_traits
decode	denc.h	/^  static void decode(std::pair<A,B>& v, buffer::ptr::iterator& p, uint64_t f=0) {$/;"	f	struct:denc_traits
decode	denc.h	/^  static void decode(value_type& s, buffer::list::iterator& p)$/;"	f	struct:denc_traits
decode	denc.h	/^  static void decode(value_type& s,$/;"	f	struct:denc_traits
decode	encoding.h	/^  decode(boost::container::flat_map<T,U,Comp,Alloc>& m, bufferlist::iterator& p)$/;"	f
decode	encoding.h	/^  decode(std::list<T,Alloc>& ls, bufferlist::iterator& p)$/;"	f
decode	encoding.h	/^  decode(std::map<T,U,Comp,Alloc>& m, bufferlist::iterator& p)$/;"	f
decode	encoding.h	/^  decode(std::pair<A,B> &pa, bufferlist::iterator &p)$/;"	f
decode	encoding.h	/^  decode(std::set<T,Comp,Alloc>& s, bufferlist::iterator& p)$/;"	f
decode	encoding.h	/^  decode(std::vector<T,Alloc>& v, bufferlist::iterator& p)$/;"	f
decode	encoding.h	/^decode(boost::container::flat_set<T, Comp, Alloc>& s, bufferlist::iterator& p)$/;"	f
decode	encoding.h	/^decode(std::array<T, N>& v, bufferlist::iterator& p)$/;"	f
decode	encoding.h	/^inline void decode(T &o, bufferlist& bl)$/;"	f
decode	encoding.h	/^inline void decode(bool &v, bufferlist::iterator& p) {$/;"	f
decode	encoding.h	/^inline void decode(boost::optional<T> &p, bufferlist::iterator &bp)$/;"	f
decode	encoding.h	/^inline void decode(boost::tuple<A, B, C> &t, bufferlist::iterator &bp)$/;"	f
decode	encoding.h	/^inline void decode(buffer::ptr& bp, bufferlist::iterator& p)$/;"	f
decode	encoding.h	/^inline void decode(bufferlist& s, bufferlist::iterator& p)$/;"	f
decode	encoding.h	/^inline void decode(ceph::unordered_set<T,Hash,Pred,Alloc>& m, bufferlist::iterator& p)$/;"	f
decode	encoding.h	/^inline void decode(std::deque<T,Alloc>& ls, bufferlist::iterator& p)$/;"	f
decode	encoding.h	/^inline void decode(std::list<ceph::shared_ptr<T>, Alloc>& ls,$/;"	f
decode	encoding.h	/^inline void decode(std::multimap<T,U,Comp,Alloc>& m, bufferlist::iterator& p)$/;"	f
decode	encoding.h	/^inline void decode(std::multiset<T,Comp,Alloc>& s, bufferlist::iterator& p)$/;"	f
decode	encoding.h	/^inline void decode(std::string& s, bufferlist::iterator& p)$/;"	f
decode	encoding.h	/^inline void decode(std::vector<ceph::shared_ptr<T>,Alloc>& v,$/;"	f
decode	encoding.h	/^inline void decode(unordered_map<T,U,Hash,Pred,Alloc>& m, bufferlist::iterator& p)$/;"	f
decode	filepath.h	/^  void decode(bufferlist::iterator& blp) {$/;"	f	class:filepath
decode	frag.h	/^  void decode(bufferlist::iterator& p) {$/;"	f	class:fragtree_t
decode	frag.h	/^inline void decode(frag_t &f, bufferlist::iterator& p) {$/;"	f
decode	fs_types.h	/^  static void decode(inodeno_t& o, buffer::ptr::iterator &p) {$/;"	f	struct:denc_traits
decode	fs_types.h	/^  void decode(bufferlist::iterator& p) {$/;"	f	struct:inodeno_t
decode	health.h	/^  static void decode(health_status_t& v, buffer::list::iterator& p,$/;"	f	struct:denc_traits
decode	health.h	/^  static void decode(health_status_t& v, buffer::ptr::iterator& p,$/;"	f	struct:denc_traits
decode	health.h	/^static inline void decode(health_status_t& hs, bufferlist::iterator& p) {$/;"	f
decode	interval_set.h	/^    decode(interval_set<T,Map>& v, bufferlist::iterator& p) {$/;"	f	struct:denc_traits
decode	interval_set.h	/^  static void decode(interval_set<T,Map>& v, bufferptr::iterator& p) {$/;"	f	struct:denc_traits
decode	interval_set.h	/^  void decode(bufferlist::iterator& p) {$/;"	f	class:interval_set
decode	interval_set.h	/^  void decode(bufferptr::iterator& p) {$/;"	f	class:interval_set
decode	object.h	/^  static void decode(snapid_t& o, buffer::ptr::iterator &p) {$/;"	f	struct:denc_traits
decode	object.h	/^  void decode(bufferlist::iterator &bl) {$/;"	f	struct:object_t
decode	object.h	/^  void decode(bufferlist::iterator& bl) {$/;"	f	struct:sobject_t
decode	object.h	/^inline void decode(snapid_t &i, bufferlist::iterator &p) { decode(i.val, p); }$/;"	f
decode	types.h	/^  void decode(bufferlist::iterator &bl) {$/;"	f	struct:errorcode32_t
decode	types.h	/^  void decode(bufferlist::iterator &bl) {$/;"	f	struct:shard_id_t
decode	types.h	/^  void decode(bufferlist::iterator& bl) {$/;"	f	struct:client_t
decode	util.h	/^  void decode(bufferlist::iterator &p) {$/;"	f	struct:ceph_data_stats
decode	utime.h	/^  void decode(bufferlist::iterator &p) {$/;"	f	class:utime_t
decode	uuid.h	/^  void decode(bufferlist::iterator& p) const {$/;"	f	struct:uuid_d
decode_file	encoding.h	/^inline ssize_t decode_file(int fd, bufferptr &bp)$/;"	f
decode_file	encoding.h	/^inline ssize_t decode_file(int fd, std::string &str)$/;"	f
decode_helper	denc.h	/^  static void decode_helper(T& s, buffer::list::iterator& p,$/;"	f	struct:denc_traits
decode_helper	denc.h	/^  static void decode_helper(T& s, buffer::ptr::iterator& p,$/;"	f	struct:denc_traits
decode_noclear	encoding.h	/^inline void decode_noclear(boost::container::flat_map<T,U,Comp,Alloc>& m,$/;"	f
decode_noclear	encoding.h	/^inline void decode_noclear(std::map<T,U,Comp,Alloc>& m, bufferlist::iterator& p)$/;"	f
decode_nohead	btree_map.h	/^inline void decode_nohead(int n, btree::btree_map<T,U>& m, bufferlist::iterator& p)$/;"	f
decode_nohead	denc.h	/^			       !traits::featured>::type decode_nohead($/;"	f
decode_nohead	denc.h	/^    decode_nohead(size_t num, container& s,$/;"	f	struct:_denc::container_base
decode_nohead	denc.h	/^    static void decode_nohead(size_t num, container& s,$/;"	f	struct:_denc::container_base
decode_nohead	denc.h	/^  static void decode_nohead(bool num, boost::optional<T>& v,$/;"	f	struct:denc_traits
decode_nohead	denc.h	/^  static void decode_nohead(size_t len, bufferlist& v,$/;"	f	struct:denc_traits
decode_nohead	denc.h	/^  static void decode_nohead(size_t len, value_type& s,$/;"	f	struct:denc_traits
decode_nohead	encoding.h	/^  decode_nohead(int len, std::set<T,Comp,Alloc>& s, bufferlist::iterator& p)$/;"	f
decode_nohead	encoding.h	/^  decode_nohead(int len, std::vector<T,Alloc>& v, bufferlist::iterator& p)$/;"	f
decode_nohead	encoding.h	/^  decode_nohead(int n, boost::container::flat_map<T,U,Comp,Alloc>& m,$/;"	f
decode_nohead	encoding.h	/^  decode_nohead(int n, std::map<T,U,Comp,Alloc>& m, bufferlist::iterator& p)$/;"	f
decode_nohead	encoding.h	/^decode_nohead(int len, boost::container::flat_set<T, Comp, Alloc>& s,$/;"	f
decode_nohead	encoding.h	/^inline void decode_nohead(int len, bufferlist& s, bufferlist::iterator& p)$/;"	f
decode_nohead	encoding.h	/^inline void decode_nohead(int len, std::string& s, bufferlist::iterator& p)$/;"	f
decode_nohead	frag.h	/^  void decode_nohead(int n, bufferlist::iterator& p) {$/;"	f	class:fragtree_t
decode_nohead	interval_set.h	/^  static void decode_nohead(size_t n, interval_set<T,Map>& v,$/;"	f	struct:denc_traits
decode_nohead	interval_set.h	/^  void decode_nohead(int n, bufferptr::iterator& p) {$/;"	f	class:interval_set
decode_raw	encoding.h	/^inline void decode_raw(T& t, bufferlist::iterator &p)$/;"	f
decode_timeval	utime.h	/^  void decode_timeval(const struct ceph_timespec *t) {$/;"	f	class:utime_t
decrement	cpp-btree/btree.h	/^  void decrement() {$/;"	f	struct:btree::btree_iterator
decrements	counter.h	/^  static uint64_t decrements() {$/;"	f	class:Counter
deep	buffer.h	/^      bool deep;         \/\/\/< if true, no not allow shallow ptr copies$/;"	m	class:ceph::CEPH_BUFFER_API::ptr::iterator
deep	buffer.h	/^      bool deep;$/;"	m	class:ceph::CEPH_BUFFER_API::list::contiguous_appender
deep	rados/buffer.h	/^      bool deep;         \/\/\/< if true, no not allow shallow ptr copies$/;"	m	class:ceph::CEPH_BUFFER_API::ptr::iterator
deep	rados/buffer.h	/^      bool deep;$/;"	m	class:ceph::CEPH_BUFFER_API::list::contiguous_appender
deferment_end_time	rbd/librbd.h	/^  time_t deferment_end_time;$/;"	m	struct:__anon87
deferment_end_time	rbd/librbd.hpp	/^    time_t deferment_end_time;$/;"	m	struct:librbd::__anon74
delete_internal_node	cpp-btree/btree.h	/^  void delete_internal_node(node_type *node) {$/;"	f	class:btree::btree
delete_internal_root_node	cpp-btree/btree.h	/^  void delete_internal_root_node() {$/;"	f	class:btree::btree
delete_leaf_node	cpp-btree/btree.h	/^  void delete_leaf_node(node_type *node) {$/;"	f	class:btree::btree
delete_me	Context.h	/^  void delete_me() {$/;"	f	class:C_GatherBase
deletion_time	rbd/librbd.h	/^  time_t deletion_time;$/;"	m	struct:__anon87
deletion_time	rbd/librbd.hpp	/^    time_t deletion_time;$/;"	m	struct:librbd::__anon74
demangle	demangle.h	/^static std::string demangle(const char* name)$/;"	f
denc	denc.h	/^			       !traits::featured>::type denc($/;"	f
denc	denc.h	/^			       has_legacy_denc::value>::type denc($/;"	f
denc	denc.h	/^			       traits::featured>::type denc($/;"	f
denc_lba	denc.h	/^inline void denc_lba(uint64_t v, bufferlist::contiguous_appender& p) {$/;"	f
denc_lba	denc.h	/^inline void denc_lba(uint64_t v, size_t& p) {$/;"	f
denc_lba	denc.h	/^inline void denc_lba(uint64_t& v, bufferptr::iterator& p) {$/;"	f
denc_signed_varint	denc.h	/^inline void denc_signed_varint(T& v, bufferptr::iterator& p)$/;"	f
denc_signed_varint	denc.h	/^inline void denc_signed_varint(int64_t v, bufferlist::contiguous_appender& p) {$/;"	f
denc_signed_varint	denc.h	/^inline void denc_signed_varint(int64_t v, size_t& p) {$/;"	f
denc_signed_varint_lowz	denc.h	/^inline void denc_signed_varint_lowz(T& v, bufferptr::iterator& p)$/;"	f
denc_signed_varint_lowz	denc.h	/^inline void denc_signed_varint_lowz(int64_t v, size_t& p) {$/;"	f
denc_signed_varint_lowz	denc.h	/^inline void denc_signed_varint_lowz(int64_t v,$/;"	f
denc_traits	denc.h	/^struct denc_traits {$/;"	s
denc_traits	denc.h	/^struct denc_traits<$/;"	s
denc_traits	denc.h	/^struct denc_traits<boost::none_t> {$/;"	s
denc_traits	denc.h	/^struct denc_traits<bufferlist> {$/;"	s
denc_traits	denc.h	/^struct denc_traits<bufferptr> {$/;"	s
denc_traits	denc.h	/^struct denc_traits<std::basic_string<char,std::char_traits<char>,A>> {$/;"	s
denc_traits	fs_types.h	/^struct denc_traits<inodeno_t> {$/;"	s
denc_traits	health.h	/^struct denc_traits<health_status_t> {$/;"	s
denc_traits	interval_set.h	/^struct denc_traits<interval_set<T,Map>> {$/;"	s
denc_traits	object.h	/^struct denc_traits<snapid_t> {$/;"	s
denc_varint	denc.h	/^inline void denc_varint(T v, bufferlist::contiguous_appender& p) {$/;"	f
denc_varint	denc.h	/^inline void denc_varint(T v, size_t& p) {$/;"	f
denc_varint	denc.h	/^inline void denc_varint(T& v, bufferptr::iterator& p) {$/;"	f
denc_varint_lowz	denc.h	/^inline void denc_varint_lowz(T& v, bufferptr::iterator& p)$/;"	f
denc_varint_lowz	denc.h	/^inline void denc_varint_lowz(uint64_t v, bufferlist::contiguous_appender& p) {$/;"	f
denc_varint_lowz	denc.h	/^inline void denc_varint_lowz(uint64_t v, size_t& p) {$/;"	f
depth	filepath.h	/^  unsigned depth() const {$/;"	f	class:filepath
description	rbd/librbd.h	/^  char *description;$/;"	m	struct:__anon83
description	rbd/librbd.hpp	/^    std::string description;$/;"	m	struct:librbd::__anon73
destroy	cpp-btree/btree.h	/^  void destroy() {$/;"	f	class:btree::btree_node
destroy	mempool.h	/^  void destroy(T* p) {$/;"	f	class:mempool::pool_allocator
destroy	mempool.h	/^  void destroy(U *p) {$/;"	f	class:mempool::pool_allocator
difference_type	cpp-btree/btree.h	/^  typedef ptrdiff_t difference_type;$/;"	t	struct:btree::btree_common_params
difference_type	cpp-btree/btree.h	/^  typedef typename Node::difference_type difference_type;$/;"	t	struct:btree::btree_iterator
difference_type	cpp-btree/btree.h	/^  typedef typename Params::difference_type difference_type;$/;"	t	class:btree::btree
difference_type	cpp-btree/btree.h	/^  typedef typename Params::difference_type difference_type;$/;"	t	class:btree::btree_node
difference_type	cpp-btree/btree_container.h	/^  typedef typename Tree::difference_type difference_type;$/;"	t	class:btree::btree_container
difference_type	mempool.h	/^  typedef std::ptrdiff_t difference_type;$/;"	t	class:mempool::pool_allocator
digest	buffer.h	/^    uint32_t digest() {$/;"	f	class:ceph::CEPH_BUFFER_API::hash
digest	rados/buffer.h	/^    uint32_t digest() {$/;"	f	class:ceph::CEPH_BUFFER_API::hash
dirent_lite	statlite.h	/^struct dirent_lite {$/;"	s
dirent_plus	statlite.h	/^struct dirent_plus {$/;"	s
dirty	ceph_fs.h	/^	__le32 caps, wanted, dirty; \/* latest issued\/wanted\/dirty *\/$/;"	m	struct:ceph_mds_caps_head
dispatch	cpp-btree/btree.h	/^  static std::pair<Iter, int> dispatch(const K &k, const T &t, Iter iter) {$/;"	f	struct:btree::btree_internal_locate_compare_to
dispatch	cpp-btree/btree.h	/^  static std::pair<Iter, int> dispatch(const K &k, const T &t, Iter iter) {$/;"	f	struct:btree::btree_internal_locate_plain_compare
dist	ceph_fs.h	/^	__le32 dist[];$/;"	m	struct:ceph_mds_reply_dirfrag
dl_dir_hash	ceph_fs.h	/^	__u8   dl_dir_hash;   \/* see ceph_hash.h for ids *\/$/;"	m	struct:ceph_dir_layout
dl_unused1	ceph_fs.h	/^	__u8   dl_unused1;$/;"	m	struct:ceph_dir_layout
dl_unused2	ceph_fs.h	/^	__u16  dl_unused2;$/;"	m	struct:ceph_dir_layout
dl_unused3	ceph_fs.h	/^	__u32  dl_unused3;$/;"	m	struct:ceph_dir_layout
dname_len	ceph_fs.h	/^	__le32 dname_len;              \/* string follows. *\/$/;"	m	struct:ceph_mds_request_release
dname_seq	ceph_fs.h	/^	__le32 dname_seq;              \/* if releasing a dentry lease, a *\/$/;"	m	struct:ceph_mds_request_release
dummy	cpp-btree/btree.h	/^  char dummy[2];$/;"	m	struct:btree::big_
dump	CompatSet.h	/^    void dump(Formatter *f) const {$/;"	f	class:CompatSet::FeatureSet
dump	CompatSet.h	/^  void dump(Formatter *f) const {$/;"	f	struct:CompatSet
dump	cpp-btree/btree.h	/^  void dump(std::ostream &os) const {$/;"	f	class:btree::btree
dump	cpp-btree/btree_container.h	/^  void dump(std::ostream &os) const {$/;"	f	class:btree::btree_container
dump	filepath.h	/^  void dump(Formatter *f) const {$/;"	f	class:filepath
dump	frag.h	/^  void dump(Formatter *f) const {$/;"	f	class:fragtree_t
dump	mempool.h	/^  void dump(ceph::Formatter *f) const {$/;"	f	struct:mempool::stats_t
dump	rangeset.h	/^  void dump() {$/;"	f	class:rangeset
dump	util.h	/^  void dump(Formatter *f) const {$/;"	f	struct:ceph_data_stats
duration	ceph_fs.h	/^	__le32 duration;         \/* seconds *\/$/;"	m	struct:ceph_mon_subscribe_ack
duration_ms	ceph_fs.h	/^	__le32 duration_ms;     \/* duration of renewal *\/$/;"	m	struct:ceph_mds_lease
duration_ms	ceph_fs.h	/^	__le32 duration_ms;     \/* lease duration *\/$/;"	m	struct:ceph_mds_reply_lease
element_type	alloc_ptr.h	/^    typedef typename std::pointer_traits< std::unique_ptr<T> >::element_type element_type;$/;"	t	class:alloc_ptr
elist	elist.h	/^  elist(size_t o) : _head(NULL), item_offset(o) {}$/;"	f	class:elist
elist	elist.h	/^class elist {$/;"	c
emplace	compact_map.h	/^  std::pair<iterator,bool> emplace ( Args&&... args ) {$/;"	f	class:compact_map_base
emplace	compact_set.h	/^  std::pair<iterator,bool> emplace ( Args&&... args ) {$/;"	f	class:compact_set_base
empty	Context.h	/^  bool empty() { return contexts.empty(); }$/;"	f	class:C_ContextsBase
empty	compact_map.h	/^  bool empty() const {$/;"	f	class:compact_map_base
empty	compact_set.h	/^  bool empty() const {$/;"	f	class:compact_set_base
empty	cpp-btree/btree.h	/^  bool empty() const { return root() == NULL; }$/;"	f	class:btree::btree
empty	cpp-btree/btree_container.h	/^  bool empty() const { return tree_.empty(); }$/;"	f	class:btree::btree_container
empty	elist.h	/^    bool empty() const { return _prev == this; }$/;"	f	struct:elist::item
empty	elist.h	/^  bool empty() const {$/;"	f	class:elist
empty	filepath.h	/^  bool empty() const { return path.length() == 0 && ino == 0; }$/;"	f	class:filepath
empty	frag.h	/^  bool empty() const { $/;"	f	class:fragtree_t
empty	frag.h	/^  bool empty() const { return _set.empty(); }$/;"	f	class:fragset_t
empty	interval_set.h	/^  bool empty() const {$/;"	f	class:interval_set
empty	rangeset.h	/^  bool empty() {$/;"	f	class:rangeset
empty	xlist.h	/^  bool empty() const { $/;"	f	class:xlist
empty_base_handle	cpp-btree/btree.h	/^    empty_base_handle(const Base &b, const Data &d)$/;"	f	struct:btree::btree::empty_base_handle
empty_base_handle	cpp-btree/btree.h	/^  struct empty_base_handle : public Base {$/;"	s	class:btree::btree
encode	CompatSet.h	/^    void encode(bufferlist& bl) const {$/;"	f	class:CompatSet::FeatureSet
encode	CompatSet.h	/^  void encode(bufferlist& bl) const {$/;"	f	struct:CompatSet
encode	btree_map.h	/^inline void encode(const btree::btree_map<T,U>& m, bufferlist& bl)$/;"	f
encode	btree_map.h	/^inline void encode(const btree::btree_map<T,U>& m, bufferlist& bl, uint64_t features)$/;"	f
encode	compact_map.h	/^  void encode(bufferlist &bl) const {$/;"	f	class:compact_map_base
encode	compact_map.h	/^  void encode(bufferlist &bl, uint64_t features) const {$/;"	f	class:compact_map_base
encode	compact_map.h	/^inline void encode(const compact_map_base<Key, T, Map>& m, bufferlist& bl) {$/;"	f
encode	compact_map.h	/^inline void encode(const compact_map_base<Key, T, Map>& m, bufferlist& bl,$/;"	f
encode	compact_set.h	/^  void encode(bufferlist &bl) const {$/;"	f	class:compact_set_base
encode	compact_set.h	/^inline void encode(const compact_set_base<T, Set>& m, bufferlist& bl) {$/;"	f
encode	denc.h	/^			       !traits::featured>::type encode($/;"	f
encode	denc.h	/^			       traits::featured>::type encode($/;"	f
encode	denc.h	/^    encode(const container& s, buffer::list::contiguous_appender& p) {$/;"	f	struct:_denc::container_base
encode	denc.h	/^    encode(const container& s, buffer::list::contiguous_appender& p,$/;"	f	struct:_denc::container_base
encode	denc.h	/^    encode(const container& s, buffer::list::contiguous_appender& p,$/;"	f	struct:denc_traits
encode	denc.h	/^  encode(const boost::optional<T>& v, bufferlist::contiguous_appender& p) {$/;"	f	struct:denc_traits
encode	denc.h	/^  encode(const boost::optional<T>& v, bufferlist::contiguous_appender& p,$/;"	f	struct:denc_traits
encode	denc.h	/^  encode(const container& s, buffer::list::contiguous_appender& p) {$/;"	f	struct:denc_traits
encode	denc.h	/^  encode(const container& s, buffer::list::contiguous_appender& p,$/;"	f	struct:denc_traits
encode	denc.h	/^  encode(const std::pair<A,B>& v, bufferlist::contiguous_appender& p) {$/;"	f	struct:denc_traits
encode	denc.h	/^  encode(const std::pair<A,B>& v, bufferlist::contiguous_appender& p,$/;"	f	struct:denc_traits
encode	denc.h	/^  static void encode(const T &o, buffer::list::contiguous_appender& p,$/;"	f	struct:denc_traits
encode	denc.h	/^  static void encode(const T &o,$/;"	f	struct:denc_traits
encode	denc.h	/^  static void encode(const boost::none_t& v,$/;"	f	struct:denc_traits
encode	denc.h	/^  static void encode(const bufferlist& v, buffer::list::contiguous_appender& p,$/;"	f	struct:denc_traits
encode	denc.h	/^  static void encode(const bufferptr& v, buffer::list::contiguous_appender& p,$/;"	f	struct:denc_traits
encode	denc.h	/^  static void encode(const value_type& s,$/;"	f	struct:denc_traits
encode	encoding.h	/^  encode(const boost::container::flat_map<T,U,Comp,Alloc>& m, bufferlist& bl)$/;"	f
encode	encoding.h	/^  encode(const boost::container::flat_map<T,U,Comp,Alloc>& m, bufferlist& bl,$/;"	f
encode	encoding.h	/^  encode(const std::list<T, Alloc>& ls, bufferlist& bl)$/;"	f
encode	encoding.h	/^  encode(const std::list<T,Alloc>& ls, bufferlist& bl, uint64_t features)$/;"	f
encode	encoding.h	/^  encode(const std::map<T,U,Comp,Alloc>& m, bufferlist& bl)$/;"	f
encode	encoding.h	/^  encode(const std::map<T,U,Comp,Alloc>& m, bufferlist& bl, uint64_t features)$/;"	f
encode	encoding.h	/^  encode(const std::pair<A,B> &p, bufferlist &bl)$/;"	f
encode	encoding.h	/^  encode(const std::pair<A,B> &p, bufferlist &bl, uint64_t features)$/;"	f
encode	encoding.h	/^  encode(const std::set<T,Comp,Alloc>& s, bufferlist& bl)$/;"	f
encode	encoding.h	/^  encode(const std::vector<T,Alloc>& v, bufferlist& bl)$/;"	f
encode	encoding.h	/^  encode(const std::vector<T,Alloc>& v, bufferlist& bl, uint64_t features)$/;"	f
encode	encoding.h	/^encode(const boost::container::flat_set<T, Comp, Alloc>& s, bufferlist& bl)$/;"	f
encode	encoding.h	/^encode(const std::array<T, N>& v, bufferlist& bl)$/;"	f
encode	encoding.h	/^encode(const std::array<T, N>& v, bufferlist& bl, uint64_t features)$/;"	f
encode	encoding.h	/^inline void encode(boost::string_view s, bufferlist& bl, uint64_t features=0)$/;"	f
encode	encoding.h	/^inline void encode(const bool &v, bufferlist& bl) {$/;"	f
encode	encoding.h	/^inline void encode(const boost::optional<T> &p, bufferlist &bl)$/;"	f
encode	encoding.h	/^inline void encode(const boost::tuple<A, B, C> &t, bufferlist& bl)$/;"	f
encode	encoding.h	/^inline void encode(const buffer::ptr& bp, bufferlist& bl) $/;"	f
encode	encoding.h	/^inline void encode(const bufferlist& s, bufferlist& bl) $/;"	f
encode	encoding.h	/^inline void encode(const ceph::unordered_set<T,Hash,Pred,Alloc>& m, bufferlist& bl)$/;"	f
encode	encoding.h	/^inline void encode(const char *s, bufferlist& bl) $/;"	f
encode	encoding.h	/^inline void encode(const std::deque<T,Alloc>& ls, bufferlist& bl)$/;"	f
encode	encoding.h	/^inline void encode(const std::deque<T,Alloc>& ls, bufferlist& bl, uint64_t features)$/;"	f
encode	encoding.h	/^inline void encode(const std::list<ceph::shared_ptr<T>, Alloc>& ls,$/;"	f
encode	encoding.h	/^inline void encode(const std::multimap<T,U,Comp,Alloc>& m, bufferlist& bl)$/;"	f
encode	encoding.h	/^inline void encode(const std::multiset<T,Comp,Alloc>& s, bufferlist& bl)$/;"	f
encode	encoding.h	/^inline void encode(const std::string& s, bufferlist& bl, uint64_t features=0)$/;"	f
encode	encoding.h	/^inline void encode(const std::vector<ceph::shared_ptr<T>,Alloc>& v,$/;"	f
encode	encoding.h	/^inline void encode(const unordered_map<T,U,Hash,Pred,Alloc>& m, bufferlist& bl)$/;"	f
encode	encoding.h	/^inline void encode(const unordered_map<T,U,Hash,Pred,Alloc>& m, bufferlist& bl,$/;"	f
encode	filepath.h	/^  void encode(bufferlist& bl) const {$/;"	f	class:filepath
encode	frag.h	/^  void encode(bufferlist& bl) const {$/;"	f	class:fragtree_t
encode	frag.h	/^inline void encode(const frag_t &f, bufferlist& bl) { encode_raw(f._enc, bl); }$/;"	f
encode	fs_types.h	/^  static void encode(const inodeno_t &o, buffer::list::contiguous_appender& p) {$/;"	f	struct:denc_traits
encode	fs_types.h	/^  void encode(bufferlist& bl) const {$/;"	f	struct:inodeno_t
encode	health.h	/^  static void encode(const health_status_t& v,$/;"	f	struct:denc_traits
encode	health.h	/^static inline void encode(health_status_t hs, bufferlist& bl) {$/;"	f
encode	interval_set.h	/^  static void encode(const interval_set<T,Map>& v,$/;"	f	struct:denc_traits
encode	interval_set.h	/^  void encode(bufferlist::contiguous_appender& p) const {$/;"	f	class:interval_set
encode	object.h	/^  static void encode(const snapid_t &o, buffer::list::contiguous_appender& p) {$/;"	f	struct:denc_traits
encode	object.h	/^  void encode(bufferlist &bl) const {$/;"	f	struct:object_t
encode	object.h	/^  void encode(bufferlist& bl) const {$/;"	f	struct:sobject_t
encode	object.h	/^inline void encode(snapid_t i, bufferlist &bl) { encode(i.val, bl); }$/;"	f
encode	types.h	/^  void encode(bufferlist &bl) const {$/;"	f	struct:errorcode32_t
encode	types.h	/^  void encode(bufferlist &bl) const {$/;"	f	struct:shard_id_t
encode	types.h	/^  void encode(bufferlist& bl) const {$/;"	f	struct:client_t
encode	util.h	/^  void encode(bufferlist &bl) const {$/;"	f	struct:ceph_data_stats
encode	utime.h	/^  void encode(bufferlist &bl) const {$/;"	f	class:utime_t
encode	uuid.h	/^  void encode(bufferlist& bl) const {$/;"	f	struct:uuid_d
encode_destructively	encoding.h	/^inline void encode_destructively(bufferlist& s, bufferlist& bl) $/;"	f
encode_helper_f	denc.h	/^  static void encode_helper_f(const T& s, buffer::list::contiguous_appender& p,$/;"	f	struct:denc_traits
encode_helper_nf	denc.h	/^  static void encode_helper_nf(const T& s, buffer::list::contiguous_appender& p,$/;"	f	struct:denc_traits
encode_nohead	btree_map.h	/^inline void encode_nohead(const btree::btree_map<T,U>& m, bufferlist& bl)$/;"	f
encode_nohead	denc.h	/^			       !traits::featured>::type encode_nohead($/;"	f
encode_nohead	denc.h	/^    encode_nohead(const container& s, buffer::list::contiguous_appender& p) {$/;"	f	struct:_denc::container_base
encode_nohead	denc.h	/^    encode_nohead(const container& s, buffer::list::contiguous_appender& p,$/;"	f	struct:_denc::container_base
encode_nohead	denc.h	/^  encode_nohead(const boost::optional<T>& v,$/;"	f	struct:denc_traits
encode_nohead	denc.h	/^  static void encode_nohead(const bufferlist& v,$/;"	f	struct:denc_traits
encode_nohead	denc.h	/^  static void encode_nohead(const value_type& s,$/;"	f	struct:denc_traits
encode_nohead	encoding.h	/^  encode_nohead(const boost::container::flat_map<T,U,Comp,Alloc>& m,$/;"	f
encode_nohead	encoding.h	/^  encode_nohead(const std::map<T,U,Comp,Alloc>& m, bufferlist& bl)$/;"	f
encode_nohead	encoding.h	/^  encode_nohead(const std::map<T,U,Comp,Alloc>& m, bufferlist& bl, uint64_t features)$/;"	f
encode_nohead	encoding.h	/^  encode_nohead(const std::set<T,Comp,Alloc>& s, bufferlist& bl)$/;"	f
encode_nohead	encoding.h	/^  encode_nohead(const std::vector<T,Alloc>& v, bufferlist& bl)$/;"	f
encode_nohead	encoding.h	/^encode_nohead(const boost::container::flat_set<T, Comp, Alloc>& s,$/;"	f
encode_nohead	encoding.h	/^inline void encode_nohead(boost::string_view s, bufferlist& bl)$/;"	f
encode_nohead	encoding.h	/^inline void encode_nohead(const bufferlist& s, bufferlist& bl) $/;"	f
encode_nohead	encoding.h	/^inline void encode_nohead(const std::string& s, bufferlist& bl)$/;"	f
encode_nohead	frag.h	/^  void encode_nohead(bufferlist& bl) const {$/;"	f	class:fragtree_t
encode_nohead	interval_set.h	/^  static void encode_nohead(const interval_set<T,Map>& v,$/;"	f	struct:denc_traits
encode_nohead	interval_set.h	/^  void encode_nohead(bufferlist::contiguous_appender& p) const {$/;"	f	class:interval_set
encode_raw	encoding.h	/^inline void encode_raw(const T& t, bufferlist& bl)$/;"	f
encode_timeval	utime.h	/^  void encode_timeval(struct ceph_timespec *t) const {$/;"	f	class:utime_t
encoded	filepath.h	/^  bool encoded;$/;"	m	class:filepath
end	buffer.h	/^      bool end() const {$/;"	f	class:ceph::CEPH_BUFFER_API::list::iterator_impl
end	buffer.h	/^      bool end() const {$/;"	f	class:ceph::CEPH_BUFFER_API::ptr::iterator
end	buffer.h	/^      char *pos, *end;$/;"	m	class:ceph::CEPH_BUFFER_API::list::page_aligned_appender
end	buffer.h	/^    const_iterator end() const {$/;"	f	class:ceph::CEPH_BUFFER_API::list
end	buffer.h	/^    iterator end() {$/;"	f	class:ceph::CEPH_BUFFER_API::list
end	buffer.h	/^    unsigned end() const { return _off + _len; }$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
end	compact_map.h	/^  const_iterator end() const {$/;"	f	class:compact_map_base
end	compact_map.h	/^  iterator end() {$/;"	f	class:compact_map_base
end	compact_set.h	/^  const_iterator end() const {$/;"	f	class:compact_set_base
end	compact_set.h	/^  iterator end() {$/;"	f	class:compact_set_base
end	cpp-btree/btree.h	/^  const_iterator end() const {$/;"	f	class:btree::btree
end	cpp-btree/btree.h	/^  iterator end() {$/;"	f	class:btree::btree
end	cpp-btree/btree_container.h	/^  const_iterator end() const { return tree_.end(); }$/;"	f	class:btree::btree_container
end	cpp-btree/btree_container.h	/^  iterator end() { return tree_.end(); }$/;"	f	class:btree::btree_container
end	elist.h	/^    bool end() const {$/;"	f	class:elist::iterator
end	frag.h	/^  std::set<frag_t>::iterator end() { return _set.end(); }$/;"	f	class:fragset_t
end	interval_set.h	/^  typename interval_set<T,Map>::const_iterator end() const {$/;"	f	class:interval_set
end	interval_set.h	/^  typename interval_set<T,Map>::iterator end() {$/;"	f	class:interval_set
end	rados/buffer.h	/^      bool end() const {$/;"	f	class:ceph::CEPH_BUFFER_API::list::iterator_impl
end	rados/buffer.h	/^      bool end() const {$/;"	f	class:ceph::CEPH_BUFFER_API::ptr::iterator
end	rados/buffer.h	/^      char *pos, *end;$/;"	m	class:ceph::CEPH_BUFFER_API::list::page_aligned_appender
end	rados/buffer.h	/^    const_iterator end() const {$/;"	f	class:ceph::CEPH_BUFFER_API::list
end	rados/buffer.h	/^    iterator end() {$/;"	f	class:ceph::CEPH_BUFFER_API::list
end	rados/buffer.h	/^    unsigned end() const { return _off + _len; }$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
end	rangeset.h	/^  iterator end() {$/;"	f	class:rangeset
end	xlist.h	/^    bool end() const { return cur == 0; }$/;"	f	class:xlist::const_iterator
end	xlist.h	/^    bool end() const { return cur == 0; }$/;"	f	class:xlist::iterator
end	xlist.h	/^  const_iterator end() const { return const_iterator(NULL); }$/;"	f	class:xlist
end	xlist.h	/^  iterator end() { return iterator(NULL); }$/;"	f	class:xlist
end_after	interval_set.h	/^  T end_after(T start) const {$/;"	f	class:interval_set
end_of_buffer	buffer.h	/^  struct end_of_buffer : public error {$/;"	s	namespace:ceph::CEPH_BUFFER_API
end_of_buffer	rados/buffer.h	/^  struct end_of_buffer : public error {$/;"	s	namespace:ceph::CEPH_BUFFER_API
end_ptr	buffer.h	/^      const char *end_ptr;   \/\/\/< pointer to bp->end_c_str()$/;"	m	class:ceph::CEPH_BUFFER_API::ptr::iterator
end_ptr	rados/buffer.h	/^      const char *end_ptr;   \/\/\/< pointer to bp->end_c_str()$/;"	m	class:ceph::CEPH_BUFFER_API::ptr::iterator
epoch	ceph_fs.h	/^	__le32 epoch;$/;"	m	struct:ceph_mon_poolop_reply
epoch	rados.h	/^	__le32 epoch;$/;"	m	struct:ceph_eversion
epoch_t	types.h	/^typedef __u32 epoch_t;       \/\/ map epoch  (32bits -> 13 epochs\/second for 10 years)$/;"	t
eqstr	types.h	/^struct eqstr$/;"	s
equal_range	cpp-btree/btree.h	/^  std::pair<const_iterator,const_iterator> equal_range(const key_type &key) const {$/;"	f	class:btree::btree
equal_range	cpp-btree/btree.h	/^  std::pair<iterator,iterator> equal_range(const key_type &key) {$/;"	f	class:btree::btree
equal_range	cpp-btree/btree_container.h	/^  std::pair<const_iterator,const_iterator> equal_range(const key_type &key) const {$/;"	f	class:btree::btree_container
equal_range	cpp-btree/btree_container.h	/^  std::pair<iterator,iterator> equal_range(const key_type &key) {$/;"	f	class:btree::btree_container
erase	compact_map.h	/^  iterator erase (iterator p) {$/;"	f	class:compact_map_base
erase	compact_map.h	/^  size_t erase (const Key& k) {$/;"	f	class:compact_map_base
erase	compact_set.h	/^  iterator erase (iterator p) {$/;"	f	class:compact_set_base
erase	compact_set.h	/^  size_t erase (const T& t) {$/;"	f	class:compact_set_base
erase	cpp-btree/btree_container.h	/^  int erase(const key_type &key) {$/;"	f	class:btree::btree_multi_container
erase	cpp-btree/btree_container.h	/^  int erase(const key_type &key) {$/;"	f	class:btree::btree_unique_container
erase	cpp-btree/btree_container.h	/^  iterator erase(const iterator &iter) {$/;"	f	class:btree::btree_multi_container
erase	cpp-btree/btree_container.h	/^  iterator erase(const iterator &iter) {$/;"	f	class:btree::btree_unique_container
erase	cpp-btree/btree_container.h	/^  void erase(const iterator &first, const iterator &last) {$/;"	f	class:btree::btree_multi_container
erase	cpp-btree/btree_container.h	/^  void erase(const iterator &first, const iterator &last) {$/;"	f	class:btree::btree_unique_container
erase	interval_set.h	/^  void erase(T start, T len, $/;"	f	class:interval_set
erase	interval_set.h	/^  void erase(T val) {$/;"	f	class:interval_set
erase	interval_set.h	/^  void erase(iterator &i) {$/;"	f	class:interval_set
erase	rangeset.h	/^  void erase(T val) {$/;"	f	class:rangeset
err_t	rados/rados_types.hpp	/^struct err_t {$/;"	s	namespace:librados
error	buffer.h	/^  struct error : public std::exception{$/;"	s	namespace:ceph::CEPH_BUFFER_API
error	rados/buffer.h	/^  struct error : public std::exception{$/;"	s	namespace:ceph::CEPH_BUFFER_API
error_code	buffer.h	/^  struct error_code : public malformed_input {$/;"	s	namespace:ceph::CEPH_BUFFER_API
error_code	rados/buffer.h	/^  struct error_code : public malformed_input {$/;"	s	namespace:ceph::CEPH_BUFFER_API
errorcode32_t	types.h	/^  errorcode32_t() : code(0) {}$/;"	f	struct:errorcode32_t
errorcode32_t	types.h	/^  errorcode32_t(int32_t i) : code(i) {}$/;"	f	struct:errorcode32_t
errorcode32_t	types.h	/^struct errorcode32_t {$/;"	s
errors	rados/rados_types.hpp	/^  uint64_t errors = 0;$/;"	m	namespace:librados
errors	rados/rados_types.hpp	/^  uint64_t errors = 0;$/;"	m	struct:inconsistent_snapset_t
errors	rados/rados_types.hpp	/^  uint64_t errors = 0;$/;"	m	struct:librados::err_t
expected_object_size	rados.h	/^			__le64 expected_object_size;$/;"	m	struct:ceph_osd_op::__anon13::__anon27
expected_write_size	rados.h	/^			__le64 expected_write_size;$/;"	m	struct:ceph_osd_op::__anon13::__anon27
extent	rados.h	/^		} __attribute__ ((packed)) extent;$/;"	m	union:ceph_osd_op::__anon13	typeref:struct:ceph_osd_op::__anon13::__anon14
extra_clones	rados/rados_types.hpp	/^  bool extra_clones() const {$/;"	f	struct:inconsistent_snapset_t
f	Context.h	/^  F f;$/;"	m	struct:LambdaGenContext
f	scope_guard.h	/^  F f;$/;"	m	struct:scope_guard
f_bavail	rados/rgw_file.h	/^    uint64_t     f_bavail;   \/* # free blocks for unprivileged users *\/$/;"	m	struct:rgw_statvfs
f_bfree	rados/rgw_file.h	/^    uint64_t     f_bfree;    \/* # free blocks *\/$/;"	m	struct:rgw_statvfs
f_blocks	rados/rgw_file.h	/^    uint64_t     f_blocks;   \/* size of fs in f_frsize units *\/$/;"	m	struct:rgw_statvfs
f_bsize	rados/rgw_file.h	/^    uint64_t  f_bsize;    \/* file system block size *\/$/;"	m	struct:rgw_statvfs
f_favail	rados/rgw_file.h	/^    uint64_t     f_favail;   \/* # free inodes for unprivileged users *\/$/;"	m	struct:rgw_statvfs
f_ffree	rados/rgw_file.h	/^    uint64_t     f_ffree;    \/* # free inodes *\/$/;"	m	struct:rgw_statvfs
f_files	rados/rgw_file.h	/^    uint64_t     f_files;    \/* # inodes *\/$/;"	m	struct:rgw_statvfs
f_flag	rados/rgw_file.h	/^    uint64_t     f_flag;     \/* mount flags *\/$/;"	m	struct:rgw_statvfs
f_frsize	rados/rgw_file.h	/^    uint64_t  f_frsize;   \/* fragment size *\/$/;"	m	struct:rgw_statvfs
f_fsid	rados/rgw_file.h	/^    uint64_t     f_fsid[2];     \/* file system ID *\/$/;"	m	struct:rgw_statvfs
f_namemax	rados/rgw_file.h	/^    uint64_t     f_namemax;  \/* maximum filename length *\/$/;"	m	struct:rgw_statvfs
fe_flags	linux_fiemap.h	/^	__u32 fe_flags;    \/* FIEMAP_EXTENT_* flags for this extent *\/$/;"	m	struct:fiemap_extent
fe_length	linux_fiemap.h	/^	__u64 fe_length;   \/* length in bytes for this extent *\/$/;"	m	struct:fiemap_extent
fe_logical	linux_fiemap.h	/^	__u64 fe_logical;  \/* logical offset in bytes for the start of$/;"	m	struct:fiemap_extent
fe_physical	linux_fiemap.h	/^	__u64 fe_physical; \/* physical offset in bytes for the start$/;"	m	struct:fiemap_extent
fe_reserved	linux_fiemap.h	/^	__u32 fe_reserved[3];$/;"	m	struct:fiemap_extent
fe_reserved64	linux_fiemap.h	/^	__u64 fe_reserved64[2];$/;"	m	struct:fiemap_extent
featured	denc.h	/^    static constexpr bool featured = (denc_traits<T>::featured ||$/;"	m	struct:_denc::tuple_traits
featured	denc.h	/^    static constexpr bool featured = false;$/;"	m	struct:_denc::tuple_traits
featured	denc.h	/^    static constexpr bool featured = traits::featured;$/;"	m	struct:_denc::container_base
featured	denc.h	/^  static constexpr bool featured = a_traits::featured || b_traits::featured ;$/;"	m	struct:denc_traits
featured	denc.h	/^  static constexpr bool featured = false;$/;"	m	struct:denc_traits
featured	denc.h	/^  static constexpr bool featured = traits::featured;$/;"	m	struct:denc_traits
featured	fs_types.h	/^  static constexpr bool featured = false;$/;"	m	struct:denc_traits
featured	health.h	/^  static constexpr bool featured = false;$/;"	m	struct:denc_traits
featured	interval_set.h	/^  static constexpr bool featured = false;$/;"	m	struct:denc_traits
featured	object.h	/^  static constexpr bool featured = false;$/;"	m	struct:denc_traits
features	msgr.h	/^	__le64 features;     \/* feature bits for this session *\/$/;"	m	struct:ceph_msg_connect_reply
features	msgr.h	/^	__le64 features;     \/* supported feature bits *\/$/;"	m	struct:ceph_msg_connect
fh_hk	rados/rgw_file.h	/^  struct rgw_fh_hk fh_hk;$/;"	m	struct:rgw_file_handle	typeref:struct:rgw_file_handle::rgw_fh_hk
fh_private	rados/rgw_file.h	/^  void *fh_private; \/* librgw private data *\/$/;"	m	struct:rgw_file_handle
fh_type	rados/rgw_file.h	/^  enum rgw_fh_type fh_type;$/;"	m	struct:rgw_file_handle	typeref:enum:rgw_file_handle::rgw_fh_type
field_type	cpp-btree/btree.h	/^    typedef typename Params::node_count_type field_type;$/;"	t	struct:btree::btree_node::base_fields
fields_	cpp-btree/btree.h	/^  root_fields fields_;$/;"	m	class:btree::btree_node
fiemap	linux_fiemap.h	/^struct fiemap {$/;"	s
fiemap_extent	linux_fiemap.h	/^struct fiemap_extent {$/;"	s
file_layout_t	fs_types.h	/^  file_layout_t(uint32_t su=0, uint32_t sc=0, uint32_t os=0)$/;"	f	struct:file_layout_t
file_layout_t	fs_types.h	/^struct file_layout_t {$/;"	s
file_mode_is_readonly	fs_types.h	/^static inline bool file_mode_is_readonly(int mode) {$/;"	f
file_object_t	object.h	/^  file_object_t(uint64_t i=0, uint64_t b=0) : ino(i), bno(b) {$/;"	f	struct:file_object_t
file_object_t	object.h	/^struct file_object_t {$/;"	s
filelock_change	ceph_fs.h	/^	} __attribute__ ((packed)) filelock_change;$/;"	m	union:ceph_mds_request_args	typeref:struct:ceph_mds_request_args::__anon64
filelock_change	ceph_fs.h	/^	} __attribute__ ((packed)) filelock_change;$/;"	m	union:ceph_mds_request_args_legacy	typeref:struct:ceph_mds_request_args_legacy::__anon55
filepath	filepath.h	/^  filepath() : ino(0), encoded(false) { }$/;"	f	class:filepath
filepath	filepath.h	/^  filepath(boost::string_view s) : encoded(false) {$/;"	f	class:filepath
filepath	filepath.h	/^  filepath(boost::string_view s, inodeno_t i) : ino(i), path(s), encoded(false) { }$/;"	f	class:filepath
filepath	filepath.h	/^  filepath(const char *s) : encoded(false) {$/;"	f	class:filepath
filepath	filepath.h	/^  filepath(const char* s, inodeno_t i) : ino(i), path(s), encoded(false) { }$/;"	f	class:filepath
filepath	filepath.h	/^  filepath(const filepath& o) {$/;"	f	class:filepath
filepath	filepath.h	/^  filepath(const string& s, inodeno_t i) : ino(i), path(s), encoded(false) { }$/;"	f	class:filepath
filepath	filepath.h	/^  filepath(inodeno_t i) : ino(i), encoded(false) { }$/;"	f	class:filepath
filepath	filepath.h	/^class filepath {$/;"	c
fin	Context.h	/^  Context *fin;$/;"	m	struct:C_Lock
find	compact_map.h	/^  const_iterator find(const Key& k) const {$/;"	f	class:compact_map_base
find	compact_map.h	/^  iterator find(const Key& k) {$/;"	f	class:compact_map_base
find	compact_set.h	/^  const_iterator find(const T& t) const {$/;"	f	class:compact_set_base
find	compact_set.h	/^  iterator find(const T& t) {$/;"	f	class:compact_set_base
find	cpp-btree/btree_container.h	/^  const_iterator find(const key_type &key) const {$/;"	f	class:btree::btree_multi_container
find	cpp-btree/btree_container.h	/^  const_iterator find(const key_type &key) const {$/;"	f	class:btree::btree_unique_container
find	cpp-btree/btree_container.h	/^  iterator find(const key_type &key) {$/;"	f	class:btree::btree_multi_container
find	cpp-btree/btree_container.h	/^  iterator find(const key_type &key) {$/;"	f	class:btree::btree_unique_container
find_adj	interval_set.h	/^  typename Map::const_iterator find_adj(T start) const {$/;"	f	class:interval_set
find_adj_m	interval_set.h	/^  typename Map::iterator find_adj_m(T start) {$/;"	f	class:interval_set
find_inc	interval_set.h	/^  typename Map::const_iterator find_inc(T start) const {$/;"	f	class:interval_set
find_inc_m	interval_set.h	/^  typename Map::iterator find_inc_m(T start) {$/;"	f	class:interval_set
find_multi	cpp-btree/btree.h	/^  const_iterator find_multi(const key_type &key) const {$/;"	f	class:btree::btree
find_multi	cpp-btree/btree.h	/^  iterator find_multi(const key_type &key) {$/;"	f	class:btree::btree
find_unique	cpp-btree/btree.h	/^  const_iterator find_unique(const key_type &key) const {$/;"	f	class:btree::btree
find_unique	cpp-btree/btree.h	/^  iterator find_unique(const key_type &key) {$/;"	f	class:btree::btree
finish_contexts	Context.h	/^inline void finish_contexts(CephContext *cct, std::list<A*>& finished, $/;"	f
finish_contexts	Context.h	/^inline void finish_contexts(CephContext *cct, std::vector<Context*>& finished, $/;"	f
finisher	Context.h	/^  ContextType *finisher;$/;"	m	class:C_GatherBuilderBase
first	ceph_fs.h	/^	__le64 first, last;     \/* snap range *\/$/;"	m	struct:ceph_mds_lease
first	rangeset.h	/^  T first() {$/;"	f	class:rangeset
fl_cas_hash	ceph_fs.h	/^	__le32 fl_cas_hash;        \/* UNUSED.  0 = none; 1 = sha256 *\/$/;"	m	struct:ceph_file_layout
fl_cas_hash	cephfs/libcephfs.h	/^	uint32_t fl_cas_hash;        \/* 0 = none; 1 = sha256 *\/$/;"	m	struct:ceph_file_layout
fl_object_size	ceph_fs.h	/^	__le32 fl_object_size;     \/* until objects are this big, then move to$/;"	m	struct:ceph_file_layout
fl_object_size	cephfs/libcephfs.h	/^	uint32_t fl_object_size;     \/* until objects are this big, then move to$/;"	m	struct:ceph_file_layout
fl_object_stripe_unit	ceph_fs.h	/^	__le32 fl_object_stripe_unit;  \/* UNUSED.  for per-object parity, if any *\/$/;"	m	struct:ceph_file_layout
fl_object_stripe_unit	cephfs/libcephfs.h	/^	uint32_t fl_object_stripe_unit;  \/* for per-object parity, if any *\/$/;"	m	struct:ceph_file_layout
fl_pg_pool	ceph_fs.h	/^	__le32 fl_pg_pool;      \/* namespace, crush ruleset, rep level *\/$/;"	m	struct:ceph_file_layout
fl_pg_pool	cephfs/libcephfs.h	/^	uint32_t fl_pg_pool;      \/* namespace, crush ruleset, rep level *\/$/;"	m	struct:ceph_file_layout
fl_pg_preferred	cephfs/libcephfs.h	/^	uint32_t fl_pg_preferred; \/* preferred primary for pg (-1 for none) *\/$/;"	m	struct:ceph_file_layout
fl_stripe_count	ceph_fs.h	/^	__le32 fl_stripe_count;    \/* over this many objects *\/$/;"	m	struct:ceph_file_layout
fl_stripe_count	cephfs/libcephfs.h	/^	uint32_t fl_stripe_count;    \/* over this many objects *\/$/;"	m	struct:ceph_file_layout
fl_stripe_unit	ceph_fs.h	/^	__le32 fl_stripe_unit;     \/* stripe unit, in bytes.  must be multiple$/;"	m	struct:ceph_file_layout
fl_stripe_unit	cephfs/libcephfs.h	/^	uint32_t fl_stripe_unit;     \/* stripe unit, in bytes.  must be multiple$/;"	m	struct:ceph_file_layout
fl_unused	ceph_fs.h	/^	__le32 fl_unused;       \/* unused; used to be preferred primary for pg (-1 for none) *\/$/;"	m	struct:ceph_file_layout
flags	ceph_fs.h	/^		__le16 flags;$/;"	m	struct:ceph_mds_request_args::__anon58
flags	ceph_fs.h	/^		__le16 flags;$/;"	m	struct:ceph_mds_request_args_legacy::__anon49
flags	ceph_fs.h	/^		__le32 flags;$/;"	m	struct:ceph_mds_request_args::__anon61
flags	ceph_fs.h	/^		__le32 flags;$/;"	m	struct:ceph_mds_request_args::__anon62
flags	ceph_fs.h	/^		__le32 flags;$/;"	m	struct:ceph_mds_request_args_legacy::__anon52
flags	ceph_fs.h	/^		__le32 flags;$/;"	m	struct:ceph_mds_request_args_legacy::__anon53
flags	ceph_fs.h	/^	__le32 flags;                  \/* CEPH_MDS_FLAG_* *\/$/;"	m	struct:ceph_mds_request_head
flags	ceph_fs.h	/^	__le32 flags;                  \/* CEPH_MDS_FLAG_* *\/$/;"	m	struct:ceph_mds_request_head_legacy
flags	ceph_fs.h	/^	__u8   flags;$/;"	m	struct:ceph_mds_cap_peer
flags	ceph_fs.h	/^	__u8 flags;                    \/* CEPH_CAP_FLAG_* *\/$/;"	m	struct:ceph_mds_reply_cap
flags	ceph_fs.h	/^	__u8 flags;$/;"	m	struct:ceph_mon_subscribe_item
flags	msgr.h	/^	__u8  flags;         \/* CEPH_MSG_CONNECT_* *\/$/;"	m	struct:ceph_msg_connect
flags	msgr.h	/^	__u8 flags;$/;"	m	struct:ceph_msg_connect_reply
flags	msgr.h	/^	__u8 flags;$/;"	m	struct:ceph_msg_footer
flags	msgr.h	/^	__u8 flags;$/;"	m	struct:ceph_msg_footer_old
flags	rados.h	/^			__le32 flags;  \/* CEPH_OSD_OP_ALLOC_HINT_FLAG_* *\/$/;"	m	struct:ceph_osd_op::__anon13::__anon27
flags	rados.h	/^			__u8 flags;$/;"	m	struct:ceph_osd_op::__anon13::__anon24
flags	rados.h	/^			__u8 flags;$/;"	m	struct:ceph_osd_op::__anon13::__anon26
flags	rados.h	/^	__le32 flags;        \/* CEPH_OSD_OP_FLAG_* *\/$/;"	m	struct:ceph_osd_op
flags	rados.h	/^	__le32 flags;$/;"	m	struct:ceph_osd_reply_head
flock_len	ceph_fs.h	/^	__le32 flock_len;       \/* size of flock state blob, if any *\/$/;"	m	struct:ceph_mds_cap_reconnect
flush	buffer.h	/^      void flush() {$/;"	f	class:ceph::CEPH_BUFFER_API::list::page_aligned_appender
flush	rados/buffer.h	/^      void flush() {$/;"	f	class:ceph::CEPH_BUFFER_API::list::page_aligned_appender
flush_and_continue	buffer.h	/^      void flush_and_continue() {$/;"	f	class:ceph::CEPH_BUFFER_API::list::contiguous_appender
flush_and_continue	rados/buffer.h	/^      void flush_and_continue() {$/;"	f	class:ceph::CEPH_BUFFER_API::list::contiguous_appender
fm_extent_count	linux_fiemap.h	/^	__u32 fm_extent_count;  \/* size of fm_extents array (in) *\/$/;"	m	struct:fiemap
fm_extents	linux_fiemap.h	/^	struct fiemap_extent fm_extents[0]; \/* array of mapped extents (out) *\/$/;"	m	struct:fiemap	typeref:struct:fiemap::fiemap_extent
fm_flags	linux_fiemap.h	/^	__u32 fm_flags;		\/* FIEMAP_FLAG_* flags for request (in\/out) *\/$/;"	m	struct:fiemap
fm_length	linux_fiemap.h	/^	__u64 fm_length;	\/* logical length of mapping which$/;"	m	struct:fiemap
fm_mapped_extents	linux_fiemap.h	/^	__u32 fm_mapped_extents;\/* number of extents that were mapped (out) *\/$/;"	m	struct:fiemap
fm_reserved	linux_fiemap.h	/^	__u32 fm_reserved;$/;"	m	struct:fiemap
fm_start	linux_fiemap.h	/^	__u64 fm_start;		\/* logical offset (inclusive) at$/;"	m	struct:fiemap
force_to_leaf	frag.h	/^  bool force_to_leaf(CephContext *cct, frag_t x) {$/;"	f	class:fragtree_t
format_u	types.h	/^  inline ostream& format_u(ostream& out, const uint64_t v, const uint64_t n,$/;"	f	namespace:__anon30
frag	ceph_fs.h	/^		__le32 frag;                 \/* which dir fragment *\/$/;"	m	struct:ceph_mds_request_args::__anon58
frag	ceph_fs.h	/^		__le32 frag;                 \/* which dir fragment *\/$/;"	m	struct:ceph_mds_request_args_legacy::__anon49
frag	ceph_fs.h	/^	__le32 frag;                   \/* this frag splits... *\/$/;"	m	struct:ceph_frag_tree_split
frag	ceph_fs.h	/^	__le32 frag;            \/* fragment *\/$/;"	m	struct:ceph_mds_reply_dirfrag
frag_t	frag.h	/^  frag_t() : _enc(0) { }$/;"	f	class:frag_t
frag_t	frag.h	/^  frag_t(_frag_t e) : _enc(e) { }$/;"	f	class:frag_t
frag_t	frag.h	/^  frag_t(unsigned v, unsigned b) : _enc(ceph_frag_make(b, v)) { }$/;"	f	class:frag_t
frag_t	frag.h	/^class frag_t {$/;"	c
fragset_t	frag.h	/^class fragset_t {$/;"	c
fragtree_t	frag.h	/^class fragtree_t {$/;"	c
free_internal	compact_map.h	/^  void free_internal() {$/;"	f	class:compact_map_base
free_internal	compact_set.h	/^  void free_internal() {$/;"	f	class:compact_set_base
from_unsigned	frag.h	/^  void from_unsigned(unsigned e) { _enc = e; }$/;"	f	class:frag_t
front	buffer.h	/^    const ptr& front() const { return _buffers.front(); }$/;"	f	class:ceph::CEPH_BUFFER_API::list
front	elist.h	/^  T front(size_t o=0) {$/;"	f	class:elist
front	rados/buffer.h	/^    const ptr& front() const { return _buffers.front(); }$/;"	f	class:ceph::CEPH_BUFFER_API::list
front	xlist.h	/^  T front() { return static_cast<T>(_front->_item); }$/;"	f	class:xlist
front	xlist.h	/^  const T front() const { return static_cast<const T>(_front->_item); }$/;"	f	class:xlist
front_crc	msgr.h	/^	__le32 front_crc, middle_crc, data_crc;$/;"	m	struct:ceph_msg_footer
front_crc	msgr.h	/^	__le32 front_crc, middle_crc, data_crc;$/;"	m	struct:ceph_msg_footer_old
front_len	msgr.h	/^	__le32 front_len; \/* bytes in main payload *\/$/;"	m	struct:ceph_msg_header
front_len	msgr.h	/^	__le32 front_len; \/* bytes in main payload *\/$/;"	m	struct:ceph_msg_header_old
fs_private	rados/rgw_file.h	/^  void *fs_private;$/;"	m	struct:rgw_fs
fsid	ceph_fs.h	/^	struct ceph_fsid fsid;$/;"	m	struct:ceph_mds_getmap	typeref:struct:ceph_mds_getmap::ceph_fsid
fsid	ceph_fs.h	/^	struct ceph_fsid fsid;$/;"	m	struct:ceph_mon_poolop	typeref:struct:ceph_mon_poolop::ceph_fsid
fsid	ceph_fs.h	/^	struct ceph_fsid fsid;$/;"	m	struct:ceph_mon_poolop_reply	typeref:struct:ceph_mon_poolop_reply::ceph_fsid
fsid	ceph_fs.h	/^	struct ceph_fsid fsid;$/;"	m	struct:ceph_mon_statfs	typeref:struct:ceph_mon_statfs::ceph_fsid
fsid	ceph_fs.h	/^	struct ceph_fsid fsid;$/;"	m	struct:ceph_mon_statfs_reply	typeref:struct:ceph_mon_statfs_reply::ceph_fsid
fsid	ceph_fs.h	/^	struct ceph_fsid fsid;$/;"	m	struct:ceph_mon_subscribe_ack	typeref:struct:ceph_mon_subscribe_ack::ceph_fsid
fsid	ceph_fs.h	/^	struct ceph_fsid fsid;$/;"	m	struct:ceph_osd_getmap	typeref:struct:ceph_osd_getmap::ceph_fsid
fsid	rados.h	/^	unsigned char fsid[16];$/;"	m	struct:ceph_fsid
fullness	cpp-btree/btree.h	/^  double fullness() const {$/;"	f	class:btree::btree
fullness	cpp-btree/btree_container.h	/^  double fullness() const { return tree_.fullness(); }$/;"	f	class:btree::btree_container
func	on_exit.h	/^      callback_t func;$/;"	m	struct:OnExitManager::cb
funcs_	on_exit.h	/^    std::vector<struct cb> funcs_;$/;"	m	class:OnExitManager
gather	Context.h	/^    C_GatherBase *gather;$/;"	m	class:C_GatherBase::C_GatherSub
gen	rados.h	/^			__u32 gen;      \/* registration generation *\/$/;"	m	struct:ceph_osd_op::__anon13::__anon19
generate_random	uuid.h	/^  void generate_random() {$/;"	f	struct:uuid_d
generate_test_instances	CompatSet.h	/^  static void generate_test_instances(list<CompatSet*>& o) {$/;"	f	struct:CompatSet
generate_test_instances	filepath.h	/^  static void generate_test_instances(list<filepath*>& o) {$/;"	f	class:filepath
generate_test_instances	util.h	/^  static void generate_test_instances(list<ceph_data_stats*>& ls) {$/;"	f	struct:ceph_data_stats
generate_value	cpp-btree/btree_container.h	/^    generate_value(const key_type &k)$/;"	f	struct:btree::btree_map_container::generate_value
generate_value	cpp-btree/btree_container.h	/^  struct generate_value {$/;"	s	class:btree::btree_map_container
get	Context.h	/^  GatherType *get() const {$/;"	f	class:C_GatherBuilderBase
get	alloc_ptr.h	/^    element_type* get() const {$/;"	f	class:alloc_ptr
get	bitmapper.h	/^  bool get(int b) const {$/;"	f	class:bitmapper
get	frag.h	/^  const std::set<frag_t> &get() const { return _set; }$/;"	f	class:fragset_t
get_append_buffer_unused_tail_length	buffer.h	/^    size_t get_append_buffer_unused_tail_length() const {$/;"	f	class:ceph::CEPH_BUFFER_API::list
get_append_buffer_unused_tail_length	rados/buffer.h	/^    size_t get_append_buffer_unused_tail_length() const {$/;"	f	class:ceph::CEPH_BUFFER_API::list
get_bl	buffer.h	/^      bl_t& get_bl() const { return *bl; }$/;"	f	class:ceph::CEPH_BUFFER_API::list::iterator_impl
get_bl	rados/buffer.h	/^      bl_t& get_bl() const { return *bl; }$/;"	f	class:ceph::CEPH_BUFFER_API::list::iterator_impl
get_branch	frag.h	/^  frag_t get_branch(frag_t x) const {$/;"	f	class:fragtree_t
get_branch_above	frag.h	/^  frag_t get_branch_above(frag_t x) const {$/;"	f	class:fragtree_t
get_branch_or_leaf	frag.h	/^  frag_t get_branch_or_leaf(frag_t x) const {$/;"	f	class:fragtree_t
get_contiguous_appender	buffer.h	/^    contiguous_appender get_contiguous_appender(size_t len, bool deep=false) {$/;"	f	class:ceph::CEPH_BUFFER_API::list
get_contiguous_appender	rados/buffer.h	/^    contiguous_appender get_contiguous_appender(size_t len, bool deep=false) {$/;"	f	class:ceph::CEPH_BUFFER_API::list
get_default	fs_types.h	/^  static file_layout_t get_default() {$/;"	f	struct:file_layout_t
get_end	buffer.h	/^      const char *get_end() {$/;"	f	class:ceph::CEPH_BUFFER_API::ptr::iterator
get_end	rados/buffer.h	/^      const char *get_end() {$/;"	f	class:ceph::CEPH_BUFFER_API::ptr::iterator
get_ino	filepath.h	/^  inodeno_t get_ino() const { return ino; }$/;"	f	class:filepath
get_item	elist.h	/^    T get_item(size_t offset) {$/;"	f	struct:elist::item
get_leaves	frag.h	/^  void get_leaves(std::list<frag_t>& ls) const {$/;"	f	class:fragtree_t
get_leaves_under	frag.h	/^  void get_leaves_under(frag_t x, std::list<frag_t>& ls) const {$/;"	f	class:fragtree_t
get_leaves_under_split	frag.h	/^  void get_leaves_under_split(frag_t under, std::list<frag_t>& ls) const {$/;"	f	class:fragtree_t
get_len	interval_set.h	/^        T get_len() const {$/;"	f	class:interval_set::const_iterator
get_len	interval_set.h	/^        T get_len() const {$/;"	f	class:interval_set::iterator
get_list	xlist.h	/^    xlist* get_list() { return _list; }$/;"	f	struct:xlist::item
get_logical_offset	buffer.h	/^      size_t get_logical_offset() {$/;"	f	class:ceph::CEPH_BUFFER_API::list::contiguous_appender
get_logical_offset	rados/buffer.h	/^      size_t get_logical_offset() {$/;"	f	class:ceph::CEPH_BUFFER_API::list::contiguous_appender
get_memcopy_count	buffer.h	/^    unsigned get_memcopy_count() const {return _memcopy_count; }$/;"	f	class:ceph::CEPH_BUFFER_API::list
get_memcopy_count	rados/buffer.h	/^    unsigned get_memcopy_count() const {return _memcopy_count; }$/;"	f	class:ceph::CEPH_BUFFER_API::list
get_name	CompatSet.h	/^    std::string get_name(uint64_t const f) const {$/;"	f	class:CompatSet::FeatureSet
get_num_buffers	buffer.h	/^    unsigned get_num_buffers() const { return _buffers.size(); }$/;"	f	class:ceph::CEPH_BUFFER_API::list
get_num_buffers	rados/buffer.h	/^    unsigned get_num_buffers() const { return _buffers.size(); }$/;"	f	class:ceph::CEPH_BUFFER_API::list
get_off	buffer.h	/^      unsigned get_off() const { return off; }$/;"	f	class:ceph::CEPH_BUFFER_API::list::iterator_impl
get_off	rados/buffer.h	/^      unsigned get_off() const { return off; }$/;"	f	class:ceph::CEPH_BUFFER_API::list::iterator_impl
get_offset	buffer.h	/^      size_t get_offset() {$/;"	f	class:ceph::CEPH_BUFFER_API::ptr::iterator
get_offset	rados/buffer.h	/^      size_t get_offset() {$/;"	f	class:ceph::CEPH_BUFFER_API::ptr::iterator
get_out_of_band_offset	buffer.h	/^      size_t get_out_of_band_offset() const {$/;"	f	class:ceph::CEPH_BUFFER_API::list::contiguous_appender
get_out_of_band_offset	rados/buffer.h	/^      size_t get_out_of_band_offset() const {$/;"	f	class:ceph::CEPH_BUFFER_API::list::contiguous_appender
get_page_aligned_appender	buffer.h	/^    page_aligned_appender get_page_aligned_appender(unsigned min_pages=1) {$/;"	f	class:ceph::CEPH_BUFFER_API::list
get_page_aligned_appender	rados/buffer.h	/^    page_aligned_appender get_page_aligned_appender(unsigned min_pages=1) {$/;"	f	class:ceph::CEPH_BUFFER_API::list
get_path	filepath.h	/^  const string& get_path() const { return path; }$/;"	f	class:filepath
get_period	fs_types.h	/^  uint64_t get_period() const {$/;"	f	struct:file_layout_t
get_pos	buffer.h	/^      char *get_pos() {$/;"	f	class:ceph::CEPH_BUFFER_API::list::contiguous_appender
get_pos	buffer.h	/^      const char *get_pos() {$/;"	f	class:ceph::CEPH_BUFFER_API::ptr::iterator
get_pos	rados/buffer.h	/^      char *get_pos() {$/;"	f	class:ceph::CEPH_BUFFER_API::list::contiguous_appender
get_pos	rados/buffer.h	/^      const char *get_pos() {$/;"	f	class:ceph::CEPH_BUFFER_API::ptr::iterator
get_pos_add	buffer.h	/^      char *get_pos_add(size_t len) {$/;"	f	class:ceph::CEPH_BUFFER_API::list::contiguous_appender
get_pos_add	buffer.h	/^      const char *get_pos_add(size_t n) {$/;"	f	class:ceph::CEPH_BUFFER_API::ptr::iterator
get_pos_add	rados/buffer.h	/^      char *get_pos_add(size_t len) {$/;"	f	class:ceph::CEPH_BUFFER_API::list::contiguous_appender
get_pos_add	rados/buffer.h	/^      const char *get_pos_add(size_t n) {$/;"	f	class:ceph::CEPH_BUFFER_API::ptr::iterator
get_preceding_ptr	buffer.h	/^      ptr get_preceding_ptr(size_t len) {$/;"	f	class:ceph::CEPH_BUFFER_API::ptr::iterator
get_preceding_ptr	rados/buffer.h	/^      ptr get_preceding_ptr(size_t len) {$/;"	f	class:ceph::CEPH_BUFFER_API::ptr::iterator
get_ptr	buffer.h	/^      ptr get_ptr(size_t len) {$/;"	f	class:ceph::CEPH_BUFFER_API::ptr::iterator
get_ptr	rados/buffer.h	/^      ptr get_ptr(size_t len) {$/;"	f	class:ceph::CEPH_BUFFER_API::ptr::iterator
get_range_for	rangeset.h	/^  mapit get_range_for(T val) {$/;"	f	struct:_rangeset_base
get_raw	buffer.h	/^    raw *get_raw() const { return _raw; }$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
get_raw	rados/buffer.h	/^    raw *get_raw() const { return _raw; }$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
get_remaining	buffer.h	/^      unsigned get_remaining() const { return bl->length() - off; }$/;"	f	class:ceph::CEPH_BUFFER_API::list::iterator_impl
get_remaining	rados/buffer.h	/^      unsigned get_remaining() const { return bl->length() - off; }$/;"	f	class:ceph::CEPH_BUFFER_API::list::iterator_impl
get_sibling	frag.h	/^  frag_t get_sibling() const {$/;"	f	class:frag_t
get_split	frag.h	/^  int get_split(const frag_t hb) const {$/;"	f	class:fragtree_t
get_start	interval_set.h	/^        T get_start() const {$/;"	f	class:interval_set::const_iterator
get_start	interval_set.h	/^        T get_start() const {$/;"	f	class:interval_set::iterator
get_str_vec	str_list.h	/^static inline std::vector<std::string> get_str_vec(const std::string& str)$/;"	f
get_sub_created_count	Context.h	/^  inline int get_sub_created_count() const {$/;"	f	class:C_GatherBase
get_sub_existing_count	Context.h	/^  inline int get_sub_existing_count() const {$/;"	f	class:C_GatherBase
get_type	mempool.h	/^  type_t *get_type(const std::type_info& ti, size_t size) {$/;"	f	class:mempool::pool_t
get_width	Distribution.h	/^  unsigned get_width() {$/;"	f	class:Distribution
getattr	ceph_fs.h	/^	} __attribute__ ((packed)) getattr;$/;"	m	union:ceph_mds_request_args	typeref:struct:ceph_mds_request_args::__anon56
getattr	ceph_fs.h	/^	} __attribute__ ((packed)) getattr;$/;"	m	union:ceph_mds_request_args_legacy	typeref:struct:ceph_mds_request_args_legacy::__anon47
gid	ceph_fs.h	/^		__le32 gid;$/;"	m	struct:ceph_mds_request_args::__anon57
gid	ceph_fs.h	/^		__le32 gid;$/;"	m	struct:ceph_mds_request_args_legacy::__anon48
gid	ceph_fs.h	/^	__le32 uid, gid, mode;$/;"	m	struct:ceph_mds_caps_head
global_id	rbd/librbd.h	/^  char *global_id;$/;"	m	struct:__anon81
global_id	rbd/librbd.hpp	/^    std::string global_id;$/;"	m	struct:librbd::__anon72
global_seq	msgr.h	/^	__le32 global_seq;   \/* count connections initiated by this host *\/$/;"	m	struct:ceph_msg_connect
global_seq	msgr.h	/^	__le32 global_seq;$/;"	m	struct:ceph_msg_connect_reply
gmtime	utime.h	/^  ostream& gmtime(ostream& out) const {$/;"	f	class:utime_t
gmtime_nsec	utime.h	/^  ostream& gmtime_nsec(ostream& out) const {$/;"	f	class:utime_t
has_attr_name_mismatch	rados/rados_types.hpp	/^  bool has_attr_name_mismatch() const {$/;"	f	namespace:librados
has_attr_value_mismatch	rados/rados_types.hpp	/^  bool has_attr_value_mismatch() const {$/;"	f	namespace:librados
has_data	ceph_fs.h	/^	char has_data;$/;"	m	struct:ceph_mon_poolop_reply
has_data_digest_mismatch	rados/rados_types.hpp	/^  bool has_data_digest_mismatch() const {$/;"	f	namespace:librados
has_data_digest_mismatch_info	rados/rados_types.hpp	/^  bool has_data_digest_mismatch_info() const {$/;"	f	struct:librados::err_t
has_data_digest_mismatch_oi	rados/rados_types.hpp	/^  bool has_data_digest_mismatch_oi() const {   \/\/ Compatibility$/;"	f	struct:librados::err_t
has_deep_errors	rados/rados_types.hpp	/^  bool has_deep_errors() const {$/;"	f	namespace:librados
has_deep_errors	rados/rados_types.hpp	/^  bool has_deep_errors() const {$/;"	f	struct:librados::err_t
has_ec_hash_error	rados/rados_types.hpp	/^  bool has_ec_hash_error() const {$/;"	f	struct:librados::err_t
has_ec_size_error	rados/rados_types.hpp	/^  bool has_ec_size_error() const {$/;"	f	struct:librados::err_t
has_hinfo_corrupted	rados/rados_types.hpp	/^  bool has_hinfo_corrupted() const {$/;"	f	struct:librados::err_t
has_hinfo_inconsistency	rados/rados_types.hpp	/^  bool has_hinfo_inconsistency() const {$/;"	f	namespace:librados
has_hinfo_missing	rados/rados_types.hpp	/^  bool has_hinfo_missing() const {$/;"	f	struct:librados::err_t
has_info_corrupted	rados/rados_types.hpp	/^  bool has_info_corrupted() const {$/;"	f	struct:librados::err_t
has_info_missing	rados/rados_types.hpp	/^  bool has_info_missing() const {$/;"	f	struct:librados::err_t
has_legacy_denc	denc.h	/^  struct has_legacy_denc : std::false_type$/;"	s	namespace:_denc
has_legacy_denc	denc.h	/^  struct has_legacy_denc<T,$/;"	s	namespace:_denc
has_obj_size_info_mismatch	rados/rados_types.hpp	/^  bool has_obj_size_info_mismatch() const {$/;"	f	struct:librados::err_t
has_obj_size_oi_mismatch	rados/rados_types.hpp	/^  bool has_obj_size_oi_mismatch() const {   \/\/ Compatibility$/;"	f	struct:librados::err_t
has_object_info_inconsistency	rados/rados_types.hpp	/^  bool has_object_info_inconsistency() const {$/;"	f	namespace:librados
has_oi_attr_corrupted	rados/rados_types.hpp	/^  bool has_oi_attr_corrupted() const {	 \/\/ Compatibility$/;"	f	struct:librados::err_t
has_oi_attr_missing	rados/rados_types.hpp	/^  bool has_oi_attr_missing() const {    \/\/ Compatibility$/;"	f	struct:librados::err_t
has_omap_digest_mismatch	rados/rados_types.hpp	/^  bool has_omap_digest_mismatch() const {$/;"	f	namespace:librados
has_omap_digest_mismatch_info	rados/rados_types.hpp	/^  bool has_omap_digest_mismatch_info() const {$/;"	f	struct:librados::err_t
has_omap_digest_mismatch_oi	rados/rados_types.hpp	/^  bool has_omap_digest_mismatch_oi() const {   \/\/ Compatibility$/;"	f	struct:librados::err_t
has_read_error	rados/rados_types.hpp	/^  bool has_read_error() const {$/;"	f	struct:librados::err_t
has_shallow_errors	rados/rados_types.hpp	/^  bool has_shallow_errors() const {$/;"	f	namespace:librados
has_shallow_errors	rados/rados_types.hpp	/^  bool has_shallow_errors() const {$/;"	f	struct:librados::err_t
has_shard_missing	rados/rados_types.hpp	/^  bool has_shard_missing() const {$/;"	f	struct:librados::err_t
has_size_mismatch	rados/rados_types.hpp	/^  bool has_size_mismatch() const {$/;"	f	namespace:librados
has_size_mismatch_info	rados/rados_types.hpp	/^  bool has_size_mismatch_info() const {$/;"	f	struct:librados::err_t
has_size_mismatch_oi	rados/rados_types.hpp	/^  bool has_size_mismatch_oi() const {   \/\/ Compatibility$/;"	f	struct:librados::err_t
has_snapset_corrupted	rados/rados_types.hpp	/^  bool has_snapset_corrupted() const {$/;"	f	struct:librados::err_t
has_snapset_inconsistency	rados/rados_types.hpp	/^  bool has_snapset_inconsistency() const {$/;"	f	namespace:librados
has_snapset_missing	rados/rados_types.hpp	/^  bool has_snapset_missing() const {$/;"	f	struct:librados::err_t
has_ss_attr_corrupted	rados/rados_types.hpp	/^  bool has_ss_attr_corrupted() const {	\/\/ Compatibility$/;"	f	struct:librados::err_t
has_ss_attr_missing	rados/rados_types.hpp	/^  bool has_ss_attr_missing() const {	\/\/ Compatibility$/;"	f	struct:librados::err_t
has_stat_error	rados/rados_types.hpp	/^  bool has_stat_error() const {$/;"	f	struct:librados::err_t
has_subs	Context.h	/^  bool has_subs() const {$/;"	f	class:C_GatherBuilderBase
hash	buffer.h	/^    hash() : crc(0) { }$/;"	f	class:ceph::CEPH_BUFFER_API::hash
hash	buffer.h	/^    hash(uint32_t init) : crc(init) { }$/;"	f	class:ceph::CEPH_BUFFER_API::hash
hash	buffer.h	/^  class hash {$/;"	c	namespace:ceph::CEPH_BUFFER_API
hash	fs_types.h	/^  template<> struct hash< inodeno_t >$/;"	s	namespace:std
hash	object.h	/^  template<> struct hash<object_t> {$/;"	s	namespace:std
hash	object.h	/^  template<> struct hash<sobject_t> {$/;"	s	namespace:std
hash	rados/buffer.h	/^    hash() : crc(0) { }$/;"	f	class:ceph::CEPH_BUFFER_API::hash
hash	rados/buffer.h	/^    hash(uint32_t init) : crc(init) { }$/;"	f	class:ceph::CEPH_BUFFER_API::hash
hash	rados/buffer.h	/^  class hash {$/;"	c	namespace:ceph::CEPH_BUFFER_API
hashmix	hash.h	10;"	d
have_raw	buffer.h	/^    bool have_raw() const { return _raw ? true:false; }$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
have_raw	rados/buffer.h	/^    bool have_raw() const { return _raw ? true:false; }$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
have_version	ceph_fs.h	/^	__le64 have_version;$/;"	m	struct:ceph_mon_request_header
head	elist.h	/^    item *head;$/;"	m	class:elist::iterator
head_mismatch	rados/rados_types.hpp	/^  bool head_mismatch() const {$/;"	f	struct:inconsistent_snapset_t
headless	rados/rados_types.hpp	/^  bool headless() const {$/;"	f	struct:inconsistent_snapset_t
health_status_t	health.h	/^enum health_status_t {$/;"	g
height	cpp-btree/btree.h	/^  size_type height() const {$/;"	f	class:btree::btree
height	cpp-btree/btree_container.h	/^  size_type height() const { return tree_.height(); }$/;"	f	class:btree::btree_container
hit_set_get	rados.h	/^		} __attribute__ ((packed)) hit_set_get;$/;"	m	union:ceph_osd_op::__anon13	typeref:struct:ceph_osd_op::__anon13::__anon25
host_type	msgr.h	/^	__le32 host_type;    \/* CEPH_ENTITY_TYPE_* *\/$/;"	m	struct:ceph_msg_connect
hostos_to_ceph_errno	types.h	450;"	d
i	cpp-btree/btree.h	/^    *mutable_child(i) = NULL;$/;"	m	namespace:btree	typeref:class:btree::btree
id	CompatSet.h	/^    uint64_t id;$/;"	m	struct:CompatSet::Feature
id	rbd/librbd.h	/^  char *id;$/;"	m	struct:__anon87
id	rbd/librbd.h	/^  uint64_t id;$/;"	m	struct:__anon75
id	rbd/librbd.hpp	/^    std::string id;$/;"	m	struct:librbd::__anon74
id	rbd/librbd.hpp	/^    uint64_t id;$/;"	m	struct:librbd::__anon69
id	rbd_types.h	/^	__le64 id;$/;"	m	struct:rbd_obj_snap_ondisk
id	types.h	/^  int8_t id;$/;"	m	struct:shard_id_t
if_	cpp-btree/btree.h	/^  typedef typename if_<$/;"	t	struct:btree::btree_common_params
if_	cpp-btree/btree.h	/^struct if_<false, A, B> {$/;"	s	namespace:btree
if_	cpp-btree/btree.h	/^struct if_{$/;"	s	namespace:btree
image_ctx_t	rbd/librbd.hpp	/^  typedef void *image_ctx_t;$/;"	t	namespace:librbd
image_info_t	rbd/librbd.hpp	/^  typedef rbd_image_info_t image_info_t;$/;"	t	namespace:librbd
image_size	rbd_types.h	/^	__le64 image_size;$/;"	m	struct:rbd_obj_header_ondisk
image_size	rbd_types.h	/^	__le64 image_size;$/;"	m	struct:rbd_obj_snap_ondisk
impl	rados/librados.hpp	/^    ListObjectImpl *impl;$/;"	m	class:librados::ListObject
impl	rados/librados.hpp	/^    NObjectIteratorImpl *impl;$/;"	m	class:librados::NObjectIterator
impl	rados/librados.hpp	/^    ObjectOperationImpl *impl;$/;"	m	class:librados::ObjectOperation
impl	rados/librados.hpp	/^    std::unique_ptr<PlacementGroupImpl> impl;$/;"	m	struct:librados::PlacementGroup
in_addr	msgr.h	/^	struct sockaddr_storage in_addr;$/;"	m	struct:ceph_entity_addr	typeref:struct:ceph_entity_addr::sockaddr_storage
incompat	CompatSet.h	/^  FeatureSet incompat;$/;"	m	struct:CompatSet
inconsistent_obj_t	rados/rados_types.hpp	/^  inconsistent_obj_t(const object_id_t& object)$/;"	f	struct:inconsistent_obj_t
inconsistent_obj_t	rados/rados_types.hpp	/^struct inconsistent_obj_t : obj_err_t {$/;"	s
inconsistent_snapset_t	rados/rados_types.hpp	/^  inconsistent_snapset_t(const object_id_t& head)$/;"	f	struct:inconsistent_snapset_t
inconsistent_snapset_t	rados/rados_types.hpp	/^struct inconsistent_snapset_t {$/;"	s
increment	cpp-btree/btree.h	/^  void increment() {$/;"	f	struct:btree::btree_iterator
increments	counter.h	/^  static uint64_t increments() {$/;"	f	class:Counter
indata_len	rados.h	/^			__le32 indata_len;$/;"	m	struct:ceph_osd_op::__anon13::__anon16
indices	denc.h	/^  struct indices {};$/;"	s	namespace:_denc
info	rbd/librbd.h	/^  rbd_mirror_image_info_t info;$/;"	m	struct:__anon83
info	rbd/librbd.hpp	/^    mirror_image_info_t info;$/;"	m	struct:librbd::__anon73
info_corrupted	rados/rados_types.hpp	/^  bool info_corrupted() const {$/;"	f	struct:inconsistent_snapset_t
info_missing	rados/rados_types.hpp	/^  bool info_missing() const {$/;"	f	struct:inconsistent_snapset_t
init	mempool.h	/^  void init(bool force_register) {$/;"	f	class:mempool::pool_allocator
init_internal	cpp-btree/btree.h	/^  static btree_node* init_internal(internal_fields *f, btree_node *parent) {$/;"	f	class:btree::btree_node
init_le16	byteorder.h	/^inline __u16 init_le16(__u16 x) {$/;"	f
init_le32	byteorder.h	/^inline __u32 init_le32(__u32 x) {$/;"	f
init_le64	byteorder.h	/^inline __u64 init_le64(__u64 x) {$/;"	f
init_leaf	cpp-btree/btree.h	/^  static btree_node* init_leaf($/;"	f	class:btree::btree_node
init_root	cpp-btree/btree.h	/^  static btree_node* init_root(root_fields *f, btree_node *parent) {$/;"	f	class:btree::btree_node
ino	ceph_fs.h	/^	__le64 ino, cap_id;            \/* ino and unique cap id *\/$/;"	m	struct:ceph_mds_request_release
ino	ceph_fs.h	/^	__le64 ino, realm;$/;"	m	struct:ceph_mds_caps_head
ino	ceph_fs.h	/^	__le64 ino;                    \/* use this ino for openc, mkdir, mknod,$/;"	m	struct:ceph_mds_request_head
ino	ceph_fs.h	/^	__le64 ino;                    \/* use this ino for openc, mkdir, mknod,$/;"	m	struct:ceph_mds_request_head_legacy
ino	ceph_fs.h	/^	__le64 ino;           \/* ino *\/$/;"	m	struct:ceph_mds_snap_realm
ino	ceph_fs.h	/^	__le64 ino;     \/* snap realm base *\/$/;"	m	struct:ceph_mds_snaprealm_reconnect
ino	ceph_fs.h	/^	__le64 ino;$/;"	m	struct:ceph_mds_cap_item
ino	ceph_fs.h	/^	__le64 ino;$/;"	m	struct:ceph_mds_lease
ino	cephfs/libcephfs.h	/^  inodeno_t ino;$/;"	m	struct:vinodeno_t
ino	filepath.h	/^  inodeno_t ino;   \/\/ base inode.  ino=0 implies pure relative path.$/;"	m	class:filepath
ino	object.h	/^  uint64_t ino, bno;$/;"	m	struct:file_object_t
ino_relative	filepath.h	/^  bool ino_relative() const { return ino > 0; }$/;"	f	class:filepath
inodeno_t	cephfs/libcephfs.h	/^typedef struct inodeno_t {$/;"	s
inodeno_t	cephfs/libcephfs.h	/^} inodeno_t;$/;"	t	typeref:struct:inodeno_t
inodeno_t	fs_types.h	/^  inodeno_t() : val(0) {}$/;"	f	struct:inodeno_t
inodeno_t	fs_types.h	/^  inodeno_t(_inodeno_t v) : val(v) {}$/;"	f	struct:inodeno_t
inodeno_t	fs_types.h	/^struct inodeno_t {$/;"	s
insert	CompatSet.h	/^    void insert(const Feature& f) {$/;"	f	class:CompatSet::FeatureSet
insert	compact_map.h	/^  iterator insert(const std::pair<const Key, T>& val) {$/;"	f	class:compact_map_base
insert	compact_set.h	/^  std::pair<iterator,bool> insert(const T& t) {$/;"	f	class:compact_set_base
insert	cpp-btree/btree_container.h	/^  iterator insert(const value_type &x) {$/;"	f	class:btree::btree_multi_container
insert	cpp-btree/btree_container.h	/^  iterator insert(iterator position, const value_type &x) {$/;"	f	class:btree::btree_multi_container
insert	cpp-btree/btree_container.h	/^  iterator insert(iterator position, const value_type &x) {$/;"	f	class:btree::btree_unique_container
insert	cpp-btree/btree_container.h	/^  std::pair<iterator,bool> insert(const value_type &x) {$/;"	f	class:btree::btree_unique_container
insert	cpp-btree/btree_container.h	/^  void insert(InputIterator b, InputIterator e) {$/;"	f	class:btree::btree_multi_container
insert	cpp-btree/btree_container.h	/^  void insert(InputIterator b, InputIterator e) {$/;"	f	class:btree::btree_unique_container
insert	denc.h	/^    static void insert(Container& c, Args&& ...args) {$/;"	f	struct:_denc::maplike_details
insert	denc.h	/^    static void insert(Container& c, Args&& ...args) {$/;"	f	struct:_denc::pushback_details
insert	denc.h	/^    static void insert(Container& c, Args&& ...args) {$/;"	f	struct:_denc::setlike_details
insert	frag.h	/^  void insert(frag_t f) {$/;"	f	class:fragset_t
insert	interval_set.h	/^  void insert(T start, T len, T *pstart=0, T *plen=0) {$/;"	f	class:interval_set
insert	interval_set.h	/^  void insert(T val) {$/;"	f	class:interval_set
insert	interval_set.h	/^  void insert(const interval_set &a) {$/;"	f	class:interval_set
insert	rangeset.h	/^  void insert(T val) {$/;"	f	class:rangeset
insert_after	elist.h	/^    void insert_after(item *other) {$/;"	f	struct:elist::item
insert_before	elist.h	/^    void insert_before(item *other) {$/;"	f	struct:elist::item
insert_multi	cpp-btree/btree.h	/^  iterator insert_multi(const value_type &v) {$/;"	f	class:btree::btree
insert_unique	cpp-btree/btree.h	/^  std::pair<iterator,bool> insert_unique(const value_type &v) {$/;"	f	class:btree::btree
internal_allocator	cpp-btree/btree.h	/^  const internal_allocator_type& internal_allocator() const {$/;"	f	class:btree::btree
internal_allocator_type	cpp-btree/btree.h	/^    internal_allocator_type;$/;"	t	class:btree::btree
internal_end	cpp-btree/btree.h	/^  const_iterator internal_end(const_iterator iter) const {$/;"	f	class:btree::btree
internal_end	cpp-btree/btree.h	/^  iterator internal_end(iterator iter) {$/;"	f	class:btree::btree
internal_fields	cpp-btree/btree.h	/^  struct internal_fields : public leaf_fields {$/;"	s	class:btree::btree_node
internal_fields	cpp-btree/btree.h	/^  typedef typename node_type::internal_fields internal_fields;$/;"	t	class:btree::btree
internal_locate_type	cpp-btree/btree.h	/^    btree_internal_locate_plain_compare>::type internal_locate_type;$/;"	t	class:btree::btree
internal_nodes	cpp-btree/btree.h	/^    ssize_t internal_nodes;$/;"	m	struct:btree::btree::node_stats
internal_nodes	cpp-btree/btree.h	/^  size_type internal_nodes() const {$/;"	f	class:btree::btree
internal_nodes	cpp-btree/btree_container.h	/^  size_type internal_nodes() const { return tree_.internal_nodes(); }$/;"	f	class:btree::btree_container
internal_stats	cpp-btree/btree.h	/^  node_stats internal_stats(const node_type *node) const {$/;"	f	class:btree::btree
internal_timegm	timegm.h	/^static  time_t internal_timegm(tm const *t) {$/;"	f
intersection_of	interval_set.h	/^  void intersection_of(const interval_set &a, const interval_set &b) {$/;"	f	class:interval_set
intersection_of	interval_set.h	/^  void intersection_of(const interval_set& b) {$/;"	f	class:interval_set
intersection_size_asym	interval_set.h	/^  void intersection_size_asym(const interval_set &s, const interval_set &l) {$/;"	f	class:interval_set
intersects	interval_set.h	/^  bool intersects(T start, T len) const {$/;"	f	class:interval_set
interval_set	interval_set.h	/^  interval_set() : _size(0) {}$/;"	f	class:interval_set
interval_set	interval_set.h	/^  interval_set(Map& other) {$/;"	f	class:interval_set
interval_set	interval_set.h	/^class interval_set {$/;"	c
io_ctx_impl	rados/librados.hpp	/^    IoCtxImpl *io_ctx_impl;$/;"	m	class:librados::IoCtx
is_aligned	buffer.h	/^    bool is_aligned(unsigned align) const {$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
is_aligned	rados/buffer.h	/^    bool is_aligned(unsigned align) const {$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
is_any_of	denc.h	/^  struct is_any_of<T, Head, Tail...> : std::conditional<$/;"	s	namespace:_denc
is_any_of	denc.h	/^  template<class T, class...> struct is_any_of : std::false_type$/;"	s	namespace:_denc
is_dentry	ceph_fs.h	/^	__u8 is_dentry, is_target;     \/* true if dentry, target inode records$/;"	m	struct:ceph_mds_reply_head
is_key_compare_to	cpp-btree/btree.h	/^  typedef btree_is_key_compare_to<key_compare> is_key_compare_to;$/;"	t	struct:btree::btree_common_params
is_key_compare_to	cpp-btree/btree.h	/^  typedef typename Params::is_key_compare_to is_key_compare_to;$/;"	t	class:btree::btree
is_last_dot_or_dotdot	filepath.h	/^  bool is_last_dot_or_dotdot() const {$/;"	f	class:filepath
is_leaf	frag.h	/^  bool is_leaf(frag_t x) const {$/;"	f	class:fragtree_t
is_leap	timegm.h	/^static int32_t is_leap(int32_t year) {$/;"	f
is_left	frag.h	/^  bool is_left() const { return ceph_frag_is_left_child(_enc); }$/;"	f	class:frag_t
is_leftmost	frag.h	/^  bool is_leftmost() const { return ceph_frag_is_leftmost(_enc); }$/;"	f	class:frag_t
is_n_align_sized	buffer.h	/^    bool is_n_align_sized(unsigned align) const$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
is_n_align_sized	rados/buffer.h	/^    bool is_n_align_sized(unsigned align) const$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
is_n_page_sized	buffer.h	/^    bool is_n_page_sized() const { return is_n_align_sized(CEPH_PAGE_SIZE); }$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
is_n_page_sized	rados/buffer.h	/^    bool is_n_page_sized() const { return is_n_align_sized(CEPH_PAGE_SIZE); }$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
is_on_list	elist.h	/^    bool is_on_list() const { return !empty(); }$/;"	f	struct:elist::item
is_on_list	xlist.h	/^    bool is_on_list() const { return _list ? true:false; }$/;"	f	struct:xlist::item
is_page_aligned	buffer.h	/^    bool is_page_aligned() const { return is_aligned(CEPH_PAGE_SIZE); }$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
is_page_aligned	rados/buffer.h	/^    bool is_page_aligned() const { return is_aligned(CEPH_PAGE_SIZE); }$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
is_partial	buffer.h	/^    bool is_partial() const {$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
is_partial	rados/buffer.h	/^    bool is_partial() const {$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
is_right	frag.h	/^  bool is_right() const { return ceph_frag_is_right_child(_enc); }$/;"	f	class:frag_t
is_rightmost	frag.h	/^  bool is_rightmost() const { return ceph_frag_is_rightmost(_enc); }$/;"	f	class:frag_t
is_root	cpp-btree/btree.h	/^  bool is_root() const { return parent()->leaf(); }$/;"	f	class:btree::btree_node
is_root	frag.h	/^  bool is_root() const { return bits() == 0; }$/;"	f	class:frag_t
is_target	ceph_fs.h	/^	__u8 is_dentry, is_target;     \/* true if dentry, target inode records$/;"	m	struct:ceph_mds_reply_head
is_zero	utime.h	/^  bool is_zero() const {$/;"	f	class:utime_t
is_zero	uuid.h	/^  bool is_zero() const {$/;"	f	struct:uuid_d
issue_seq	ceph_fs.h	/^	__le32 seq, issue_seq, mseq;$/;"	m	struct:ceph_mds_request_release
issue_seq	ceph_fs.h	/^	__le32 seq, issue_seq;$/;"	m	struct:ceph_mds_caps_head
issued	ceph_fs.h	/^	__le32 issued;$/;"	m	struct:ceph_mds_cap_reconnect
issued	ceph_fs.h	/^	__le32 issued;$/;"	m	struct:ceph_mds_cap_reconnect_v1
it	compact_map.h	/^    It it;$/;"	m	class:compact_map_base::const_iterator_base
it	compact_map.h	/^    It it;$/;"	m	class:compact_map_base::iterator_base
it	compact_set.h	/^    It it;$/;"	m	class:compact_set_base::iterator_base
it	rangeset.h	/^  typename map<T,T>::iterator it;$/;"	m	class:rangeset_iterator
item	elist.h	/^    item(T i=0) : _prev(this), _next(this) {}$/;"	f	struct:elist::item
item	elist.h	/^  struct item {$/;"	s	class:elist
item	xlist.h	/^    item(T i) : _item(i), _prev(0), _next(0), _list(0) {}$/;"	f	struct:xlist::item
item	xlist.h	/^  struct item {$/;"	s	class:xlist
item_offset	elist.h	/^    size_t item_offset;$/;"	m	class:elist::iterator
item_offset	elist.h	/^  size_t item_offset;$/;"	m	class:elist
item_size	mempool.h	/^  size_t item_size;$/;"	m	struct:mempool::type_t
items	mempool.h	/^  ssize_t items = 0;$/;"	m	struct:mempool::stats_t
items	mempool.h	/^  std::atomic<size_t> items = {0};$/;"	m	struct:mempool::shard_t
items	mempool.h	/^  std::atomic<ssize_t> items = {0};  \/\/ signed$/;"	m	struct:mempool::type_t
iterator	buffer.h	/^      iterator(const ptr *p, size_t offset, bool d)$/;"	f	class:ceph::CEPH_BUFFER_API::ptr::iterator
iterator	buffer.h	/^    class CEPH_BUFFER_API iterator : public iterator_impl<false> {$/;"	c	class:ceph::CEPH_BUFFER_API::list
iterator	buffer.h	/^    class iterator {$/;"	c	class:ceph::CEPH_BUFFER_API::ptr
iterator	compact_map.h	/^      iterator() { }$/;"	f	class:compact_map_base::iterator
iterator	compact_map.h	/^      iterator(compact_map_base* m) : iterator_base<typename Map::iterator>(m) { }$/;"	f	class:compact_map_base::iterator
iterator	compact_map.h	/^      iterator(compact_map_base* m, const typename Map::iterator& i)$/;"	f	class:compact_map_base::iterator
iterator	compact_map.h	/^      iterator(const iterator_base<typename Map::iterator>& o)$/;"	f	class:compact_map_base::iterator
iterator	compact_map.h	/^  class iterator : public iterator_base<typename Map::iterator> {$/;"	c	class:compact_map_base
iterator	compact_set.h	/^      iterator() { }$/;"	f	class:compact_set_base::iterator
iterator	compact_set.h	/^      iterator(compact_set_base* s) : iterator_base<typename Set::iterator>(s) { }$/;"	f	class:compact_set_base::iterator
iterator	compact_set.h	/^      iterator(compact_set_base* s, const typename Set::iterator& i)$/;"	f	class:compact_set_base::iterator
iterator	compact_set.h	/^      iterator(const iterator_base<typename Set::iterator>& o)$/;"	f	class:compact_set_base::iterator
iterator	compact_set.h	/^  class iterator : public iterator_base<typename Set::iterator> {$/;"	c	class:compact_set_base
iterator	cpp-btree/btree.h	/^    normal_node, normal_reference, normal_pointer> iterator;$/;"	t	struct:btree::btree_iterator
iterator	cpp-btree/btree.h	/^  typedef btree_iterator<node_type, reference, pointer> iterator;$/;"	t	class:btree::btree
iterator	cpp-btree/btree_container.h	/^  typedef typename Tree::iterator iterator;$/;"	t	class:btree::btree_container
iterator	cpp-btree/btree_container.h	/^  typedef typename Tree::iterator iterator;$/;"	t	class:btree::btree_multi_container
iterator	cpp-btree/btree_container.h	/^  typedef typename Tree::iterator iterator;$/;"	t	class:btree::btree_unique_container
iterator	elist.h	/^    iterator(item *h, size_t o, mode_t m) :$/;"	f	class:elist::iterator
iterator	elist.h	/^  class iterator {$/;"	c	class:elist
iterator	interval_set.h	/^        explicit iterator(typename Map::iterator iter)$/;"	f	class:interval_set::iterator
iterator	interval_set.h	/^  class iterator : public std::iterator <std::forward_iterator_tag, T>$/;"	c	class:interval_set
iterator	rados/buffer.h	/^      iterator(const ptr *p, size_t offset, bool d)$/;"	f	class:ceph::CEPH_BUFFER_API::ptr::iterator
iterator	rados/buffer.h	/^    class CEPH_BUFFER_API iterator : public iterator_impl<false> {$/;"	c	class:ceph::CEPH_BUFFER_API::list
iterator	rados/buffer.h	/^    class iterator {$/;"	c	class:ceph::CEPH_BUFFER_API::ptr
iterator	rangeset.h	/^  typedef rangeset_iterator<T> iterator;$/;"	t	class:rangeset
iterator	xlist.h	/^    iterator(item *i = 0) : cur(i) {}$/;"	f	class:xlist::iterator
iterator	xlist.h	/^  class iterator: std::iterator<std::forward_iterator_tag, T> {$/;"	c	class:xlist
iterator_base	compact_map.h	/^    iterator_base() : map(0) { }$/;"	f	class:compact_map_base::iterator_base
iterator_base	compact_map.h	/^    iterator_base(compact_map_base* m) : map(m) { }$/;"	f	class:compact_map_base::iterator_base
iterator_base	compact_map.h	/^    iterator_base(compact_map_base* m, const It& i) : map(m), it(i) { }$/;"	f	class:compact_map_base::iterator_base
iterator_base	compact_map.h	/^    iterator_base(const iterator_base& o) {$/;"	f	class:compact_map_base::iterator_base
iterator_base	compact_map.h	/^  class iterator_base {$/;"	c	class:compact_map_base
iterator_base	compact_set.h	/^    iterator_base() : set(0) { }$/;"	f	class:compact_set_base::iterator_base
iterator_base	compact_set.h	/^    iterator_base(const compact_set_base* s) : set(s) { }$/;"	f	class:compact_set_base::iterator_base
iterator_base	compact_set.h	/^    iterator_base(const compact_set_base* s, const It& i) : set(s), it(i) { }$/;"	f	class:compact_set_base::iterator_base
iterator_base	compact_set.h	/^    iterator_base(const iterator_base& o) {$/;"	f	class:compact_set_base::iterator_base
iterator_base	compact_set.h	/^  class iterator_base {$/;"	c	class:compact_set_base
iterator_category	cpp-btree/btree.h	/^  typedef std::bidirectional_iterator_tag iterator_category;$/;"	t	struct:btree::btree_iterator
iterator_impl	buffer.h	/^      iterator_impl()$/;"	f	class:ceph::CEPH_BUFFER_API::list::iterator_impl
iterator_impl	buffer.h	/^      iterator_impl(bl_t *l, unsigned o, list_iter_t ip, unsigned po)$/;"	f	class:ceph::CEPH_BUFFER_API::list::iterator_impl
iterator_impl	buffer.h	/^    class CEPH_BUFFER_API iterator_impl$/;"	c	class:ceph::CEPH_BUFFER_API::list
iterator_impl	rados/buffer.h	/^      iterator_impl()$/;"	f	class:ceph::CEPH_BUFFER_API::list::iterator_impl
iterator_impl	rados/buffer.h	/^      iterator_impl(bl_t *l, unsigned o, list_iter_t ip, unsigned po)$/;"	f	class:ceph::CEPH_BUFFER_API::list::iterator_impl
iterator_impl	rados/buffer.h	/^    class CEPH_BUFFER_API iterator_impl$/;"	c	class:ceph::CEPH_BUFFER_API::list
joinify	stringify.h	/^T joinify(const A &begin, const A &end, const T &t)$/;"	f
kExactMatch	cpp-btree/btree.h	/^    kExactMatch = 1 << 30,$/;"	e	enum:btree::btree_node::__anon98
kExactMatch	cpp-btree/btree.h	/^    kExactMatch = node_type::kExactMatch,$/;"	e	enum:btree::btree::__anon99
kMatchMask	cpp-btree/btree.h	/^    kMatchMask = kExactMatch - 1,$/;"	e	enum:btree::btree_node::__anon98
kMatchMask	cpp-btree/btree.h	/^    kMatchMask = node_type::kMatchMask,$/;"	e	enum:btree::btree::__anon99
kMinNodeValues	cpp-btree/btree.h	/^    kMinNodeValues = kNodeValues \/ 2,$/;"	e	enum:btree::btree::__anon99
kNodeTargetValues	cpp-btree/btree.h	/^    kNodeTargetValues = (kTargetNodeSize - sizeof(base_fields)) \/ kValueSize,$/;"	e	enum:btree::btree_node::__anon98
kNodeValueSpace	cpp-btree/btree.h	/^    kNodeValueSpace = TargetNodeSize - 2 * sizeof(void*),$/;"	e	enum:btree::btree_common_params::__anon95
kNodeValues	cpp-btree/btree.h	/^    kNodeValues = kNodeTargetValues >= 3 ? kNodeTargetValues : 3,$/;"	e	enum:btree::btree_node::__anon98
kNodeValues	cpp-btree/btree.h	/^    kNodeValues = node_type::kNodeValues,$/;"	e	enum:btree::btree::__anon99
kTargetNodeSize	cpp-btree/btree.h	/^    kTargetNodeSize = TargetNodeSize,$/;"	e	enum:btree::btree_common_params::__anon95
kTargetNodeSize	cpp-btree/btree.h	/^    kTargetNodeSize = params_type::kTargetNodeSize,$/;"	e	enum:btree::btree_node::__anon98
kValueSize	cpp-btree/btree.h	/^    kValueSize = node_type::kValueSize,$/;"	e	enum:btree::btree::__anon99
kValueSize	cpp-btree/btree.h	/^    kValueSize = params_type::kValueSize,$/;"	e	enum:btree::btree_node::__anon98
kValueSize	cpp-btree/btree.h	/^    kValueSize = sizeof(Key) + sizeof(data_type),$/;"	e	enum:btree::btree_map_params::__anon96
kValueSize	cpp-btree/btree.h	/^    kValueSize = sizeof(Key),$/;"	e	enum:btree::btree_set_params::__anon97
kb	ceph_fs.h	/^	__le64 kb, kb_used, kb_avail;$/;"	m	struct:ceph_statfs
kb	rados/librados.h	/^  uint64_t kb, kb_used, kb_avail;$/;"	m	struct:rados_cluster_stat_t
kb_avail	ceph_fs.h	/^	__le64 kb, kb_used, kb_avail;$/;"	m	struct:ceph_statfs
kb_avail	rados/librados.h	/^  uint64_t kb, kb_used, kb_avail;$/;"	m	struct:rados_cluster_stat_t
kb_used	ceph_fs.h	/^	__le64 kb, kb_used, kb_avail;$/;"	m	struct:ceph_statfs
kb_used	rados/librados.h	/^  uint64_t kb, kb_used, kb_avail;$/;"	m	struct:rados_cluster_stat_t
key	cpp-btree/btree.h	/^  const key_type& key() const {$/;"	f	struct:btree::btree_iterator
key	cpp-btree/btree.h	/^  const key_type& key(int i) const {$/;"	f	class:btree::btree_node
key	cpp-btree/btree.h	/^  static const Key& key(const mutable_value_type &x) { return x.first; }$/;"	f	struct:btree::btree_map_params
key	cpp-btree/btree.h	/^  static const Key& key(const value_type &x) { return x.first; }$/;"	f	struct:btree::btree_map_params
key	cpp-btree/btree.h	/^  static const Key& key(const value_type &x) { return x; }$/;"	f	struct:btree::btree_set_params
key	cpp-btree/btree_container.h	/^    const key_type &key;$/;"	m	struct:btree::btree_map_container::generate_value
key_comp	cpp-btree/btree.h	/^  const key_compare& key_comp() const {$/;"	f	class:btree::btree
key_compare	cpp-btree/btree.h	/^    Compare, btree_key_compare_to_adapter<Compare> >::type key_compare;$/;"	t	struct:btree::btree_common_params
key_compare	cpp-btree/btree.h	/^  typedef typename Params::key_compare key_compare;$/;"	t	class:btree::btree
key_compare	cpp-btree/btree.h	/^  typedef typename Params::key_compare key_compare;$/;"	t	class:btree::btree_node
key_compare	cpp-btree/btree_container.h	/^  typedef typename Tree::key_compare key_compare;$/;"	t	class:btree::btree_container
key_compare	cpp-btree/btree_container.h	/^  typedef typename Tree::key_compare key_compare;$/;"	t	class:btree::btree_map_container
key_compare	cpp-btree/btree_container.h	/^  typedef typename Tree::key_compare key_compare;$/;"	t	class:btree::btree_multi_container
key_compare	cpp-btree/btree_container.h	/^  typedef typename Tree::key_compare key_compare;$/;"	t	class:btree::btree_unique_container
key_compare	cpp-btree/btree_map.h	/^  typedef typename btree_type::key_compare key_compare;$/;"	t	class:btree::btree_map
key_compare	cpp-btree/btree_map.h	/^  typedef typename btree_type::key_compare key_compare;$/;"	t	class:btree::btree_multimap
key_compare	cpp-btree/btree_set.h	/^  typedef typename btree_type::key_compare key_compare;$/;"	t	class:btree::btree_multiset
key_compare	cpp-btree/btree_set.h	/^  typedef typename btree_type::key_compare key_compare;$/;"	t	class:btree::btree_set
key_comparison_function_must_return_bool	cpp-btree/btree.h	/^      key_comparison_function_must_return_bool);$/;"	m	class:btree::btree
key_type	cpp-btree/btree.h	/^  typedef Key key_type;$/;"	t	struct:btree::btree_common_params
key_type	cpp-btree/btree.h	/^  typedef typename Node::key_type key_type;$/;"	t	struct:btree::btree_iterator
key_type	cpp-btree/btree.h	/^  typedef typename Params::key_type key_type;$/;"	t	class:btree::btree
key_type	cpp-btree/btree.h	/^  typedef typename Params::key_type key_type;$/;"	t	class:btree::btree_node
key_type	cpp-btree/btree_container.h	/^  typedef typename Tree::key_type key_type;$/;"	t	class:btree::btree_container
key_type	cpp-btree/btree_container.h	/^  typedef typename Tree::key_type key_type;$/;"	t	class:btree::btree_map_container
key_type	cpp-btree/btree_container.h	/^  typedef typename Tree::key_type key_type;$/;"	t	class:btree::btree_multi_container
key_type	cpp-btree/btree_container.h	/^  typedef typename Tree::key_type key_type;$/;"	t	class:btree::btree_unique_container
last	ceph_fs.h	/^	__le64 first, last;     \/* snap range *\/$/;"	m	struct:ceph_mds_lease
last_dentry	filepath.h	/^  const string& last_dentry() const {$/;"	f	class:filepath
last_p	buffer.h	/^    mutable iterator last_p;$/;"	m	class:ceph::CEPH_BUFFER_API::list
last_p	rados/buffer.h	/^    mutable iterator last_p;$/;"	m	class:ceph::CEPH_BUFFER_API::list
last_update	rbd/librbd.h	/^  time_t last_update;$/;"	m	struct:__anon83
last_update	rbd/librbd.hpp	/^    time_t last_update;$/;"	m	struct:librbd::__anon73
layout	ceph_fs.h	/^			struct ceph_file_layout layout;$/;"	m	struct:ceph_mds_caps_body_legacy::__anon66::__anon67	typeref:struct:ceph_mds_caps_body_legacy::__anon66::__anon67::ceph_file_layout
layout	ceph_fs.h	/^		struct ceph_file_layout layout;$/;"	m	struct:ceph_mds_request_args::__anon63	typeref:struct:ceph_mds_request_args::__anon63::ceph_file_layout
layout	ceph_fs.h	/^		struct ceph_file_layout layout;$/;"	m	struct:ceph_mds_request_args_legacy::__anon54	typeref:struct:ceph_mds_request_args_legacy::__anon54::ceph_file_layout
layout	rados.h	/^	struct ceph_object_layout layout;$/;"	m	struct:ceph_osd_reply_head	typeref:struct:ceph_osd_reply_head::ceph_object_layout
le16_to_cpu	byteorder.h	103;"	d
le32_to_cpu	byteorder.h	102;"	d
le64_to_cpu	byteorder.h	101;"	d
leaf	cpp-btree/btree.h	/^    bool leaf;$/;"	m	struct:btree::btree_node::base_fields
leaf	cpp-btree/btree.h	/^  bool leaf() const { return fields_.leaf; }$/;"	f	class:btree::btree_node
leaf_fields	cpp-btree/btree.h	/^  struct leaf_fields : public base_fields {$/;"	s	class:btree::btree_node
leaf_fields	cpp-btree/btree.h	/^  typedef typename node_type::leaf_fields leaf_fields;$/;"	t	class:btree::btree
leaf_nodes	cpp-btree/btree.h	/^    ssize_t leaf_nodes;$/;"	m	struct:btree::btree::node_stats
leaf_nodes	cpp-btree/btree.h	/^  size_type leaf_nodes() const {$/;"	f	class:btree::btree
leaf_nodes	cpp-btree/btree_container.h	/^  size_type leaf_nodes() const { return tree_.leaf_nodes(); }$/;"	f	class:btree::btree_container
left_child	frag.h	/^  frag_t left_child() const { return frag_t(ceph_frag_left_child(_enc)); }$/;"	f	class:frag_t
leftmost	cpp-btree/btree.h	/^  const node_type* leftmost() const { return root() ? root()->parent() : NULL; }$/;"	f	class:btree::btree
leftmost	cpp-btree/btree.h	/^  node_type* leftmost() { return root() ? root()->parent() : NULL; }$/;"	f	class:btree::btree
length	buffer.h	/^    unsigned length() const { return _len; }$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
length	buffer.h	/^    unsigned length() const {$/;"	f	class:ceph::CEPH_BUFFER_API::list
length	ceph_fs.h	/^		__le64 length; \/* num bytes to lock from start *\/$/;"	m	struct:ceph_mds_request_args::__anon64
length	ceph_fs.h	/^		__le64 length; \/* num bytes to lock from start *\/$/;"	m	struct:ceph_mds_request_args_legacy::__anon55
length	ceph_fs.h	/^	__le64 length; \/* num bytes to lock; 0 for all following start *\/$/;"	m	struct:ceph_filelock
length	filepath.h	/^  int length() const { return path.length(); }$/;"	f	class:filepath
length	rados.h	/^			__le64 length;$/;"	m	struct:ceph_osd_op::__anon13::__anon28
length	rados.h	/^			__le64 length;$/;"	m	struct:ceph_osd_op::__anon13::__anon29
length	rados.h	/^			__le64 offset, length;$/;"	m	struct:ceph_osd_op::__anon13::__anon14
length	rados.h	/^			__le64 offset, length;$/;"	m	struct:ceph_osd_op::__anon13::__anon22
length	rados/buffer.h	/^    unsigned length() const { return _len; }$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
length	rados/buffer.h	/^    unsigned length() const {$/;"	f	class:ceph::CEPH_BUFFER_API::list
librados	rados/librados.hpp	/^namespace librados$/;"	n
librados	rados/rados_types.hpp	/^namespace librados {$/;"	n
libradosstriper	rados/librados.hpp	/^namespace libradosstriper$/;"	n
libradosstriper	radosstriper/libradosstriper.hpp	/^namespace libradosstriper$/;"	n
librbd	rbd/librbd.hpp	/^namespace librbd {$/;"	n
librbd_progress_fn_t	rbd/librbd.h	/^typedef int (*librbd_progress_fn_t)(uint64_t offset, uint64_t total, void *ptr);$/;"	t
librgw_t	rados/librgw.h	/^typedef void* librgw_t;$/;"	t
linear_search_compare_to	cpp-btree/btree.h	/^  int linear_search_compare_to($/;"	f	class:btree::btree_node
linear_search_compare_to_type	cpp-btree/btree.h	/^    key_type, self_type, key_compare> linear_search_compare_to_type;$/;"	t	class:btree::btree_node
linear_search_plain_compare	cpp-btree/btree.h	/^  int linear_search_plain_compare($/;"	f	class:btree::btree_node
linear_search_plain_compare_type	cpp-btree/btree.h	/^    key_type, self_type, key_compare> linear_search_plain_compare_type;$/;"	t	class:btree::btree_node
linear_search_type	cpp-btree/btree.h	/^    linear_search_plain_compare_type>::type linear_search_type;$/;"	t	class:btree::btree_node
list	buffer.h	/^    list() : _len(0), _memcopy_count(0), last_p(this) {}$/;"	f	class:ceph::CEPH_BUFFER_API::list
list	buffer.h	/^    list(const list& other) : _buffers(other._buffers), _len(other._len),$/;"	f	class:ceph::CEPH_BUFFER_API::list
list	buffer.h	/^    list(unsigned prealloc) : _len(0), _memcopy_count(0), last_p(this) {$/;"	f	class:ceph::CEPH_BUFFER_API::list
list	buffer.h	/^  class CEPH_BUFFER_API list {$/;"	c	namespace:ceph::CEPH_BUFFER_API
list	rados/buffer.h	/^    list() : _len(0), _memcopy_count(0), last_p(this) {}$/;"	f	class:ceph::CEPH_BUFFER_API::list
list	rados/buffer.h	/^    list(const list& other) : _buffers(other._buffers), _len(other._len),$/;"	f	class:ceph::CEPH_BUFFER_API::list
list	rados/buffer.h	/^    list(unsigned prealloc) : _len(0), _memcopy_count(0), last_p(this) {$/;"	f	class:ceph::CEPH_BUFFER_API::list
list	rados/buffer.h	/^  class CEPH_BUFFER_API list {$/;"	c	namespace:ceph::CEPH_BUFFER_API
list_ctx_t	rados/librados.hpp	/^  typedef void *list_ctx_t;$/;"	t	namespace:librados
list_iter_t	buffer.h	/^					typename std::list<ptr>::iterator>::type list_iter_t;$/;"	t	class:ceph::CEPH_BUFFER_API::list::iterator_impl
list_iter_t	rados/buffer.h	/^					typename std::list<ptr>::iterator>::type list_iter_t;$/;"	t	class:ceph::CEPH_BUFFER_API::list::iterator_impl
list_t	buffer.h	/^					std::list<ptr> >::type list_t;$/;"	t	class:ceph::CEPH_BUFFER_API::list::iterator_impl
list_t	rados/buffer.h	/^					std::list<ptr> >::type list_t;$/;"	t	class:ceph::CEPH_BUFFER_API::list::iterator_impl
list_to_context	Context.h	/^  static ContextType *list_to_context(list<ContextType *> &cs) {$/;"	f	class:C_ContextsBase
localtime	utime.h	/^  ostream& localtime(ostream& out) const {$/;"	f	class:utime_t
locator	rados/librados.h	/^  char *locator;$/;"	m	struct:rados_object_list_item
locator	rados/librados.hpp	/^    std::string locator;$/;"	m	class:librados::ObjectItem
locator	rados/rados_types.hpp	/^  std::string locator;$/;"	m	struct:librados::object_id_t
locator_length	rados/librados.h	/^  size_t locator_length;$/;"	m	struct:rados_object_list_item
lock	Context.h	/^  Mutex *lock;$/;"	m	struct:C_Lock
lock	Context.h	/^  mutable Mutex lock;$/;"	m	class:C_GatherBase
lock	Spinlock.h	/^  pthread_spinlock_t lock;$/;"	m	struct:__anon1
lock	Spinlock.h	/^  void lock() const {$/;"	f	class:Spinlock
lock	mempool.h	/^  mutable std::mutex lock;  \/\/ only used for types list$/;"	m	class:mempool::pool_t
lock_	on_exit.h	/^    pthread_mutex_t lock_;$/;"	m	class:OnExitManager
locker_t	rados/librados.hpp	/^  } locker_t;$/;"	t	namespace:librados	typeref:struct:librados::__anon42
locker_t	rbd/librbd.hpp	/^  } locker_t;$/;"	t	namespace:librbd	typeref:struct:librbd::__anon70
loff_t	types.h	/^typedef long long loff_t;$/;"	t
loff_t	types.h	/^typedef off_t loff_t;$/;"	t
lower_bound	compact_map.h	/^  const_iterator lower_bound(const Key& k) const {$/;"	f	class:compact_map_base
lower_bound	compact_map.h	/^  iterator lower_bound(const Key& k) {$/;"	f	class:compact_map_base
lower_bound	compact_set.h	/^  const_iterator lower_bound(const T& t) const {$/;"	f	class:compact_set_base
lower_bound	compact_set.h	/^  iterator lower_bound(const T& t) {$/;"	f	class:compact_set_base
lower_bound	cpp-btree/btree.h	/^  const_iterator lower_bound(const key_type &key) const {$/;"	f	class:btree::btree
lower_bound	cpp-btree/btree.h	/^  int lower_bound(const key_type &k, const Compare &comp) const {$/;"	f	class:btree::btree_node
lower_bound	cpp-btree/btree.h	/^  iterator lower_bound(const key_type &key) {$/;"	f	class:btree::btree
lower_bound	cpp-btree/btree.h	/^  static int lower_bound(const K &k, const N &n, Compare comp)  {$/;"	f	struct:btree::btree_binary_search_plain_compare
lower_bound	cpp-btree/btree.h	/^  static int lower_bound(const K &k, const N &n, Compare comp)  {$/;"	f	struct:btree::btree_linear_search_plain_compare
lower_bound	cpp-btree/btree.h	/^  static int lower_bound(const K &k, const N &n, CompareTo comp)  {$/;"	f	struct:btree::btree_binary_search_compare_to
lower_bound	cpp-btree/btree.h	/^  static int lower_bound(const K &k, const N &n, CompareTo comp)  {$/;"	f	struct:btree::btree_linear_search_compare_to
lower_bound	cpp-btree/btree_container.h	/^  const_iterator lower_bound(const key_type &key) const {$/;"	f	class:btree::btree_container
lower_bound	cpp-btree/btree_container.h	/^  iterator lower_bound(const key_type &key) {$/;"	f	class:btree::btree_container
lower_bound	interval_set.h	/^  typename interval_set<T,Map>::const_iterator lower_bound(T start) const {$/;"	f	class:interval_set
lower_bound	interval_set.h	/^  typename interval_set<T,Map>::iterator lower_bound(T start) {$/;"	f	class:interval_set
lru	lru.h	/^  class LRU *lru;$/;"	m	class:LRUObject	typeref:class:LRUObject::LRU
lru_bottouch	lru.h	/^  bool lru_bottouch(LRUObject *o) {$/;"	f	class:LRU
lru_clear	lru.h	/^  void lru_clear() {$/;"	f	class:LRU
lru_expire	lru.h	/^  LRUObject *lru_expire() {$/;"	f	class:LRU
lru_get_bot	lru.h	/^  uint64_t lru_get_bot() const{ return bottom.size(); }$/;"	f	class:LRU
lru_get_next_expire	lru.h	/^  LRUObject *lru_get_next_expire() {$/;"	f	class:LRU
lru_get_num_pinned	lru.h	/^  uint64_t lru_get_num_pinned() const { return num_pinned; }$/;"	f	class:LRU
lru_get_pintail	lru.h	/^  uint64_t lru_get_pintail() const { return pintail.size(); }$/;"	f	class:LRU
lru_get_size	lru.h	/^  uint64_t lru_get_size() const { return lru_get_top()+lru_get_bot()+lru_get_pintail(); }$/;"	f	class:LRU
lru_get_top	lru.h	/^  uint64_t lru_get_top() const { return top.size(); }$/;"	f	class:LRU
lru_insert_bot	lru.h	/^  void lru_insert_bot(LRUObject *o) {$/;"	f	class:LRU
lru_insert_mid	lru.h	/^  void lru_insert_mid(LRUObject *o) {$/;"	f	class:LRU
lru_insert_top	lru.h	/^  void lru_insert_top(LRUObject *o) {$/;"	f	class:LRU
lru_is_expireable	lru.h	/^  bool lru_is_expireable() const { return !lru_pinned; }$/;"	f	class:LRUObject
lru_link	lru.h	/^  xlist<LRUObject *>::item lru_link;$/;"	m	class:LRUObject
lru_midtouch	lru.h	/^  bool lru_midtouch(LRUObject *o) {$/;"	f	class:LRU
lru_pin	lru.h	/^inline void LRUObject::lru_pin() {$/;"	f	class:LRUObject
lru_pinned	lru.h	/^  bool lru_pinned;$/;"	m	class:LRUObject
lru_remove	lru.h	/^  LRUObject *lru_remove(LRUObject *o) {$/;"	f	class:LRU
lru_set_midpoint	lru.h	/^  void lru_set_midpoint(double f) { midpoint = fmin(1.0, fmax(0.0, f)); }$/;"	f	class:LRU
lru_status	lru.h	/^  void lru_status() {$/;"	f	class:LRU
lru_touch	lru.h	/^  bool lru_touch(LRUObject *o) {$/;"	f	class:LRU
lru_touch_entire_pintail	lru.h	/^  void lru_touch_entire_pintail() {$/;"	f	class:LRU
lru_unpin	lru.h	/^inline void LRUObject::lru_unpin() {$/;"	f	class:LRUObject
ls	buffer.h	/^      list_t* ls;  \/\/ meh.. just here to avoid an extra pointer dereference..$/;"	m	class:ceph::CEPH_BUFFER_API::list::iterator_impl
ls	rados/buffer.h	/^      list_t* ls;  \/\/ meh.. just here to avoid an extra pointer dereference..$/;"	m	class:ceph::CEPH_BUFFER_API::list::iterator_impl
lseek64	compat.h	125;"	d
ltstr	types.h	/^struct ltstr$/;"	s
m	interval_set.h	/^  Map m;   \/\/ map start -> len$/;"	m	class:interval_set
m_callback	Context.h	/^  boost::function<void(int)> m_callback;$/;"	m	class:FunctionContext
make_child	frag.h	/^  frag_t make_child(int i, int nb) const {$/;"	f	class:frag_t
make_container_context	Context.h	/^ContainerContext<T> *make_container_context(T &&t) {$/;"	f
make_gen_lambda_context	Context.h	/^GenContextURef<T> make_gen_lambda_context(F &&f) {$/;"	f
make_lambda_context	Context.h	/^LambdaContext<T> *make_lambda_context(T &&t) {$/;"	f
make_root	cpp-btree/btree.h	/^  void make_root() {$/;"	f	class:btree::btree_node
make_scope_guard	scope_guard.h	/^scope_guard<F> make_scope_guard(F &&f) {$/;"	f
make_shareable	buffer.h	/^    void make_shareable() {$/;"	f	class:ceph::CEPH_BUFFER_API::list
make_shareable	rados/buffer.h	/^    void make_shareable() {$/;"	f	class:ceph::CEPH_BUFFER_API::list
malformed_input	buffer.h	/^    explicit malformed_input(const std::string& w) {$/;"	f	struct:ceph::CEPH_BUFFER_API::malformed_input
malformed_input	buffer.h	/^  struct malformed_input : public error {$/;"	s	namespace:ceph::CEPH_BUFFER_API
malformed_input	rados/buffer.h	/^    explicit malformed_input(const std::string& w) {$/;"	f	struct:ceph::CEPH_BUFFER_API::malformed_input
malformed_input	rados/buffer.h	/^  struct malformed_input : public error {$/;"	s	namespace:ceph::CEPH_BUFFER_API
map	compact_map.h	/^    const compact_map_base *map;$/;"	m	class:compact_map_base::const_iterator_base
map	compact_map.h	/^    const compact_map_base* map;$/;"	m	class:compact_map_base::iterator_base
map	compact_map.h	/^  std::unique_ptr<Map> map;$/;"	m	class:compact_map_base
map_begin	rangeset.h	/^  map_iterator map_begin() {$/;"	f	class:rangeset
map_end	rangeset.h	/^  map_iterator map_end() {$/;"	f	class:rangeset
map_insert	rangeset.h	/^  void map_insert(T v1, T v2) {$/;"	f	class:rangeset
map_iterator	rangeset.h	/^  typedef typename map<T,T>::iterator map_iterator;$/;"	t	class:rangeset
map_size	rangeset.h	/^  int map_size() {$/;"	f	class:rangeset
mapit	rangeset.h	/^  typedef typename map<T,T>::iterator mapit;$/;"	t	struct:_rangeset_base
maplike_details	denc.h	/^  struct maplike_details : public container_details_base<Container> {$/;"	s	namespace:_denc
mapped_type	cpp-btree/btree.h	/^  typedef Data mapped_type;$/;"	t	struct:btree::btree_map_params
mapped_type	cpp-btree/btree.h	/^  typedef std::false_type mapped_type;$/;"	t	struct:btree::btree_set_params
mapped_type	cpp-btree/btree.h	/^  typedef typename Params::mapped_type mapped_type;$/;"	t	class:btree::btree
mapped_type	cpp-btree/btree_container.h	/^  typedef typename Tree::mapped_type mapped_type;$/;"	t	class:btree::btree_map_container
mapped_type	cpp-btree/btree_map.h	/^  typedef typename btree_type::mapped_type mapped_type;$/;"	t	class:btree::btree_multimap
mask	CompatSet.h	/^    uint64_t mask;$/;"	m	class:CompatSet::FeatureSet
mask	ceph_fs.h	/^		__le32 mask;                 \/* CEPH_CAP_* *\/$/;"	m	struct:ceph_mds_request_args::__anon56
mask	ceph_fs.h	/^		__le32 mask;                 \/* CEPH_CAP_* *\/$/;"	m	struct:ceph_mds_request_args::__anon61
mask	ceph_fs.h	/^		__le32 mask;                 \/* CEPH_CAP_* *\/$/;"	m	struct:ceph_mds_request_args_legacy::__anon47
mask	ceph_fs.h	/^		__le32 mask;                 \/* CEPH_CAP_* *\/$/;"	m	struct:ceph_mds_request_args_legacy::__anon52
mask	ceph_fs.h	/^		__le32 mask;                 \/* CEPH_SETATTR_* *\/$/;"	m	struct:ceph_mds_request_args::__anon57
mask	ceph_fs.h	/^		__le32 mask;                 \/* CEPH_SETATTR_* *\/$/;"	m	struct:ceph_mds_request_args_legacy::__anon48
mask	ceph_fs.h	/^	__le16 mask;            \/* lease type(s) *\/$/;"	m	struct:ceph_mds_reply_lease
mask	ceph_fs.h	/^	__le16 mask;            \/* which lease *\/$/;"	m	struct:ceph_mds_lease
mask	frag.h	/^  unsigned mask() const { return ceph_frag_mask(_enc); }$/;"	f	class:frag_t
mask_shift	frag.h	/^  unsigned mask_shift() const { return ceph_frag_mask_shift(_enc); }$/;"	f	class:frag_t
max	rados.h	/^			__le64 max;     \/* max data in reply *\/$/;"	m	struct:ceph_osd_op::__anon13::__anon23
max_bytes	ceph_fs.h	/^		__le32 max_bytes;$/;"	m	struct:ceph_mds_request_args::__anon58
max_bytes	ceph_fs.h	/^		__le32 max_bytes;$/;"	m	struct:ceph_mds_request_args_legacy::__anon49
max_caps	ceph_fs.h	/^	__le32 max_caps, max_leases;$/;"	m	struct:ceph_mds_session_head
max_count	cpp-btree/btree.h	/^    field_type max_count;$/;"	m	struct:btree::btree_node::base_fields
max_count	cpp-btree/btree.h	/^  int max_count() const { return fields_.max_count; }$/;"	f	class:btree::btree_node
max_entries	ceph_fs.h	/^		__le32 max_entries;          \/* how many dentries to grab *\/$/;"	m	struct:ceph_mds_request_args::__anon58
max_entries	ceph_fs.h	/^		__le32 max_entries;          \/* how many dentries to grab *\/$/;"	m	struct:ceph_mds_request_args_legacy::__anon49
max_id	rbd_types.h	/^	__le64 max_id;$/;"	m	struct:rbd_info
max_leases	ceph_fs.h	/^	__le32 max_caps, max_leases;$/;"	m	struct:ceph_mds_session_head
max_size	ceph_fs.h	/^			__le64 size, max_size, truncate_size;$/;"	m	struct:ceph_mds_caps_body_legacy::__anon66::__anon67
max_size	cpp-btree/btree.h	/^  size_type max_size() const { return std::numeric_limits<size_type>::max(); }$/;"	f	class:btree::btree
max_size	cpp-btree/btree_container.h	/^  size_type max_size() const { return tree_.max_size(); }$/;"	f	class:btree::btree_container
maybe_inline_memcpy	inline_memory.h	/^void *maybe_inline_memcpy(void *dest, const void *src, size_t l,$/;"	f
maybe_inline_memcpy	inline_memory.h	66;"	d
maybe_inline_memcpy	rados/inline_memory.h	/^void *maybe_inline_memcpy(void *dest, const void *src, size_t l,$/;"	f
maybe_inline_memcpy	rados/inline_memory.h	66;"	d
mds	ceph_fs.h	/^	__le32 mds;$/;"	m	struct:ceph_mds_cap_peer
mdsmap_epoch	ceph_fs.h	/^	__le32 mdsmap_epoch;           \/* on client *\/$/;"	m	struct:ceph_mds_request_head
mdsmap_epoch	ceph_fs.h	/^	__le32 mdsmap_epoch;           \/* on client *\/$/;"	m	struct:ceph_mds_request_head_legacy
mdsmap_epoch	ceph_fs.h	/^	__le32 mdsmap_epoch;$/;"	m	struct:ceph_mds_reply_head
mem_is_zero	inline_memory.h	/^bool mem_is_zero(const char *data, size_t len)$/;"	f
mem_is_zero	inline_memory.h	/^static inline bool mem_is_zero(const char *data, size_t len) {$/;"	f
mem_is_zero	rados/inline_memory.h	/^bool mem_is_zero(const char *data, size_t len)$/;"	f
mem_is_zero	rados/inline_memory.h	/^static inline bool mem_is_zero(const char *data, size_t len) {$/;"	f
member_offset	elist.h	29;"	d
mempool	mempool.h	/^namespace mempool {$/;"	n
merge	CompatSet.h	/^  bool merge(CompatSet const & other) {$/;"	f	struct:CompatSet
merge	frag.h	/^  void merge(frag_t x, int b, bool simplify=true) {$/;"	f	class:fragtree_t
method_len	rados.h	/^			__u8 method_len;$/;"	m	struct:ceph_osd_op::__anon13::__anon16
middle_crc	msgr.h	/^	__le32 front_crc, middle_crc, data_crc;$/;"	m	struct:ceph_msg_footer
middle_crc	msgr.h	/^	__le32 front_crc, middle_crc, data_crc;$/;"	m	struct:ceph_msg_footer_old
middle_len	msgr.h	/^	__le32 middle_len;\/* bytes in middle payload *\/$/;"	m	struct:ceph_msg_header
middle_len	msgr.h	/^	__le32 middle_len;\/* bytes in middle payload *\/$/;"	m	struct:ceph_msg_header_old
midpoint	lru.h	/^  double midpoint;$/;"	m	class:LRU
migrate_seq	ceph_fs.h	/^	__le32 migrate_seq, seq;$/;"	m	struct:ceph_mds_cap_item
migrate_seq	ceph_fs.h	/^	__le32 migrate_seq;$/;"	m	struct:ceph_mds_caps_head
min_alloc	buffer.h	/^      unsigned min_alloc;$/;"	m	class:ceph::CEPH_BUFFER_API::list::page_aligned_appender
min_alloc	rados/buffer.h	/^      unsigned min_alloc;$/;"	m	class:ceph::CEPH_BUFFER_API::list::page_aligned_appender
mirror_image_info_t	rbd/librbd.hpp	/^  } mirror_image_info_t;$/;"	t	namespace:librbd	typeref:struct:librbd::__anon72
mirror_image_state_t	rbd/librbd.hpp	/^  typedef rbd_mirror_image_state_t mirror_image_state_t;$/;"	t	namespace:librbd
mirror_image_status_state_t	rbd/librbd.hpp	/^  typedef rbd_mirror_image_status_state_t mirror_image_status_state_t;$/;"	t	namespace:librbd
mirror_image_status_t	rbd/librbd.hpp	/^  } mirror_image_status_t;$/;"	t	namespace:librbd	typeref:struct:librbd::__anon73
mirror_peer_t	rbd/librbd.hpp	/^  } mirror_peer_t;$/;"	t	namespace:librbd	typeref:struct:librbd::__anon71
missing	rados/rados_types.hpp	/^  std::vector<snap_t> missing;$/;"	m	struct:inconsistent_snapset_t
mkdir	ceph_fs.h	/^	} __attribute__ ((packed)) mkdir;$/;"	m	union:ceph_mds_request_args	typeref:struct:ceph_mds_request_args::__anon60
mkdir	ceph_fs.h	/^	} __attribute__ ((packed)) mkdir;$/;"	m	union:ceph_mds_request_args_legacy	typeref:struct:ceph_mds_request_args_legacy::__anon51
mknod	ceph_fs.h	/^	} __attribute__ ((packed)) mknod;$/;"	m	union:ceph_mds_request_args	typeref:struct:ceph_mds_request_args::__anon59
mknod	ceph_fs.h	/^	} __attribute__ ((packed)) mknod;$/;"	m	union:ceph_mds_request_args_legacy	typeref:struct:ceph_mds_request_args_legacy::__anon50
mode	ceph_fs.h	/^		__le32 mode;$/;"	m	struct:ceph_mds_request_args::__anon57
mode	ceph_fs.h	/^		__le32 mode;$/;"	m	struct:ceph_mds_request_args::__anon59
mode	ceph_fs.h	/^		__le32 mode;$/;"	m	struct:ceph_mds_request_args::__anon60
mode	ceph_fs.h	/^		__le32 mode;$/;"	m	struct:ceph_mds_request_args::__anon61
mode	ceph_fs.h	/^		__le32 mode;$/;"	m	struct:ceph_mds_request_args_legacy::__anon48
mode	ceph_fs.h	/^		__le32 mode;$/;"	m	struct:ceph_mds_request_args_legacy::__anon50
mode	ceph_fs.h	/^		__le32 mode;$/;"	m	struct:ceph_mds_request_args_legacy::__anon51
mode	ceph_fs.h	/^		__le32 mode;$/;"	m	struct:ceph_mds_request_args_legacy::__anon52
mode	ceph_fs.h	/^	__le32 uid, gid, mode;$/;"	m	struct:ceph_mds_caps_head
mode	elist.h	/^    mode_t mode;$/;"	m	class:elist::iterator
mode_t	elist.h	/^  enum mode_t {$/;"	g	class:elist
monhdr	ceph_fs.h	/^	struct ceph_mon_request_header monhdr;$/;"	m	struct:ceph_client_mount	typeref:struct:ceph_client_mount::ceph_mon_request_header
monhdr	ceph_fs.h	/^	struct ceph_mon_request_header monhdr;$/;"	m	struct:ceph_mds_getmap	typeref:struct:ceph_mds_getmap::ceph_mon_request_header
monhdr	ceph_fs.h	/^	struct ceph_mon_request_header monhdr;$/;"	m	struct:ceph_mon_poolop	typeref:struct:ceph_mon_poolop::ceph_mon_request_header
monhdr	ceph_fs.h	/^	struct ceph_mon_request_header monhdr;$/;"	m	struct:ceph_mon_poolop_reply	typeref:struct:ceph_mon_poolop_reply::ceph_mon_request_header
monhdr	ceph_fs.h	/^	struct ceph_mon_request_header monhdr;$/;"	m	struct:ceph_mon_statfs	typeref:struct:ceph_mon_statfs::ceph_mon_request_header
monhdr	ceph_fs.h	/^	struct ceph_mon_request_header monhdr;$/;"	m	struct:ceph_osd_getmap	typeref:struct:ceph_osd_getmap::ceph_mon_request_header
move_into	interval_set.h	/^  void move_into(Map& other) {$/;"	f	class:interval_set
move_to_back	xlist.h	/^    void move_to_back() {$/;"	f	struct:xlist::item
move_to_front	xlist.h	/^    void move_to_front() {$/;"	f	struct:xlist::item
mseq	ceph_fs.h	/^	__le32 mseq;$/;"	m	struct:ceph_mds_cap_peer
mseq	ceph_fs.h	/^	__le32 seq, issue_seq, mseq;$/;"	m	struct:ceph_mds_request_release
mseq	ceph_fs.h	/^	__le32 seq, mseq;$/;"	m	struct:ceph_mds_reply_cap
mswab	byteorder.h	/^inline T mswab(T val) {$/;"	f
mtime	ceph_fs.h	/^			struct ceph_timespec mtime, atime, ctime;$/;"	m	struct:ceph_mds_caps_body_legacy::__anon66::__anon67	typeref:struct:ceph_mds_caps_body_legacy::__anon66::__anon67::ceph_timespec
mtime	ceph_fs.h	/^		struct ceph_timespec mtime;$/;"	m	struct:ceph_mds_request_args::__anon57	typeref:struct:ceph_mds_request_args::__anon57::ceph_timespec
mtime	ceph_fs.h	/^		struct ceph_timespec mtime;$/;"	m	struct:ceph_mds_request_args_legacy::__anon48	typeref:struct:ceph_mds_request_args_legacy::__anon48::ceph_timespec
mtime	ceph_fs.h	/^	struct ceph_timespec mtime, atime;$/;"	m	struct:ceph_mds_cap_reconnect_v1	typeref:struct:ceph_mds_cap_reconnect_v1::ceph_timespec
mutable_child	cpp-btree/btree.h	/^  btree_node** mutable_child(int i) { return &fields_.children[i]; }$/;"	f	class:btree::btree_node
mutable_internal_allocator	cpp-btree/btree.h	/^  internal_allocator_type* mutable_internal_allocator() {$/;"	f	class:btree::btree
mutable_key_comp	cpp-btree/btree.h	/^  key_compare* mutable_key_comp() {$/;"	f	class:btree::btree
mutable_rightmost	cpp-btree/btree.h	/^  btree_node** mutable_rightmost() { return &fields_.rightmost; }$/;"	f	class:btree::btree_node
mutable_rightmost	cpp-btree/btree.h	/^  node_type** mutable_rightmost() { return root()->mutable_rightmost(); }$/;"	f	class:btree::btree
mutable_root	cpp-btree/btree.h	/^  node_type** mutable_root() { return &root_.data; }$/;"	f	class:btree::btree
mutable_size	cpp-btree/btree.h	/^  size_type* mutable_size() { return &fields_.size; }$/;"	f	class:btree::btree_node
mutable_size	cpp-btree/btree.h	/^  size_type* mutable_size() { return root()->mutable_size(); }$/;"	f	class:btree::btree
mutable_value	cpp-btree/btree.h	/^  mutable_value_type* mutable_value(int i) {$/;"	f	class:btree::btree_node
mutable_value_type	cpp-btree/btree.h	/^  typedef std::pair<Key, data_type> mutable_value_type;$/;"	t	struct:btree::btree_map_params
mutable_value_type	cpp-btree/btree.h	/^  typedef typename Params::mutable_value_type mutable_value_type;$/;"	t	class:btree::btree_node
mutable_value_type	cpp-btree/btree.h	/^  typedef value_type mutable_value_type;$/;"	t	struct:btree::btree_set_params
mydout	Context.h	29;"	d
mydout	Context.h	499;"	d
name	CompatSet.h	/^    string name;$/;"	m	struct:CompatSet::Feature
name	msgr.h	/^	struct ceph_entity_name name;$/;"	m	struct:ceph_entity_inst	typeref:struct:ceph_entity_inst::ceph_entity_name
name	object.h	/^  string name; \/\/ 对象名$/;"	m	struct:object_t
name	rados/rados_types.hpp	/^  std::string name;$/;"	m	struct:librados::object_id_t
name	rbd/librbd.h	/^  char *name;$/;"	m	struct:__anon83
name	rbd/librbd.h	/^  char *name;$/;"	m	struct:__anon87
name	rbd/librbd.h	/^  const char *name;$/;"	m	struct:__anon75
name	rbd/librbd.hpp	/^    std::string name;$/;"	m	struct:librbd::__anon69
name	rbd/librbd.hpp	/^    std::string name;$/;"	m	struct:librbd::__anon73
name	rbd/librbd.hpp	/^    std::string name;$/;"	m	struct:librbd::__anon74
name_len	ceph_fs.h	/^	__le32 name_len;$/;"	m	struct:ceph_mon_poolop
name_len	rados.h	/^			__le32 name_len;$/;"	m	struct:ceph_osd_op::__anon13::__anon15
names	CompatSet.h	/^    map <uint64_t,string> names;$/;"	m	class:CompatSet::FeatureSet
ndist	ceph_fs.h	/^	__le32 ndist;           \/* number of mds' this is replicated on *\/$/;"	m	struct:ceph_mds_reply_dirfrag
need_contiguous	denc.h	/^    static constexpr bool need_contiguous = false;$/;"	m	struct:_denc::tuple_traits
need_contiguous	denc.h	/^    static constexpr bool need_contiguous = traits::need_contiguous;$/;"	m	struct:_denc::container_base
need_contiguous	denc.h	/^    static constexpr bool need_contiguous =$/;"	m	struct:_denc::tuple_traits
need_contiguous	denc.h	/^  static constexpr bool need_contiguous = (a_traits::need_contiguous ||$/;"	m	struct:denc_traits
need_contiguous	denc.h	/^  static constexpr bool need_contiguous = false;$/;"	m	struct:denc_traits
need_contiguous	denc.h	/^  static constexpr bool need_contiguous = traits::need_contiguous;$/;"	m	struct:denc_traits
need_contiguous	denc.h	/^  static constexpr bool need_contiguous = true;$/;"	m	struct:denc_traits
need_contiguous	fs_types.h	/^  static constexpr bool need_contiguous = true;$/;"	m	struct:denc_traits
need_contiguous	health.h	/^  static constexpr bool need_contiguous = false;$/;"	m	struct:denc_traits
need_contiguous	interval_set.h	/^  static constexpr bool need_contiguous = denc_traits<T,Map>::need_contiguous;$/;"	m	struct:denc_traits
need_contiguous	object.h	/^  static constexpr bool need_contiguous = true;$/;"	m	struct:denc_traits
new_internal_node	cpp-btree/btree.h	/^  node_type* new_internal_node(node_type *parent) {$/;"	f	class:btree::btree
new_internal_root_node	cpp-btree/btree.h	/^  node_type* new_internal_root_node() {$/;"	f	class:btree::btree
new_leaf_node	cpp-btree/btree.h	/^  node_type* new_leaf_node(node_type *parent) {$/;"	f	class:btree::btree
new_leaf_root_node	cpp-btree/btree.h	/^  node_type* new_leaf_root_node(int max_count) {$/;"	f	class:btree::btree
new_sub	Context.h	/^  ContextType *new_sub() {$/;"	f	class:C_GatherBase
new_sub	Context.h	/^  ContextType *new_sub() {$/;"	f	class:C_GatherBuilderBase
next	elist.h	/^    item *cur, *next;$/;"	m	class:elist::iterator
next	frag.h	/^  frag_t next() const {$/;"	f	class:frag_t
nlink	ceph_fs.h	/^	__le32 nlink;$/;"	m	struct:ceph_mds_caps_head
node	cpp-btree/btree.h	/^  Node *node;$/;"	m	struct:btree::btree_iterator
node_count_type	cpp-btree/btree.h	/^    uint8_t>::type node_count_type;$/;"	t	struct:btree::btree_common_params
node_stats	cpp-btree/btree.h	/^    node_stats(ssize_t l, ssize_t i)$/;"	f	struct:btree::btree::node_stats
node_stats	cpp-btree/btree.h	/^  struct node_stats {$/;"	s	class:btree::btree
node_type	cpp-btree/btree.h	/^  typedef Node node_type;$/;"	t	struct:btree::btree_iterator
node_type	cpp-btree/btree.h	/^  typedef btree_node<Params> node_type;$/;"	t	class:btree::btree
nodes	cpp-btree/btree.h	/^  size_type nodes() const {$/;"	f	class:btree::btree
nodes	cpp-btree/btree_container.h	/^  size_type nodes() const { return tree_.nodes(); }$/;"	f	class:btree::btree_container
noexcept	buffer.h	/^    ptr& operator= (ptr&& p) noexcept;$/;"	m	class:ceph::CEPH_BUFFER_API::ptr
noexcept	buffer.h	/^    ptr(ptr&& p) noexcept;$/;"	m	class:ceph::CEPH_BUFFER_API::ptr
noexcept	rados/buffer.h	/^    ptr& operator= (ptr&& p) noexcept;$/;"	m	class:ceph::CEPH_BUFFER_API::ptr
noexcept	rados/buffer.h	/^    ptr(ptr&& p) noexcept;$/;"	m	class:ceph::CEPH_BUFFER_API::ptr
nonce	msgr.h	/^	__le32 nonce;  \/* unique id for process (e.g. pid) *\/$/;"	m	struct:ceph_entity_addr
normal_node	cpp-btree/btree.h	/^  typedef typename std::remove_const<Node>::type normal_node;$/;"	t	struct:btree::btree_iterator
normal_pointer	cpp-btree/btree.h	/^  typedef typename params_type::pointer normal_pointer;$/;"	t	struct:btree::btree_iterator
normal_reference	cpp-btree/btree.h	/^  typedef typename params_type::reference normal_reference;$/;"	t	struct:btree::btree_iterator
normalize	Distribution.h	/^  float normalize() {$/;"	f	class:Distribution
normalize	utime.h	/^  void normalize() {$/;"	f	class:utime_t
notify	rados.h	/^		} __attribute__ ((packed)) notify;$/;"	m	union:ceph_osd_op::__anon13	typeref:struct:ceph_osd_op::__anon13::__anon20
nsec	utime.h	/^  int           nsec() const { return tv.tv_nsec; }$/;"	f	class:utime_t
nsec_ref	utime.h	/^  __u32&         nsec_ref() { return tv.tv_nsec; }$/;"	f	class:utime_t
nspace	rados/librados.h	/^  char *nspace;$/;"	m	struct:rados_object_list_item
nspace	rados/librados.hpp	/^    std::string nspace;$/;"	m	class:librados::ObjectItem
nspace	rados/rados_types.hpp	/^  std::string nspace;$/;"	m	struct:librados::object_id_t
nspace_length	rados/librados.h	/^  size_t nspace_length;$/;"	m	struct:rados_object_list_item
nsplits	ceph_fs.h	/^	__le32 nsplits;                \/* num ceph_frag_tree_split records *\/$/;"	m	struct:ceph_frag_tree_head
num	ceph_fs.h	/^	__le32 num;                \/* number of cap_items that follow *\/$/;"	m	struct:ceph_mds_cap_release
num	msgr.h	/^	__le64 num;$/;"	m	struct:ceph_entity_name
num_bytes	rados/librados.h	/^  uint64_t num_bytes;$/;"	m	struct:rados_pool_stat_t
num_fwd	ceph_fs.h	/^	__u8 num_retry, num_fwd;       \/* count retry, fwd attempts *\/$/;"	m	struct:ceph_mds_request_head
num_fwd	ceph_fs.h	/^	__u8 num_retry, num_fwd;       \/* count retry, fwd attempts *\/$/;"	m	struct:ceph_mds_request_head_legacy
num_intervals	interval_set.h	/^  int num_intervals() const$/;"	f	class:interval_set
num_kb	rados/librados.h	/^  uint64_t num_kb;$/;"	m	struct:rados_pool_stat_t
num_object_clones	rados/librados.h	/^  uint64_t num_object_clones;$/;"	m	struct:rados_pool_stat_t
num_object_copies	rados/librados.h	/^  uint64_t num_object_copies;$/;"	m	struct:rados_pool_stat_t
num_objects	ceph_fs.h	/^	__le64 num_objects;$/;"	m	struct:ceph_statfs
num_objects	rados/librados.h	/^  uint64_t num_objects;$/;"	m	struct:rados_cluster_stat_t
num_objects	rados/librados.h	/^  uint64_t num_objects;$/;"	m	struct:rados_pool_stat_t
num_objects_degraded	rados/librados.h	/^  uint64_t num_objects_degraded;$/;"	m	struct:rados_pool_stat_t
num_objects_missing_on_primary	rados/librados.h	/^  uint64_t num_objects_missing_on_primary;$/;"	m	struct:rados_pool_stat_t
num_objects_unfound	rados/librados.h	/^  uint64_t num_objects_unfound;$/;"	m	struct:rados_pool_stat_t
num_objs	rbd/librbd.h	/^  uint64_t num_objs;$/;"	m	struct:__anon77
num_ops	rados.h	/^	__le32 num_ops;$/;"	m	struct:ceph_osd_reply_head
num_pinned	lru.h	/^  uint64_t num_pinned;$/;"	m	class:LRU
num_pools	mempool.h	/^  num_pools        \/\/ Must be last.$/;"	e	enum:mempool::pool_index_t
num_prior_parent_snaps	ceph_fs.h	/^	__le32 num_prior_parent_snaps;$/;"	m	struct:ceph_mds_snap_realm
num_rd	rados/librados.h	/^  uint64_t num_rd;$/;"	m	struct:rados_pool_stat_t
num_rd_kb	rados/librados.h	/^  uint64_t num_rd_kb;$/;"	m	struct:rados_pool_stat_t
num_releases	ceph_fs.h	/^	__le16 num_releases;           \/* # include cap\/lease release records *\/$/;"	m	struct:ceph_mds_request_head
num_releases	ceph_fs.h	/^	__le16 num_releases;           \/* # include cap\/lease release records *\/$/;"	m	struct:ceph_mds_request_head_legacy
num_retry	ceph_fs.h	/^	__u8 num_retry, num_fwd;       \/* count retry, fwd attempts *\/$/;"	m	struct:ceph_mds_request_head
num_retry	ceph_fs.h	/^	__u8 num_retry, num_fwd;       \/* count retry, fwd attempts *\/$/;"	m	struct:ceph_mds_request_head_legacy
num_shard_bits	mempool.h	/^  num_shard_bits = 5$/;"	e	enum:mempool::__anon88
num_shards	mempool.h	/^  num_shards = 1 << num_shard_bits$/;"	e	enum:mempool::__anon89
num_snaps	ceph_fs.h	/^	__le32 num_snaps;$/;"	m	struct:ceph_mds_snap_realm
num_split_inos	ceph_fs.h	/^	__le32 num_split_inos;    \/* # inos belonging to new child realm *\/$/;"	m	struct:ceph_mds_snap_head
num_split_realms	ceph_fs.h	/^	__le32 num_split_realms;  \/* # child realms udner new child realm *\/$/;"	m	struct:ceph_mds_snap_head
num_subs_created	Context.h	/^  int num_subs_created() {$/;"	f	class:C_GatherBuilderBase
num_subs_remaining	Context.h	/^  int num_subs_remaining() {$/;"	f	class:C_GatherBuilderBase
num_wr	rados/librados.h	/^  uint64_t num_wr;$/;"	m	struct:rados_pool_stat_t
num_wr_kb	rados/librados.h	/^  uint64_t num_wr_kb;$/;"	m	struct:rados_pool_stat_t
obj	Context.h	/^  T obj;$/;"	m	class:ContainerContext
obj_err_t	rados/rados_types.hpp	/^struct obj_err_t {$/;"	s	namespace:librados
obj_size	rbd/librbd.h	/^  uint64_t obj_size;$/;"	m	struct:__anon77
obj_watch_t	rados/rados_types.h	/^struct obj_watch_t {$/;"	s
object	rados/rados_types.hpp	/^  object_id_t object;$/;"	m	struct:inconsistent_obj_t
object	rados/rados_types.hpp	/^  object_id_t object;$/;"	m	struct:inconsistent_snapset_t
object	rados/rgw_file.h	/^  uint64_t object;$/;"	m	struct:rgw_fh_hk
object_id_t	rados/rados_types.hpp	/^  object_id_t(const std::string& name,$/;"	f	struct:librados::object_id_t
object_id_t	rados/rados_types.hpp	/^struct object_id_t {$/;"	s	namespace:librados
object_len	rados.h	/^	__le32 object_len;                \/* length of object name *\/$/;"	m	struct:ceph_osd_reply_head
object_size	ceph_fs.h	/^		__le32 object_size;$/;"	m	struct:ceph_mds_request_args::__anon61
object_size	ceph_fs.h	/^		__le32 object_size;$/;"	m	struct:ceph_mds_request_args_legacy::__anon52
object_size	fs_types.h	/^  uint32_t object_size;   \/\/\/< until objects are this big$/;"	m	struct:file_layout_t
object_t	object.h	/^  object_t() {}$/;"	f	struct:object_t
object_t	object.h	/^  object_t(const char *s) : name(s) {}$/;"	f	struct:object_t
object_t	object.h	/^  object_t(const string& s) : name(s) {}$/;"	f	struct:object_t
object_t	object.h	/^struct object_t { \/\/ 本地文件系统的一个文件对象$/;"	s
off	buffer.h	/^      unsigned off; \/\/ in bl$/;"	m	class:ceph::CEPH_BUFFER_API::list::iterator_impl
off	rados/buffer.h	/^      unsigned off; \/\/ in bl$/;"	m	class:ceph::CEPH_BUFFER_API::list::iterator_impl
off64_t	types.h	/^typedef long long off64_t;$/;"	t
off64_t	types.h	/^typedef off_t off64_t;$/;"	t
offset	buffer.h	/^      size_t offset;$/;"	m	class:ceph::CEPH_BUFFER_API::list::page_aligned_appender
offset	buffer.h	/^    unsigned offset() const { return _off; }$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
offset	rados.h	/^			__le64 offset, length;$/;"	m	struct:ceph_osd_op::__anon13::__anon14
offset	rados.h	/^			__le64 offset, length;$/;"	m	struct:ceph_osd_op::__anon13::__anon22
offset	rados.h	/^			__le64 offset;$/;"	m	struct:ceph_osd_op::__anon13::__anon28
offset	rados.h	/^			__le64 offset;$/;"	m	struct:ceph_osd_op::__anon13::__anon29
offset	rados/buffer.h	/^      size_t offset;$/;"	m	class:ceph::CEPH_BUFFER_API::list::page_aligned_appender
offset	rados/buffer.h	/^    unsigned offset() const { return _off; }$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
offset_hash	ceph_fs.h	/^               __le32 offset_hash;$/;"	m	struct:ceph_mds_request_args::__anon58
offset_hash	ceph_fs.h	/^               __le32 offset_hash;$/;"	m	struct:ceph_mds_request_args_legacy::__anon49
oi_attr_corrupted	rados/rados_types.hpp	/^  bool oi_attr_corrupted() const {  \/\/ Compatibility$/;"	f	struct:inconsistent_snapset_t
oi_attr_missing	rados/rados_types.hpp	/^  bool oi_attr_missing() const {   \/\/ Compatibility$/;"	f	struct:inconsistent_snapset_t
oid	object.h	/^  object_t oid;$/;"	m	struct:sobject_t
oid	rados/librados.h	/^  char *oid;$/;"	m	struct:rados_object_list_item
oid	rados/librados.hpp	/^    std::string oid;$/;"	m	class:librados::ObjectItem
oid_length	rados/librados.h	/^  size_t oid_length;$/;"	m	struct:rados_object_list_item
ol_pgid	rados.h	/^	struct ceph_pg ol_pgid;   \/* raw pg, with _full_ ps precision. *\/$/;"	m	struct:ceph_object_layout	typeref:struct:ceph_object_layout::ceph_pg
ol_stripe_unit	rados.h	/^	__le32 ol_stripe_unit;    \/* for per-object parity, if any *\/$/;"	m	struct:ceph_object_layout
old_size	ceph_fs.h	/^		__le64 old_size;             \/* if O_TRUNC *\/$/;"	m	struct:ceph_mds_request_args::__anon61
old_size	ceph_fs.h	/^		__le64 old_size;             \/* if O_TRUNC *\/$/;"	m	struct:ceph_mds_request_args_legacy::__anon52
old_size	ceph_fs.h	/^		__le64 size, old_size;       \/* old_size needed by truncate *\/$/;"	m	struct:ceph_mds_request_args::__anon57
old_size	ceph_fs.h	/^		__le64 size, old_size;       \/* old_size needed by truncate *\/$/;"	m	struct:ceph_mds_request_args_legacy::__anon48
oldest_client_tid	ceph_fs.h	/^	__le64 oldest_client_tid;$/;"	m	struct:ceph_mds_request_head
oldest_client_tid	ceph_fs.h	/^	__le64 oldest_client_tid;$/;"	m	struct:ceph_mds_request_head_legacy
omap_digest	rados/rados_types.hpp	/^  uint32_t omap_digest = 0;$/;"	m	struct:librados::shard_info_t
omap_digest_present	rados/rados_types.hpp	/^  bool omap_digest_present = false;$/;"	m	struct:librados::shard_info_t
onfinish	Context.h	/^  ContextType *onfinish;$/;"	m	class:C_GatherBase
op	ceph_fs.h	/^	__le32 op;                     \/* mds op code *\/$/;"	m	struct:ceph_mds_request_head
op	ceph_fs.h	/^	__le32 op;                     \/* mds op code *\/$/;"	m	struct:ceph_mds_request_head_legacy
op	ceph_fs.h	/^	__le32 op;                  \/* CEPH_CAP_OP_* *\/$/;"	m	struct:ceph_mds_caps_head
op	ceph_fs.h	/^	__le32 op;                \/* CEPH_SNAP_OP_* *\/$/;"	m	struct:ceph_mds_snap_head
op	ceph_fs.h	/^	__le32 op;$/;"	m	struct:ceph_mds_reply_head
op	ceph_fs.h	/^	__le32 op;$/;"	m	struct:ceph_mds_session_head
op	ceph_fs.h	/^	__le32 op;$/;"	m	struct:ceph_mon_poolop
op	rados.h	/^			__u8 op;	\/* CEPH_OSD_WATCH_OP_* *\/$/;"	m	struct:ceph_osd_op::__anon13::__anon19
op	rados.h	/^	__le16 op;           \/* CEPH_OSD_OP_* *\/$/;"	m	struct:ceph_osd_op
open	ceph_fs.h	/^	} __attribute__ ((packed)) open;$/;"	m	union:ceph_mds_request_args	typeref:struct:ceph_mds_request_args::__anon61
open	ceph_fs.h	/^	} __attribute__ ((packed)) open;$/;"	m	union:ceph_mds_request_args_legacy	typeref:struct:ceph_mds_request_args_legacy::__anon52
operator !=	alloc_ptr.h	/^    friend bool operator!=(const alloc_ptr& lhs, const alloc_ptr& rhs) {$/;"	f	class:alloc_ptr
operator !=	buffer.h	/^      bool operator!=(const iterator& rhs) const {$/;"	f	class:ceph::CEPH_BUFFER_API::list::iterator
operator !=	buffer.h	/^      friend bool operator!=(const iterator_impl& lhs,$/;"	f	class:ceph::CEPH_BUFFER_API::list::iterator_impl
operator !=	compact_map.h	/^    bool operator!=(const const_iterator_base& o) const {$/;"	f	class:compact_map_base::const_iterator_base
operator !=	compact_map.h	/^    bool operator!=(const iterator_base& o) const {$/;"	f	class:compact_map_base::iterator_base
operator !=	compact_map.h	/^  bool operator!=(const compact_map_base& o) const {$/;"	f	class:compact_map_base
operator !=	compact_set.h	/^    bool operator!=(const iterator_base& o) const {$/;"	f	class:compact_set_base::iterator_base
operator !=	compact_set.h	/^  bool operator!=(const compact_set_base& o) const {$/;"	f	class:compact_set_base
operator !=	cpp-btree/btree.h	/^  bool operator!=(const const_iterator &x) const {$/;"	f	struct:btree::btree_iterator
operator !=	cpp-btree/btree_container.h	/^  bool operator!=(const self_type& other) const {$/;"	f	class:btree::btree_container
operator !=	frag.h	/^inline bool operator!=(const fragtree_t& l, const fragtree_t& r) {$/;"	f
operator !=	interval_set.h	/^        bool operator!=(const const_iterator& rhs) const {$/;"	f	class:interval_set::const_iterator
operator !=	interval_set.h	/^        bool operator!=(const iterator& rhs) const {$/;"	f	class:interval_set::iterator
operator !=	mempool.h	/^  bool operator!=(const pool_allocator&) const { return false; }$/;"	f	class:mempool::pool_allocator
operator !=	object.h	/^inline bool operator!=(const object_t& l, const object_t& r) {$/;"	f
operator !=	object.h	/^inline bool operator!=(const sobject_t &l, const sobject_t &r) {$/;"	f
operator !=	rados/buffer.h	/^      bool operator!=(const iterator& rhs) const {$/;"	f	class:ceph::CEPH_BUFFER_API::list::iterator
operator !=	rados/buffer.h	/^      friend bool operator!=(const iterator_impl& lhs,$/;"	f	class:ceph::CEPH_BUFFER_API::list::iterator_impl
operator !=	rangeset.h	/^  bool operator!=(rangeset_iterator<T> rit) {$/;"	f	class:rangeset_iterator
operator !=	types.h	/^static inline bool operator!=(const client_t& l, const client_t& r) { return l.v != r.v; }$/;"	f
operator !=	utime.h	/^inline bool operator!=(const utime_t& a, const utime_t& b)$/;"	f
operator !=	uuid.h	/^inline bool operator!=(const uuid_d& l, const uuid_d& r) {$/;"	f
operator !=	xlist.h	/^    bool operator!=(const iterator& rhs) const {$/;"	f	class:xlist::iterator
operator &	types.h	/^  int* operator&()      { return &code; }$/;"	f	struct:errorcode32_t
operator ()	blobhash.h	/^  uint32_t operator()(const char *p, unsigned len) {$/;"	f	class:blobhash
operator ()	cpp-btree/btree.h	/^  bool operator()(const Key &a, const Key &b) const {$/;"	f	struct:btree::btree_upper_bound_adapter
operator ()	cpp-btree/btree.h	/^  bool operator()(const Key &x, const Key &y) const {$/;"	f	struct:btree::btree_key_comparer
operator ()	cpp-btree/btree.h	/^  int operator()(const Key &a, const Key &b) const {$/;"	f	struct:btree::btree_upper_bound_compare_to_adapter
operator ()	cpp-btree/btree.h	/^  int operator()(const std::string &a, const std::string &b) const {$/;"	f	struct:btree::btree_key_compare_to_adapter
operator ()	fs_types.h	/^    size_t operator()( const inodeno_t& x ) const$/;"	f	struct:std::hash
operator ()	hash.h	/^  inline size_t operator()(const uint32_t x) const {$/;"	f	struct:rjhash
operator ()	hash.h	/^  inline size_t operator()(const uint64_t x) const {$/;"	f	struct:rjhash
operator ()	mempool.h	/^  std::size_t operator()(const std::type_info& k) const {$/;"	f	struct:mempool::type_info_hash
operator ()	object.h	/^    size_t operator()(const object_t& r) const { $/;"	f	struct:std::hash
operator ()	object.h	/^    size_t operator()(const sobject_t &r) const {$/;"	f	struct:std::hash
operator ()	types.h	/^  bool operator()(const char* s1, const char* s2) const$/;"	f	struct:eqstr
operator ()	types.h	/^  bool operator()(const char* s1, const char* s2) const$/;"	f	struct:ltstr
operator *	alloc_ptr.h	/^    element_type& operator*() const {$/;"	f	class:alloc_ptr
operator *	compact_map.h	/^    const std::pair<const Key,T>& operator*() {$/;"	f	class:compact_map_base::const_iterator_base
operator *	compact_map.h	/^    std::pair<const Key,T>& operator*() {$/;"	f	class:compact_map_base::iterator_base
operator *	compact_set.h	/^    const T& operator*() {$/;"	f	class:compact_set_base::iterator_base
operator *	cpp-btree/btree.h	/^  reference operator*() const {$/;"	f	struct:btree::btree_iterator
operator *	cpp-btree/btree_container.h	/^    value_type operator*() const {$/;"	f	struct:btree::btree_map_container::generate_value
operator *	elist.h	/^    T operator*() {$/;"	f	class:elist::iterator
operator *	interval_set.h	/^        std::pair < T, T > &operator*() {$/;"	f	class:interval_set::iterator
operator *	interval_set.h	/^        std::pair < T, T > operator*() const {$/;"	f	class:interval_set::const_iterator
operator *	rangeset.h	/^  T& operator*() {$/;"	f	class:rangeset_iterator
operator *	xlist.h	/^    T operator*() { return static_cast<T>(cur->_item); }$/;"	f	class:xlist::iterator
operator *	xlist.h	/^    const T operator*() { return static_cast<const T>(cur->_item); }$/;"	f	class:xlist::const_iterator
operator +	utime.h	/^inline utime_t operator+(const utime_t& l, const utime_t& r) {$/;"	f
operator ++	compact_map.h	/^    const_iterator_base& operator++() {$/;"	f	class:compact_map_base::const_iterator_base
operator ++	compact_map.h	/^    iterator_base operator++(int) {$/;"	f	class:compact_map_base::iterator_base
operator ++	compact_map.h	/^    iterator_base& operator++() {$/;"	f	class:compact_map_base::iterator_base
operator ++	compact_set.h	/^    iterator_base operator++(int) {$/;"	f	class:compact_set_base::iterator_base
operator ++	compact_set.h	/^    iterator_base& operator++() {$/;"	f	class:compact_set_base::iterator_base
operator ++	cpp-btree/btree.h	/^  self_type operator++(int) {$/;"	f	struct:btree::btree_iterator
operator ++	cpp-btree/btree.h	/^  self_type& operator++() {$/;"	f	struct:btree::btree_iterator
operator ++	elist.h	/^    iterator& operator++() {$/;"	f	class:elist::iterator
operator ++	interval_set.h	/^        const_iterator &operator++()$/;"	f	class:interval_set::const_iterator
operator ++	interval_set.h	/^        const_iterator operator++(int)$/;"	f	class:interval_set::const_iterator
operator ++	interval_set.h	/^        iterator &operator++()$/;"	f	class:interval_set::iterator
operator ++	interval_set.h	/^        iterator operator++(int)$/;"	f	class:interval_set::iterator
operator ++	object.h	/^  snapid_t operator++() { ++val; return *this; }$/;"	f	struct:snapid_t
operator ++	rangeset.h	/^  rangeset_iterator<T> operator++(int) {$/;"	f	class:rangeset_iterator
operator ++	xlist.h	/^    const_iterator& operator++() {$/;"	f	class:xlist::const_iterator
operator ++	xlist.h	/^    iterator& operator++() {$/;"	f	class:xlist::iterator
operator +=	cpp-btree/btree.h	/^    node_stats& operator+=(const node_stats &x) {$/;"	f	struct:btree::btree::node_stats
operator +=	fs_types.h	/^  inodeno_t operator+=(inodeno_t o) { val += o.val; return *this; }$/;"	f	struct:inodeno_t
operator +=	mempool.h	/^  stats_t& operator+=(const stats_t& o) {$/;"	f	struct:mempool::stats_t
operator +=	object.h	/^  snapid_t operator+=(snapid_t o) { val += o.val; return *this; }$/;"	f	struct:snapid_t
operator +=	utime.h	/^inline utime_t& operator+=(utime_t& l, const utime_t& r) {$/;"	f
operator +=	utime.h	/^inline utime_t& operator+=(utime_t& l, double f) {$/;"	f
operator -	utime.h	/^inline utime_t operator-(const utime_t& l, const utime_t& r) {$/;"	f
operator --	compact_map.h	/^    const_iterator_base& operator--() {$/;"	f	class:compact_map_base::const_iterator_base
operator --	compact_map.h	/^    iterator_base& operator--() {$/;"	f	class:compact_map_base::iterator_base
operator --	compact_set.h	/^    iterator_base& operator--() {$/;"	f	class:compact_set_base::iterator_base
operator --	cpp-btree/btree.h	/^  self_type operator--(int) {$/;"	f	struct:btree::btree_iterator
operator --	cpp-btree/btree.h	/^  self_type& operator--() {$/;"	f	struct:btree::btree_iterator
operator -=	utime.h	/^inline utime_t& operator-=(utime_t& l, const utime_t& r) {$/;"	f
operator -=	utime.h	/^inline utime_t& operator-=(utime_t& l, double f) {$/;"	f
operator ->	alloc_ptr.h	/^    element_type* operator->() const {$/;"	f	class:alloc_ptr
operator ->	compact_map.h	/^    const std::pair<const Key,T>* operator->() {$/;"	f	class:compact_map_base::const_iterator_base
operator ->	compact_map.h	/^    std::pair<const Key,T>* operator->() {$/;"	f	class:compact_map_base::iterator_base
operator ->	cpp-btree/btree.h	/^  pointer operator->() const {$/;"	f	struct:btree::btree_iterator
operator <	alloc_ptr.h	/^    friend bool operator< (const alloc_ptr& lhs, const alloc_ptr& rhs) {$/;"	f	class:alloc_ptr
operator <	buffer.h	/^inline bool operator<(bufferlist& l, bufferlist& r) {$/;"	f	namespace:ceph::CEPH_BUFFER_API
operator <	object.h	/^inline bool operator<(const object_t& l, const object_t& r) {$/;"	f
operator <	object.h	/^inline bool operator<(const sobject_t &l, const sobject_t &r) {$/;"	f
operator <	rados/buffer.h	/^inline bool operator<(bufferlist& l, bufferlist& r) {$/;"	f	namespace:ceph::CEPH_BUFFER_API
operator <	rados/rados_types.hpp	/^inline bool operator<(const osd_shard_t &lhs, const osd_shard_t &rhs) {$/;"	f	namespace:librados
operator <	types.h	/^  int operator<(int i)  { return code < i; }$/;"	f	struct:errorcode32_t
operator <	types.h	/^static inline bool operator<(const client_t& l, const client_t& r) { return l.v < r.v; }$/;"	f
operator <	types.h	/^static inline bool operator<(const client_t& l, int64_t o) { return l.v < o; }$/;"	f
operator <	utime.h	/^inline bool operator<(const utime_t& a, const utime_t& b)$/;"	f
operator <	uuid.h	/^inline bool operator<(const uuid_d& l, const uuid_d& r) {$/;"	f
operator <<	CompatSet.h	/^inline ostream& operator<<(ostream& out, const CompatSet& compat)$/;"	f
operator <<	CompatSet.h	/^inline ostream& operator<<(ostream& out, const CompatSet::FeatureSet& fs)$/;"	f
operator <<	buffer.h	/^inline bufferhash& operator<<(bufferhash& l, const bufferlist &r) {$/;"	f	namespace:ceph::CEPH_BUFFER_API
operator <<	compact_map.h	/^inline std::ostream& operator<<(std::ostream& out, const compact_map<Key, T, Compare, Alloc>& m)$/;"	f
operator <<	compact_map.h	/^inline std::ostream& operator<<(std::ostream& out, const compact_multimap<Key, T, Compare, Alloc>& m)$/;"	f
operator <<	compact_set.h	/^inline std::ostream& operator<<(std::ostream& out, const compact_set<T,Compare,Alloc>& s)$/;"	f
operator <<	cpp-btree/btree_container.h	/^inline std::ostream& operator<<(std::ostream &os, const btree_container<T> &b) {$/;"	f	namespace:btree
operator <<	filepath.h	/^inline ostream& operator<<(ostream& out, const filepath& path)$/;"	f
operator <<	frag.h	/^inline std::ostream& operator<<(std::ostream& out, const frag_t& hb)$/;"	f
operator <<	frag.h	/^inline std::ostream& operator<<(std::ostream& out, const fragset_t& fs) $/;"	f
operator <<	frag.h	/^inline std::ostream& operator<<(std::ostream& out, const fragtree_t& ft)$/;"	f
operator <<	fs_types.h	/^inline ostream& operator<<(ostream& out, const inodeno_t& ino) {$/;"	f
operator <<	health.h	/^inline std::ostream& operator<<(std::ostream &oss, const health_status_t status) {$/;"	f
operator <<	interval_set.h	/^inline std::ostream& operator<<(std::ostream& out, const interval_set<T,Map> &s) {$/;"	f
operator <<	object.h	/^inline ostream& operator<<(ostream& out, const object_t& o) {$/;"	f
operator <<	object.h	/^inline ostream& operator<<(ostream& out, const snapid_t& s) {$/;"	f
operator <<	object.h	/^inline ostream& operator<<(ostream& out, const sobject_t &o) {$/;"	f
operator <<	rados/buffer.h	/^inline bufferhash& operator<<(bufferhash& l, const bufferlist &r) {$/;"	f	namespace:ceph::CEPH_BUFFER_API
operator <<	types.h	/^inline ostream& operator<<(ostream& out, const byte_u_t& b)$/;"	f
operator <<	types.h	/^inline ostream& operator<<(ostream& out, const ceph_mon_subscribe_item& i)$/;"	f
operator <<	types.h	/^inline ostream& operator<<(ostream& out, const client_t& c) {$/;"	f
operator <<	types.h	/^inline ostream& operator<<(ostream& out, const deque<A,Alloc>& v) {$/;"	f
operator <<	types.h	/^inline ostream& operator<<(ostream& out, const list<A,Alloc>& ilist) {$/;"	f
operator <<	types.h	/^inline ostream& operator<<(ostream& out, const map<A,B,Comp,Alloc>& m)$/;"	f
operator <<	types.h	/^inline ostream& operator<<(ostream& out, const multimap<A,B,Comp,Alloc>& m)$/;"	f
operator <<	types.h	/^inline ostream& operator<<(ostream& out, const multiset<A,Comp,Alloc>& iset) {$/;"	f
operator <<	types.h	/^inline ostream& operator<<(ostream& out, const pair<A,B>& v) {$/;"	f
operator <<	types.h	/^inline ostream& operator<<(ostream& out, const set<A, Comp, Alloc>& iset) {$/;"	f
operator <<	types.h	/^inline ostream& operator<<(ostream& out, const si_u_t& b)$/;"	f
operator <<	types.h	/^inline ostream& operator<<(ostream& out, const vector<A,Alloc>& v) {$/;"	f
operator <<	types.h	/^inline ostream& operator<<(ostream& out, const weightf_t& w)$/;"	f
operator <<	types.h	/^inline ostream& operator<<(ostream&out, const boost::tuple<A, B, C> &t) {$/;"	f
operator <<	utime.h	/^inline std::ostream& operator<<(std::ostream& out, const utime_t& t)$/;"	f
operator <<	uuid.h	/^inline std::ostream& operator<<(std::ostream& out, const uuid_d& u) {$/;"	f
operator <=	alloc_ptr.h	/^    friend bool operator<=(const alloc_ptr& lhs, const alloc_ptr& rhs) {$/;"	f	class:alloc_ptr
operator <=	buffer.h	/^inline bool operator<=(bufferlist& l, bufferlist& r) {$/;"	f	namespace:ceph::CEPH_BUFFER_API
operator <=	object.h	/^inline bool operator<=(const object_t& l, const object_t& r) {$/;"	f
operator <=	object.h	/^inline bool operator<=(const sobject_t &l, const sobject_t &r) {$/;"	f
operator <=	rados/buffer.h	/^inline bool operator<=(bufferlist& l, bufferlist& r) {$/;"	f	namespace:ceph::CEPH_BUFFER_API
operator <=	types.h	/^  int operator<=(int i) { return code <= i; }$/;"	f	struct:errorcode32_t
operator <=	types.h	/^static inline bool operator<=(const client_t& l, const client_t& r) { return l.v <= r.v; }$/;"	f
operator <=	utime.h	/^inline bool operator<=(const utime_t& a, const utime_t& b)$/;"	f
operator =	alloc_ptr.h	/^    alloc_ptr& operator=(const alloc_ptr<pointer>& rhs) {$/;"	f	class:alloc_ptr
operator =	alloc_ptr.h	/^    alloc_ptr& operator=(const alloc_ptr<pointer>&& rhs) {$/;"	f	class:alloc_ptr
operator =	buffer.h	/^    list& operator= (const list& other) {$/;"	f	class:ceph::CEPH_BUFFER_API::list
operator =	buffer.h	/^    list& operator= (list&& other) {$/;"	f	class:ceph::CEPH_BUFFER_API::list
operator =	byteorder.h	/^  ceph_le<T>& operator=(T nv) {$/;"	f	struct:ceph_le
operator =	compact_map.h	/^    const_iterator_base& operator=(const const_iterator_base& o) {$/;"	f	class:compact_map_base::const_iterator_base
operator =	compact_map.h	/^    iterator_base& operator=(const iterator_base& o) {$/;"	f	class:compact_map_base::iterator_base
operator =	compact_map.h	/^  compact_map_base& operator=(const compact_map_base& o) {$/;"	f	class:compact_map_base
operator =	compact_set.h	/^    iterator_base& operator=(const iterator_base& o) {$/;"	f	class:compact_set_base::iterator_base
operator =	compact_set.h	/^  compact_set_base& operator=(const compact_set_base& o) {$/;"	f	class:compact_set_base
operator =	cpp-btree/btree.h	/^  self_type& operator=(const self_type &x) {$/;"	f	class:btree::btree
operator =	rados/buffer.h	/^    list& operator= (const list& other) {$/;"	f	class:ceph::CEPH_BUFFER_API::list
operator =	rados/buffer.h	/^    list& operator= (list&& other) {$/;"	f	class:ceph::CEPH_BUFFER_API::list
operator ==	alloc_ptr.h	/^    friend bool operator==(const alloc_ptr& lhs, const alloc_ptr& rhs) {$/;"	f	class:alloc_ptr
operator ==	buffer.h	/^      bool operator==(const iterator& rhs) const {$/;"	f	class:ceph::CEPH_BUFFER_API::list::iterator
operator ==	buffer.h	/^      friend bool operator==(const iterator_impl& lhs,$/;"	f	class:ceph::CEPH_BUFFER_API::list::iterator_impl
operator ==	buffer.h	/^inline bool operator==(const bufferlist &l, const bufferlist &r) {$/;"	f	namespace:ceph::CEPH_BUFFER_API
operator ==	byteorder.h	/^inline bool operator==(ceph_le<T> a, ceph_le<T> b) {$/;"	f
operator ==	compact_map.h	/^    bool operator==(const const_iterator_base& o) const {$/;"	f	class:compact_map_base::const_iterator_base
operator ==	compact_map.h	/^    bool operator==(const iterator_base& o) const {$/;"	f	class:compact_map_base::iterator_base
operator ==	compact_map.h	/^  bool operator==(const compact_map_base& o) const {$/;"	f	class:compact_map_base
operator ==	compact_set.h	/^    bool operator==(const iterator_base& o) const {$/;"	f	class:compact_set_base::iterator_base
operator ==	compact_set.h	/^  bool operator==(const compact_set_base& o) const {$/;"	f	class:compact_set_base
operator ==	cpp-btree/btree.h	/^  bool operator==(const const_iterator &x) const {$/;"	f	struct:btree::btree_iterator
operator ==	cpp-btree/btree_container.h	/^  bool operator==(const self_type& x) const {$/;"	f	class:btree::btree_container
operator ==	frag.h	/^inline bool operator==(const fragtree_t& l, const fragtree_t& r) {$/;"	f
operator ==	interval_set.h	/^        bool operator==(const const_iterator& rhs) const {$/;"	f	class:interval_set::const_iterator
operator ==	interval_set.h	/^        bool operator==(const iterator& rhs) const {$/;"	f	class:interval_set::iterator
operator ==	interval_set.h	/^  bool operator==(const interval_set& other) const {$/;"	f	class:interval_set
operator ==	mempool.h	/^  bool operator==(const pool_allocator&) const { return true; }$/;"	f	class:mempool::pool_allocator
operator ==	object.h	/^inline bool operator==(const object_t& l, const object_t& r) {$/;"	f
operator ==	object.h	/^inline bool operator==(const sobject_t &l, const sobject_t &r) {$/;"	f
operator ==	rados/buffer.h	/^      bool operator==(const iterator& rhs) const {$/;"	f	class:ceph::CEPH_BUFFER_API::list::iterator
operator ==	rados/buffer.h	/^      friend bool operator==(const iterator_impl& lhs,$/;"	f	class:ceph::CEPH_BUFFER_API::list::iterator_impl
operator ==	rados/buffer.h	/^inline bool operator==(const bufferlist &l, const bufferlist &r) {$/;"	f	namespace:ceph::CEPH_BUFFER_API
operator ==	rangeset.h	/^  bool operator==(rangeset_iterator<T> rit) {$/;"	f	class:rangeset_iterator
operator ==	types.h	/^  int operator==(int i) { return code == i; }$/;"	f	struct:errorcode32_t
operator ==	types.h	/^static inline bool operator==(const client_t& l, const client_t& r) { return l.v == r.v; }$/;"	f
operator ==	utime.h	/^inline bool operator==(const utime_t& a, const utime_t& b)$/;"	f
operator ==	uuid.h	/^inline bool operator==(const uuid_d& l, const uuid_d& r) {$/;"	f
operator ==	xlist.h	/^    bool operator==(const iterator& rhs) const {$/;"	f	class:xlist::iterator
operator >	alloc_ptr.h	/^    friend bool operator> (const alloc_ptr& lhs, const alloc_ptr& rhs) {$/;"	f	class:alloc_ptr
operator >	buffer.h	/^inline bool operator>(bufferlist& l, bufferlist& r) {$/;"	f	namespace:ceph::CEPH_BUFFER_API
operator >	object.h	/^inline bool operator>(const object_t& l, const object_t& r) {$/;"	f
operator >	object.h	/^inline bool operator>(const sobject_t &l, const sobject_t &r) {$/;"	f
operator >	rados/buffer.h	/^inline bool operator>(bufferlist& l, bufferlist& r) {$/;"	f	namespace:ceph::CEPH_BUFFER_API
operator >	types.h	/^  int operator>(int i)  { return code > i; }$/;"	f	struct:errorcode32_t
operator >	types.h	/^static inline bool operator>(const client_t& l, const client_t& r) { return l.v > r.v; }$/;"	f
operator >	utime.h	/^inline bool operator>(const utime_t& a, const utime_t& b)$/;"	f
operator >=	alloc_ptr.h	/^    friend bool operator>=(const alloc_ptr& lhs, const alloc_ptr& rhs) {$/;"	f	class:alloc_ptr
operator >=	buffer.h	/^inline bool operator>=(bufferlist& l, bufferlist& r) {$/;"	f	namespace:ceph::CEPH_BUFFER_API
operator >=	object.h	/^inline bool operator>=(const object_t& l, const object_t& r) { $/;"	f
operator >=	object.h	/^inline bool operator>=(const sobject_t &l, const sobject_t &r) {$/;"	f
operator >=	rados/buffer.h	/^inline bool operator>=(bufferlist& l, bufferlist& r) {$/;"	f	namespace:ceph::CEPH_BUFFER_API
operator >=	types.h	/^  int operator>=(int i) { return code >= i; }$/;"	f	struct:errorcode32_t
operator >=	types.h	/^static inline bool operator>=(const client_t& l, const client_t& r) { return l.v >= r.v; }$/;"	f
operator >=	types.h	/^static inline bool operator>=(const client_t& l, int64_t o) { return l.v >= o; }$/;"	f
operator >=	utime.h	/^inline bool operator>=(const utime_t& a, const utime_t& b)$/;"	f
operator T	byteorder.h	/^  operator T() const { return mswab(v); }$/;"	f	struct:ceph_le
operator []	bitmapper.h	/^  bool operator[](int b) const {$/;"	f	class:bitmapper
operator []	compact_map.h	/^  T& operator[](const Key& k) {$/;"	f	class:compact_map
operator []	cpp-btree/btree_container.h	/^  data_type& operator[](const key_type &key) {$/;"	f	class:btree::btree_map_container
operator []	filepath.h	/^  const string& operator[](int i) const {$/;"	f	class:filepath
operator []	frag.h	/^  frag_t operator[](unsigned v) const {$/;"	f	class:fragtree_t
operator _frag_t	frag.h	/^  operator _frag_t() const { return _enc; }$/;"	f	class:frag_t
operator _inodeno_t	fs_types.h	/^  operator _inodeno_t() const { return val; }$/;"	f	struct:inodeno_t
operator bool	alloc_ptr.h	/^    operator bool() const {$/;"	f	class:alloc_ptr
operator ceph_timespec	utime.h	/^  operator ceph_timespec() const {$/;"	f	class:utime_t
operator const_iterator	compact_set.h	/^      operator const_iterator() const {$/;"	f	class:compact_set_base::iterator
operator const_iterator	compact_set.h	/^      operator const_iterator() const {$/;"	f	class:compact_set_base::reverse_iterator
operator const_iterator_base<It>	compact_map.h	/^    operator const_iterator_base<It>() const {$/;"	f	class:compact_map_base::iterator_base
operator double	utime.h	/^  operator double() const {$/;"	f	class:utime_t
operator int	types.h	/^  operator int() const  { return code; }$/;"	f	struct:errorcode32_t
operator int8_t	types.h	/^  operator int8_t() const { return id; }$/;"	f	struct:shard_id_t
operator object_t	object.h	/^  operator object_t() {$/;"	f	struct:file_object_t
operator uint64_t	object.h	/^  operator uint64_t() const { return val; }  $/;"	f	struct:snapid_t
ops	rados.h	/^	struct ceph_osd_op ops[0];  \/* ops[], object *\/$/;"	m	struct:ceph_osd_reply_head	typeref:struct:ceph_osd_reply_head::ceph_osd_op
options	rbd_types.h	/^	} __attribute__((packed)) options;$/;"	m	struct:rbd_obj_header_ondisk	typeref:struct:rbd_obj_header_ondisk::__anon32
opts	rbd/librbd.hpp	/^  rbd_image_options_t opts;$/;"	m	class:librbd::ImageOptions
order	rbd/librbd.h	/^  int order;$/;"	m	struct:__anon77
order	rbd_types.h	/^		__u8 order;$/;"	m	struct:rbd_obj_header_ondisk::__anon32
orig_src	msgr.h	/^	struct ceph_entity_inst src, orig_src;$/;"	m	struct:ceph_msg_header_old	typeref:struct:ceph_msg_header_old::
osd	rados/rados_types.hpp	/^  int32_t osd;$/;"	m	struct:librados::osd_shard_t
osd_shard_t	rados/rados_types.hpp	/^struct osd_shard_t {$/;"	s	namespace:librados
osdmap_epoch	ceph_fs.h	/^		__le32 osdmap_epoch; 	    \/* use for set file\/dir layout *\/$/;"	m	struct:ceph_mds_request_args::__anon62
osdmap_epoch	ceph_fs.h	/^		__le32 osdmap_epoch; 	    \/* use for set file\/dir layout *\/$/;"	m	struct:ceph_mds_request_args_legacy::__anon53
osdmap_epoch	rados.h	/^	__le32 osdmap_epoch;$/;"	m	struct:ceph_osd_reply_head
other	mempool.h	/^    typedef pool_allocator<pool_ix,U> other;$/;"	t	struct:mempool::pool_allocator::rebind
out_of_band_offset	buffer.h	/^      size_t out_of_band_offset = 0;$/;"	m	class:ceph::CEPH_BUFFER_API::list::contiguous_appender
out_of_band_offset	rados/buffer.h	/^      size_t out_of_band_offset = 0;$/;"	m	class:ceph::CEPH_BUFFER_API::list::contiguous_appender
overhead	cpp-btree/btree.h	/^  double overhead() const {$/;"	f	class:btree::btree
overhead	cpp-btree/btree_container.h	/^  double overhead() const { return tree_.overhead(); }$/;"	f	class:btree::btree_container
overlap	rados/rados_types.hpp	/^  std::vector< std::pair<uint64_t,uint64_t> > overlap;  \/\/ with next newest$/;"	m	struct:librados::clone_info_t
override	buffer.h	/^    const char *what() const throw () override;$/;"	m	struct:ceph::CEPH_BUFFER_API::bad_alloc
override	buffer.h	/^    const char *what() const throw () override;$/;"	m	struct:ceph::CEPH_BUFFER_API::end_of_buffer
override	buffer.h	/^    const char *what() const throw () override;$/;"	m	struct:ceph::CEPH_BUFFER_API::error
override	buffer.h	/^    const char *what() const throw () override;$/;"	m	struct:ceph::CEPH_BUFFER_API::malformed_input
override	rados/buffer.h	/^    const char *what() const throw () override;$/;"	m	struct:ceph::CEPH_BUFFER_API::bad_alloc
override	rados/buffer.h	/^    const char *what() const throw () override;$/;"	m	struct:ceph::CEPH_BUFFER_API::end_of_buffer
override	rados/buffer.h	/^    const char *what() const throw () override;$/;"	m	struct:ceph::CEPH_BUFFER_API::error
override	rados/buffer.h	/^    const char *what() const throw () override;$/;"	m	struct:ceph::CEPH_BUFFER_API::malformed_input
owner	ceph_fs.h	/^		__le64 owner; \/* who requests\/holds the lock *\/$/;"	m	struct:ceph_mds_request_args::__anon64
owner	ceph_fs.h	/^		__le64 owner; \/* who requests\/holds the lock *\/$/;"	m	struct:ceph_mds_request_args_legacy::__anon55
owner	ceph_fs.h	/^	__le64 owner; \/* who requests\/holds the lock *\/$/;"	m	struct:ceph_filelock
p	Distribution.h	/^  vector<float> p;$/;"	m	class:Distribution
p	buffer.h	/^      list_iter_t p;$/;"	m	class:ceph::CEPH_BUFFER_API::list::iterator_impl
p	rados/buffer.h	/^      list_iter_t p;$/;"	m	class:ceph::CEPH_BUFFER_API::list::iterator_impl
p_off	buffer.h	/^      unsigned p_off;   \/\/ in *p$/;"	m	class:ceph::CEPH_BUFFER_API::list::iterator_impl
p_off	rados/buffer.h	/^      unsigned p_off;   \/\/ in *p$/;"	m	class:ceph::CEPH_BUFFER_API::list::iterator_impl
padding_check	utime.h	/^  void padding_check() {$/;"	f	class:utime_t
page_aligned_appender	buffer.h	/^      page_aligned_appender(list *l, unsigned min_pages)$/;"	f	class:ceph::CEPH_BUFFER_API::list::page_aligned_appender
page_aligned_appender	buffer.h	/^    class page_aligned_appender {$/;"	c	class:ceph::CEPH_BUFFER_API::list
page_aligned_appender	rados/buffer.h	/^      page_aligned_appender(list *l, unsigned min_pages)$/;"	f	class:ceph::CEPH_BUFFER_API::list::page_aligned_appender
page_aligned_appender	rados/buffer.h	/^    class page_aligned_appender {$/;"	c	class:ceph::CEPH_BUFFER_API::list
params_type	cpp-btree/btree.h	/^  typedef Params params_type;$/;"	t	class:btree::btree
params_type	cpp-btree/btree.h	/^  typedef Params params_type;$/;"	t	class:btree::btree_node
params_type	cpp-btree/btree.h	/^  typedef typename Node::params_type params_type;$/;"	t	struct:btree::btree_iterator
params_type	cpp-btree/btree_container.h	/^  typedef typename Tree::params_type params_type;$/;"	t	class:btree::btree_container
params_type	cpp-btree/btree_map.h	/^    Key, Value, Compare, Alloc, TargetNodeSize> params_type;$/;"	t	class:btree::btree_map
params_type	cpp-btree/btree_map.h	/^    Key, Value, Compare, Alloc, TargetNodeSize> params_type;$/;"	t	class:btree::btree_multimap
params_type	cpp-btree/btree_set.h	/^  typedef btree_set_params<Key, Compare, Alloc, TargetNodeSize> params_type;$/;"	t	class:btree::btree_multiset
params_type	cpp-btree/btree_set.h	/^  typedef btree_set_params<Key, Compare, Alloc, TargetNodeSize> params_type;$/;"	t	class:btree::btree_set
parent	ceph_fs.h	/^	__le64 parent;        \/* ino: parent realm *\/$/;"	m	struct:ceph_mds_snap_realm
parent	ceph_fs.h	/^	__le64 parent;  \/* parent realm *\/$/;"	m	struct:ceph_mds_snaprealm_reconnect
parent	cpp-btree/btree.h	/^    btree_node *parent;$/;"	m	struct:btree::btree_node::base_fields
parent	cpp-btree/btree.h	/^  btree_node* parent() const { return fields_.parent; }$/;"	f	class:btree::btree_node
parent	frag.h	/^  frag_t parent() const {$/;"	f	class:frag_t
parent_name	rbd/librbd.h	/^  char parent_name[RBD_MAX_IMAGE_NAME_SIZE];       \/* deprecated *\/$/;"	m	struct:__anon77
parent_pool	rbd/librbd.h	/^  int64_t parent_pool;			           \/* deprecated *\/$/;"	m	struct:__anon77
parent_since	ceph_fs.h	/^	__le64 parent_since;  \/* snap: same parent since *\/$/;"	m	struct:ceph_mds_snap_realm
parse	frag.h	/^  bool parse(const char *s) {$/;"	f	class:frag_t
parse	uuid.h	/^  bool parse(const char *s) {$/;"	f	struct:uuid_d
parse_bits	filepath.h	/^  void parse_bits() const {$/;"	f	class:filepath
parse_date	utime.h	/^  static int parse_date(const string& date, uint64_t *epoch, uint64_t *nsec,$/;"	f	class:utime_t
path	filepath.h	/^  string path;     \/\/ relative path.$/;"	m	class:filepath
pathbase	ceph_fs.h	/^	__le64 pathbase;        \/* base ino for our path to this ino *\/$/;"	m	struct:ceph_mds_cap_reconnect
pathbase	ceph_fs.h	/^	__le64 pathbase;        \/* base ino for our path to this ino *\/$/;"	m	struct:ceph_mds_cap_reconnect_v1
payload_len	rados.h	/^	__le32 payload_len;$/;"	m	struct:ceph_osd_op
pbl	buffer.h	/^      bufferlist *pbl;$/;"	m	class:ceph::CEPH_BUFFER_API::list::contiguous_appender
pbl	buffer.h	/^      bufferlist *pbl;$/;"	m	class:ceph::CEPH_BUFFER_API::list::page_aligned_appender
pbl	rados/buffer.h	/^      bufferlist *pbl;$/;"	m	class:ceph::CEPH_BUFFER_API::list::contiguous_appender
pbl	rados/buffer.h	/^      bufferlist *pbl;$/;"	m	class:ceph::CEPH_BUFFER_API::list::page_aligned_appender
pc	rados/librados.hpp	/^    AioCompletionImpl *pc;$/;"	m	struct:librados::AioCompletion
pc	rados/librados.hpp	/^    PoolAsyncCompletionImpl *pc;$/;"	m	struct:librados::PoolAsyncCompletion
pc	radosstriper/libradosstriper.hpp	/^    MultiAioCompletionImpl *pc;$/;"	m	struct:libradosstriper::MultiAioCompletion
pc	rbd/librbd.hpp	/^    void *pc;$/;"	m	struct:librbd::RBD::AioCompletion
peer	ceph_fs.h	/^		struct ceph_mds_cap_peer peer;$/;"	m	union:ceph_mds_caps_body_legacy::__anon66	typeref:struct:ceph_mds_caps_body_legacy::__anon66::ceph_mds_cap_peer
pgls	rados.h	/^		} __attribute__ ((packed)) pgls;$/;"	m	union:ceph_osd_op::__anon13	typeref:struct:ceph_osd_op::__anon13::__anon17
pick_a_shard	mempool.h	/^  shard_t* pick_a_shard() {$/;"	f	class:mempool::pool_t
pid	ceph_fs.h	/^		__le64 pid; \/* process id requesting the lock *\/$/;"	m	struct:ceph_mds_request_args::__anon64
pid	ceph_fs.h	/^		__le64 pid; \/* process id requesting the lock *\/$/;"	m	struct:ceph_mds_request_args_legacy::__anon55
pid	ceph_fs.h	/^	__le64 pid; \/* process id holding the lock on the client *\/$/;"	m	struct:ceph_filelock
pintail	lru.h	/^  LRUList top, bottom, pintail;$/;"	m	class:LRU
pointer	alloc_ptr.h	/^    typedef typename std::pointer_traits< std::unique_ptr<T> >::pointer pointer;$/;"	t	class:alloc_ptr
pointer	cpp-btree/btree.h	/^  typedef Pointer pointer;$/;"	t	struct:btree::btree_iterator
pointer	cpp-btree/btree.h	/^  typedef typename Params::pointer pointer;$/;"	t	class:btree::btree
pointer	cpp-btree/btree.h	/^  typedef typename Params::pointer pointer;$/;"	t	class:btree::btree_node
pointer	cpp-btree/btree.h	/^  typedef value_type* pointer;$/;"	t	struct:btree::btree_map_params
pointer	cpp-btree/btree.h	/^  typedef value_type* pointer;$/;"	t	struct:btree::btree_set_params
pointer	cpp-btree/btree_container.h	/^  typedef typename Tree::pointer pointer;$/;"	t	class:btree::btree_container
pointer	mempool.h	/^  typedef value_type *pointer;$/;"	t	class:mempool::pool_allocator
pool	ceph_fs.h	/^		__le32 pool;                 \/* if >= 0 and CREATEPOOLID feature *\/$/;"	m	struct:ceph_mds_request_args::__anon61
pool	ceph_fs.h	/^		__le32 pool;                 \/* if >= 0 and CREATEPOOLID feature *\/$/;"	m	struct:ceph_mds_request_args_legacy::__anon52
pool	ceph_fs.h	/^	__le32 pool;$/;"	m	struct:ceph_mon_poolop
pool	mempool.h	/^  pool_t *pool;$/;"	m	class:mempool::pool_allocator
pool	rados.h	/^	__le32 pool;      \/* object pool *\/$/;"	m	struct:ceph_pg
pool_allocator	mempool.h	/^  pool_allocator(bool force_register=false) {$/;"	f	class:mempool::pool_allocator
pool_allocator	mempool.h	/^  pool_allocator(const pool_allocator<pool_ix,U>&) {$/;"	f	class:mempool::pool_allocator
pool_allocator	mempool.h	/^class pool_allocator {$/;"	c	namespace:mempool
pool_id	fs_types.h	/^  int64_t pool_id;        \/\/\/< rados pool id$/;"	m	struct:file_layout_t
pool_index_t	mempool.h	/^enum pool_index_t {$/;"	g	namespace:mempool
pool_ns	fs_types.h	/^  string pool_ns;         \/\/\/< rados pool namespace$/;"	m	struct:file_layout_t
pool_stat_t	rados/librados.hpp	/^  typedef struct rados_pool_stat_t pool_stat_t;$/;"	t	namespace:librados	typeref:struct:librados::rados_pool_stat_t
pool_t	mempool.h	/^class pool_t {$/;"	c	namespace:mempool
pop_back	elist.h	/^  void pop_back() {$/;"	f	class:elist
pop_back	xlist.h	/^  void pop_back() {$/;"	f	class:xlist
pop_dentry	filepath.h	/^  void pop_dentry() {$/;"	f	class:filepath
pop_front	elist.h	/^  void pop_front() {$/;"	f	class:elist
pop_front	xlist.h	/^  void pop_front() {$/;"	f	class:xlist
pos	buffer.h	/^      char *pos, *end;$/;"	m	class:ceph::CEPH_BUFFER_API::list::page_aligned_appender
pos	buffer.h	/^      char *pos;$/;"	m	class:ceph::CEPH_BUFFER_API::list::contiguous_appender
pos	buffer.h	/^      const char *pos;   \/\/\/< pointer into bp->c_str()$/;"	m	class:ceph::CEPH_BUFFER_API::ptr::iterator
pos	rados/buffer.h	/^      char *pos, *end;$/;"	m	class:ceph::CEPH_BUFFER_API::list::page_aligned_appender
pos	rados/buffer.h	/^      char *pos;$/;"	m	class:ceph::CEPH_BUFFER_API::list::contiguous_appender
pos	rados/buffer.h	/^      const char *pos;   \/\/\/< pointer into bp->c_str()$/;"	m	class:ceph::CEPH_BUFFER_API::ptr::iterator
position	cpp-btree/btree.h	/^    field_type position;$/;"	m	struct:btree::btree_node::base_fields
position	cpp-btree/btree.h	/^  int position() const { return fields_.position; }$/;"	f	class:btree::btree_node
position	cpp-btree/btree.h	/^  int position;$/;"	m	struct:btree::btree_iterator
postfixpath	filepath.h	/^  filepath postfixpath(int s) const {$/;"	f	class:filepath
preferred	rados.h	/^	__le16 preferred; \/* preferred primary osd *\/$/;"	m	struct:ceph_pg
prefixpath	filepath.h	/^  filepath prefixpath(int s) const {$/;"	f	class:filepath
prepare_iov	buffer.h	/^    void prepare_iov(VectorT *piov) const {$/;"	f	class:ceph::CEPH_BUFFER_API::list
prepare_iov	rados/buffer.h	/^    void prepare_iov(VectorT *piov) const {$/;"	f	class:ceph::CEPH_BUFFER_API::list
primary	rados/rados_types.hpp	/^  bool primary = false;$/;"	m	struct:librados::shard_info_t
primary	rbd/librbd.h	/^  bool primary;$/;"	m	struct:__anon81
primary	rbd/librbd.hpp	/^    bool primary;$/;"	m	struct:librbd::__anon72
print	frag.h	/^  void print(std::ostream& out) {$/;"	f	class:fragtree_t
print	uuid.h	/^  void print(char *s) const {$/;"	f	struct:uuid_d
priority	msgr.h	/^	__le16 priority;  \/* priority.  higher value == higher priority *\/$/;"	m	struct:ceph_msg_header
priority	msgr.h	/^	__le16 priority;  \/* priority.  higher value == higher priority *\/$/;"	m	struct:ceph_msg_header_old
protocol_version	msgr.h	/^	__le32 protocol_version;$/;"	m	struct:ceph_msg_connect
protocol_version	msgr.h	/^	__le32 protocol_version;$/;"	m	struct:ceph_msg_connect_reply
ps	rados.h	/^	__le16 ps;        \/* placement seed *\/$/;"	m	struct:ceph_pg
ptr	alloc_ptr.h	/^    mutable std::unique_ptr<element_type> ptr;$/;"	m	class:alloc_ptr
ptr	buffer.h	/^    ptr() : _raw(0), _off(0), _len(0) {}$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
ptr	buffer.h	/^  class CEPH_BUFFER_API ptr {$/;"	c	namespace:ceph::CEPH_BUFFER_API
ptr	rados/buffer.h	/^    ptr() : _raw(0), _off(0), _len(0) {}$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
ptr	rados/buffer.h	/^  class CEPH_BUFFER_API ptr {$/;"	c	namespace:ceph::CEPH_BUFFER_API
pure_relative	filepath.h	/^  bool pure_relative() const { return ino == 0; }$/;"	f	class:filepath
push_back	buffer.h	/^    void push_back(const ptr& bp) {$/;"	f	class:ceph::CEPH_BUFFER_API::list
push_back	buffer.h	/^    void push_back(ptr&& bp) {$/;"	f	class:ceph::CEPH_BUFFER_API::list
push_back	buffer.h	/^    void push_back(raw *r) {$/;"	f	class:ceph::CEPH_BUFFER_API::list
push_back	elist.h	/^  void push_back(item *i) {$/;"	f	class:elist
push_back	rados/buffer.h	/^    void push_back(const ptr& bp) {$/;"	f	class:ceph::CEPH_BUFFER_API::list
push_back	rados/buffer.h	/^    void push_back(ptr&& bp) {$/;"	f	class:ceph::CEPH_BUFFER_API::list
push_back	rados/buffer.h	/^    void push_back(raw *r) {$/;"	f	class:ceph::CEPH_BUFFER_API::list
push_back	xlist.h	/^  void push_back(item *i) {$/;"	f	class:xlist
push_dentry	filepath.h	/^  void push_dentry(boost::string_view s) {$/;"	f	class:filepath
push_dentry	filepath.h	/^  void push_dentry(const char *cs) {$/;"	f	class:filepath
push_dentry	filepath.h	/^  void push_dentry(const string& s) {$/;"	f	class:filepath
push_front	buffer.h	/^    void push_front(ptr& bp) {$/;"	f	class:ceph::CEPH_BUFFER_API::list
push_front	buffer.h	/^    void push_front(ptr&& bp) {$/;"	f	class:ceph::CEPH_BUFFER_API::list
push_front	buffer.h	/^    void push_front(raw *r) {$/;"	f	class:ceph::CEPH_BUFFER_API::list
push_front	elist.h	/^  void push_front(item *i) {$/;"	f	class:elist
push_front	rados/buffer.h	/^    void push_front(ptr& bp) {$/;"	f	class:ceph::CEPH_BUFFER_API::list
push_front	rados/buffer.h	/^    void push_front(ptr&& bp) {$/;"	f	class:ceph::CEPH_BUFFER_API::list
push_front	rados/buffer.h	/^    void push_front(raw *r) {$/;"	f	class:ceph::CEPH_BUFFER_API::list
push_front	xlist.h	/^  void push_front(item *i) {$/;"	f	class:xlist
push_front_dentry	filepath.h	/^  void push_front_dentry(const string& s) {$/;"	f	class:filepath
pushback_details	denc.h	/^  struct pushback_details : public container_details_base<Container> {$/;"	s	namespace:_denc
rados_callback_t	rados/librados.h	/^typedef void (*rados_callback_t)(rados_completion_t cb, void *arg);$/;"	t
rados_checksum_type_t	rados/librados.h	/^} rados_checksum_type_t;$/;"	t	typeref:enum:__anon38
rados_cluster_stat_t	rados/librados.h	/^struct rados_cluster_stat_t {$/;"	s
rados_completion_t	rados/librados.h	/^typedef void *rados_completion_t;$/;"	t
rados_config_t	rados/librados.h	/^typedef void *rados_config_t;$/;"	t
rados_ioctx_t	rados/librados.h	/^typedef void *rados_ioctx_t;$/;"	t
rados_list_ctx_t	rados/librados.h	/^typedef void *rados_list_ctx_t;$/;"	t
rados_log_callback2_t	rados/librados.h	/^typedef void (*rados_log_callback2_t)(void *arg,$/;"	t
rados_log_callback_t	rados/librados.h	/^typedef void (*rados_log_callback_t)(void *arg,$/;"	t
rados_object_list_cursor	rados/librados.h	/^typedef void * rados_object_list_cursor;$/;"	t
rados_object_list_item	rados/librados.h	/^typedef struct rados_object_list_item {$/;"	s
rados_object_list_item	rados/librados.h	/^} rados_object_list_item;$/;"	t	typeref:struct:rados_object_list_item
rados_omap_iter_t	rados/librados.h	/^typedef void *rados_omap_iter_t;$/;"	t
rados_pool_stat_t	rados/librados.h	/^struct rados_pool_stat_t {$/;"	s
rados_read_op_t	rados/librados.h	/^typedef void *rados_read_op_t;$/;"	t
rados_snap_t	rados/librados.h	/^typedef uint64_t rados_snap_t;$/;"	t
rados_striper_impl	radosstriper/libradosstriper.hpp	/^    RadosStriperImpl *rados_striper_impl;$/;"	m	class:libradosstriper::RadosStriper
rados_striper_multi_completion_t	radosstriper/libradosstriper.h	/^typedef void *rados_striper_multi_completion_t;$/;"	t
rados_striper_t	radosstriper/libradosstriper.h	/^typedef void *rados_striper_t;$/;"	t
rados_t	cephfs/libcephfs.h	/^typedef void *rados_t;$/;"	t
rados_t	rados/librados.h	/^typedef void *rados_t;$/;"	t
rados_watchcb2_t	rados/librados.h	/^typedef void (*rados_watchcb2_t)(void *arg,$/;"	t
rados_watchcb_t	rados/librados.h	/^typedef void (*rados_watchcb_t)(uint8_t opcode, uint64_t ver, void *arg);$/;"	t
rados_watcherrcb_t	rados/librados.h	/^  typedef void (*rados_watcherrcb_t)(void *pre, uint64_t cookie, int err);$/;"	t
rados_write_op_t	rados/librados.h	/^typedef void *rados_write_op_t;$/;"	t
rados_xattrs_iter_t	rados/librados.h	/^typedef void *rados_xattrs_iter_t;$/;"	t
random	Distribution.h	/^  void random() {$/;"	f	class:Distribution
range_end	interval_set.h	/^  T range_end() const {$/;"	f	class:interval_set
range_start	interval_set.h	/^  T range_start() const {$/;"	f	class:interval_set
ranges	rangeset.h	/^  map<T,T> ranges;  \/\/ pair(first,last) (inclusive, e.g. [first,last])$/;"	m	struct:_rangeset_base
ranges	rangeset.h	/^  map<T,T> ranges;$/;"	m	class:rangeset_iterator
rangeset	rangeset.h	/^  rangeset() { _size = 0; }$/;"	f	class:rangeset
rangeset	rangeset.h	/^class rangeset$/;"	c
rangeset_iterator	rangeset.h	/^  rangeset_iterator() {}$/;"	f	class:rangeset_iterator
rangeset_iterator	rangeset.h	/^  rangeset_iterator(typename map<T,T>::iterator& it, map<T,T>& ranges) {$/;"	f	class:rangeset_iterator
rangeset_iterator	rangeset.h	/^class rangeset_iterator :$/;"	c
rbd_callback_t	rbd/librbd.h	/^typedef void (*rbd_callback_t)(rbd_completion_t cb, void *arg);$/;"	t
rbd_completion_t	rbd/librbd.h	/^typedef void *rbd_completion_t;$/;"	t
rbd_image_info_t	rbd/librbd.h	/^} rbd_image_info_t;$/;"	t	typeref:struct:__anon77
rbd_image_options_t	rbd/librbd.h	/^typedef void *rbd_image_options_t;$/;"	t
rbd_image_t	rbd/librbd.h	/^typedef void *rbd_image_t;$/;"	t
rbd_info	rbd_types.h	/^struct rbd_info {$/;"	s
rbd_lock_mode_t	rbd/librbd.h	/^} rbd_lock_mode_t;$/;"	t	typeref:enum:__anon84
rbd_mirror_image_info_t	rbd/librbd.h	/^} rbd_mirror_image_info_t;$/;"	t	typeref:struct:__anon81
rbd_mirror_image_state_t	rbd/librbd.h	/^} rbd_mirror_image_state_t;$/;"	t	typeref:enum:__anon80
rbd_mirror_image_status_state_t	rbd/librbd.h	/^} rbd_mirror_image_status_state_t;$/;"	t	typeref:enum:__anon82
rbd_mirror_image_status_t	rbd/librbd.h	/^} rbd_mirror_image_status_t;$/;"	t	typeref:struct:__anon83
rbd_mirror_mode_t	rbd/librbd.h	/^} rbd_mirror_mode_t;$/;"	t	typeref:enum:__anon78
rbd_mirror_peer_t	rbd/librbd.h	/^} rbd_mirror_peer_t;$/;"	t	typeref:struct:__anon79
rbd_obj_header_ondisk	rbd_types.h	/^struct rbd_obj_header_ondisk {$/;"	s
rbd_obj_snap_ondisk	rbd_types.h	/^struct rbd_obj_snap_ondisk {$/;"	s
rbd_snap_info_t	rbd/librbd.h	/^} rbd_snap_info_t;$/;"	t	typeref:struct:__anon75
rbd_snap_t	rbd/librbd.h	/^typedef void *rbd_snap_t;$/;"	t
rbd_trash_image_info_t	rbd/librbd.h	/^} rbd_trash_image_info_t;$/;"	t	typeref:struct:__anon87
rbd_trash_image_source_t	rbd/librbd.h	/^} rbd_trash_image_source_t;$/;"	t	typeref:enum:__anon86
rbd_update_callback_t	rbd/librbd.h	/^typedef void (*rbd_update_callback_t)(void *arg);$/;"	t
rbegin	compact_map.h	/^  const_reverse_iterator rbegin() const {$/;"	f	class:compact_map_base
rbegin	compact_map.h	/^  reverse_iterator rbegin() {$/;"	f	class:compact_map_base
rbegin	compact_set.h	/^  const_reverse_iterator rbegin() const {$/;"	f	class:compact_set_base
rbegin	compact_set.h	/^  reverse_iterator rbegin() {$/;"	f	class:compact_set_base
rbegin	cpp-btree/btree.h	/^  const_reverse_iterator rbegin() const {$/;"	f	class:btree::btree
rbegin	cpp-btree/btree.h	/^  reverse_iterator rbegin() {$/;"	f	class:btree::btree
rbegin	cpp-btree/btree_container.h	/^  const_reverse_iterator rbegin() const { return tree_.rbegin(); }$/;"	f	class:btree::btree_container
rbegin	cpp-btree/btree_container.h	/^  reverse_iterator rbegin() { return tree_.rbegin(); }$/;"	f	class:btree::btree_container
rdev	ceph_fs.h	/^		__le32 rdev;$/;"	m	struct:ceph_mds_request_args::__anon59
rdev	ceph_fs.h	/^		__le32 rdev;$/;"	m	struct:ceph_mds_request_args_legacy::__anon50
readable	CompatSet.h	/^  bool readable(CompatSet const& other) const {$/;"	f	struct:CompatSet
readdir	ceph_fs.h	/^	} __attribute__ ((packed)) readdir;$/;"	m	union:ceph_mds_request_args	typeref:struct:ceph_mds_request_args::__anon58
readdir	ceph_fs.h	/^	} __attribute__ ((packed)) readdir;$/;"	m	union:ceph_mds_request_args_legacy	typeref:struct:ceph_mds_request_args_legacy::__anon49
realm	ceph_fs.h	/^	__le64 ino, realm;$/;"	m	struct:ceph_mds_caps_head
realm	ceph_fs.h	/^	__le64 realm;                  \/* snap realm *\/$/;"	m	struct:ceph_mds_reply_cap
reassert_version	rados.h	/^	struct ceph_eversion reassert_version; \/* for replaying uncommitted *\/$/;"	m	struct:ceph_osd_reply_head	typeref:struct:ceph_osd_reply_head::ceph_eversion
rebind	mempool.h	/^  template<typename U> struct rebind {$/;"	s	class:mempool::pool_allocator
rebuild_path	filepath.h	/^  void rebuild_path() {$/;"	f	class:filepath
reference	cpp-btree/btree.h	/^  typedef Reference reference;$/;"	t	struct:btree::btree_iterator
reference	cpp-btree/btree.h	/^  typedef typename Params::reference reference;$/;"	t	class:btree::btree
reference	cpp-btree/btree.h	/^  typedef typename Params::reference reference;$/;"	t	class:btree::btree_node
reference	cpp-btree/btree.h	/^  typedef value_type& reference;$/;"	t	struct:btree::btree_map_params
reference	cpp-btree/btree.h	/^  typedef value_type& reference;$/;"	t	struct:btree::btree_set_params
reference	cpp-btree/btree_container.h	/^  typedef typename Tree::reference reference;$/;"	t	class:btree::btree_container
reference	mempool.h	/^  typedef value_type& reference;$/;"	t	class:mempool::pool_allocator
release	alloc_ptr.h	/^    element_type* release() {$/;"	f	class:alloc_ptr
remove	CompatSet.h	/^    void remove(const Feature& f) {$/;"	f	class:CompatSet::FeatureSet
remove	CompatSet.h	/^    void remove(uint64_t f) {$/;"	f	class:CompatSet::FeatureSet
remove	xlist.h	/^  void remove(item *i) {$/;"	f	class:xlist
remove_myself	elist.h	/^    bool remove_myself() {$/;"	f	struct:elist::item
remove_myself	xlist.h	/^    bool remove_myself() {$/;"	f	struct:xlist::item
rend	compact_map.h	/^  const_reverse_iterator rend() const {$/;"	f	class:compact_map_base
rend	compact_map.h	/^  reverse_iterator rend() {$/;"	f	class:compact_map_base
rend	compact_set.h	/^  const_reverse_iterator rend() const {$/;"	f	class:compact_set_base
rend	compact_set.h	/^  reverse_iterator rend() {$/;"	f	class:compact_set_base
rend	cpp-btree/btree.h	/^  const_reverse_iterator rend() const {$/;"	f	class:btree::btree
rend	cpp-btree/btree.h	/^  reverse_iterator rend() {$/;"	f	class:btree::btree
rend	cpp-btree/btree_container.h	/^  const_reverse_iterator rend() const { return tree_.rend(); }$/;"	f	class:btree::btree_container
rend	cpp-btree/btree_container.h	/^  reverse_iterator rend() { return tree_.rend(); }$/;"	f	class:btree::btree_container
reply_code	ceph_fs.h	/^	__le32 reply_code;$/;"	m	struct:ceph_mon_poolop_reply
reserve	denc.h	/^    static void reserve(Container& c, size_t s) {$/;"	f	struct:_denc::reserve_switch
reserve	denc.h	/^    static void reserve(Container& c, size_t s) {}$/;"	f	struct:_denc::reserve_switch
reserve_switch	denc.h	/^  struct reserve_switch<Container, false> {$/;"	s	namespace:_denc
reserve_switch	denc.h	/^  struct reserve_switch<Container, true> {$/;"	s	namespace:_denc
reserved	msgr.h	/^	__le16 reserved;$/;"	m	struct:ceph_msg_header
reserved	msgr.h	/^	__le32 reserved;$/;"	m	struct:ceph_msg_header_old
reserved	rbd_types.h	/^	__le32 reserved;$/;"	m	struct:rbd_obj_header_ondisk
reset	alloc_ptr.h	/^    void reset(element_type *p = nullptr) {$/;"	f	class:alloc_ptr
result	Context.h	/^  int result;$/;"	m	class:C_GatherBase
result	ceph_fs.h	/^	__le32 result;$/;"	m	struct:ceph_mds_reply_head
result	rados.h	/^	__le32 result;                    \/* result code *\/$/;"	m	struct:ceph_osd_reply_head
reverse_iterator	compact_map.h	/^      reverse_iterator() { }$/;"	f	class:compact_map_base::reverse_iterator
reverse_iterator	compact_map.h	/^      reverse_iterator(compact_map_base* m) : iterator_base<typename Map::reverse_iterator>(m) { }$/;"	f	class:compact_map_base::reverse_iterator
reverse_iterator	compact_map.h	/^      reverse_iterator(compact_map_base* m, const typename Map::reverse_iterator& i)$/;"	f	class:compact_map_base::reverse_iterator
reverse_iterator	compact_map.h	/^      reverse_iterator(const iterator_base<typename Map::reverse_iterator>& o)$/;"	f	class:compact_map_base::reverse_iterator
reverse_iterator	compact_map.h	/^  class reverse_iterator : public iterator_base<typename Map::reverse_iterator> {$/;"	c	class:compact_map_base
reverse_iterator	compact_set.h	/^      reverse_iterator() { }$/;"	f	class:compact_set_base::reverse_iterator
reverse_iterator	compact_set.h	/^      reverse_iterator(compact_set_base* s) : iterator_base<typename Set::reverse_iterator>(s) { }$/;"	f	class:compact_set_base::reverse_iterator
reverse_iterator	compact_set.h	/^      reverse_iterator(compact_set_base* s, const typename Set::reverse_iterator& i)$/;"	f	class:compact_set_base::reverse_iterator
reverse_iterator	compact_set.h	/^      reverse_iterator(const iterator_base<typename Set::reverse_iterator>& o)$/;"	f	class:compact_set_base::reverse_iterator
reverse_iterator	compact_set.h	/^  class reverse_iterator : public iterator_base<typename Set::reverse_iterator> {$/;"	c	class:compact_set_base
reverse_iterator	cpp-btree/btree.h	/^  typedef std::reverse_iterator<iterator> reverse_iterator;$/;"	t	class:btree::btree
reverse_iterator	cpp-btree/btree_container.h	/^  typedef typename Tree::reverse_iterator reverse_iterator;$/;"	t	class:btree::btree_container
rgw	rados/rgw_file.h	/^  librgw_t rgw;$/;"	m	struct:rgw_fs
rgw_fh_callback_t	rados/rgw_file.h	/^typedef void (*rgw_fh_callback_t)(void *handle, struct rgw_fh_hk fh_hk);$/;"	t
rgw_fh_hk	rados/rgw_file.h	/^struct rgw_fh_hk {$/;"	s
rgw_fh_type	rados/rgw_file.h	/^enum rgw_fh_type {$/;"	g
rgw_file_handle	rados/rgw_file.h	/^struct rgw_file_handle$/;"	s
rgw_fs	rados/rgw_file.h	/^struct rgw_fs$/;"	s
rgw_readdir_cb	rados/rgw_file.h	/^typedef bool (*rgw_readdir_cb)(const char *name, void *arg, uint64_t offset,$/;"	t
rgw_statvfs	rados/rgw_file.h	/^struct rgw_statvfs {$/;"	s
rgw_uio	rados/rgw_file.h	/^struct rgw_uio {$/;"	s
rgw_uio	rados/rgw_file.h	/^typedef struct rgw_uio rgw_uio;$/;"	t	typeref:struct:rgw_uio
rgw_uio_release	rados/rgw_file.h	/^typedef void (*rgw_uio_release)(struct rgw_uio *, uint32_t);$/;"	t
rgw_vio	rados/rgw_file.h	/^struct rgw_vio {$/;"	s
rhs	alloc_ptr.h	/^    alloc_ptr(const alloc_ptr<pointer>& rhs) = delete;$/;"	m	class:alloc_ptr
right_child	frag.h	/^  frag_t right_child() const { return frag_t(ceph_frag_right_child(_enc)); }$/;"	f	class:frag_t
rightmost	cpp-btree/btree.h	/^    btree_node *rightmost;$/;"	m	struct:btree::btree_node::root_fields
rightmost	cpp-btree/btree.h	/^  btree_node* rightmost() const { return fields_.rightmost; }$/;"	f	class:btree::btree_node
rightmost	cpp-btree/btree.h	/^  const node_type* rightmost() const {$/;"	f	class:btree::btree
rightmost	cpp-btree/btree.h	/^  node_type* rightmost() {$/;"	f	class:btree::btree
rjhash	hash.h	/^template <class _Key> struct rjhash { };$/;"	s
rjhash	hash.h	/^template<> struct rjhash<uint32_t> {$/;"	s
rjhash	hash.h	/^template<> struct rjhash<uint64_t> {$/;"	s
rjhash32	hash.h	/^inline uint32_t rjhash32(uint32_t a) {$/;"	f
rjhash64	hash.h	/^inline uint64_t rjhash64(uint64_t key) {$/;"	f
ro_compat	CompatSet.h	/^  FeatureSet ro_compat;$/;"	m	struct:CompatSet
root	cpp-btree/btree.h	/^  const node_type* root() const { return root_.data; }$/;"	f	class:btree::btree
root	cpp-btree/btree.h	/^  node_type* root() { return root_.data; }$/;"	f	class:btree::btree
root_	cpp-btree/btree.h	/^  empty_base_handle<internal_allocator_type, node_type*> root_;$/;"	m	class:btree::btree
root_fh	rados/rgw_file.h	/^  struct rgw_file_handle* root_fh;$/;"	m	struct:rgw_fs	typeref:struct:rgw_fs::rgw_file_handle
root_fields	cpp-btree/btree.h	/^  struct root_fields : public internal_fields {$/;"	s	class:btree::btree_node
root_fields	cpp-btree/btree.h	/^  typedef typename node_type::root_fields root_fields;$/;"	t	class:btree::btree
round_to_hour	utime.h	/^  utime_t round_to_hour() {$/;"	f	class:utime_t
round_to_minute	utime.h	/^  utime_t round_to_minute() {$/;"	f	class:utime_t
rule	ceph_fs.h	/^		__u8 rule; \/* currently fcntl or flock *\/$/;"	m	struct:ceph_mds_request_args::__anon64
rule	ceph_fs.h	/^		__u8 rule; \/* currently fcntl or flock *\/$/;"	m	struct:ceph_mds_request_args_legacy::__anon55
safe	ceph_fs.h	/^	__u8 safe;                     \/* true if committed to disk *\/$/;"	m	struct:ceph_mds_reply_head
sample	Distribution.h	/^  int sample() {$/;"	f	class:Distribution
saved_state	coredumpctl.h	/^  int saved_state = -1;$/;"	m	struct:PrCtl
scope_guard	scope_guard.h	/^  scope_guard(F &&f) : f(std::move(f)) {}$/;"	f	struct:scope_guard
scope_guard	scope_guard.h	/^struct scope_guard {$/;"	s
search_type	cpp-btree/btree.h	/^    linear_search_type, binary_search_type>::type search_type;$/;"	t	class:btree::btree_node
sec	utime.h	/^  time_t        sec()  const { return tv.tv_sec; } $/;"	f	class:utime_t
sec_ref	utime.h	/^  __u32&         sec_ref()  { return tv.tv_sec; }$/;"	f	class:utime_t
selected_oi	rados/rados_types.hpp	/^  bool selected_oi = false;$/;"	m	struct:librados::shard_info_t
self_type	cpp-btree/btree.h	/^  typedef btree<Params> self_type;$/;"	t	class:btree::btree
self_type	cpp-btree/btree.h	/^  typedef btree_iterator<Node, Reference, Pointer> self_type;$/;"	t	struct:btree::btree_iterator
self_type	cpp-btree/btree.h	/^  typedef btree_node<Params> self_type;$/;"	t	class:btree::btree_node
self_type	cpp-btree/btree_container.h	/^  typedef btree_container<Tree> self_type;$/;"	t	class:btree::btree_container
self_type	cpp-btree/btree_container.h	/^  typedef btree_map_container<Tree> self_type;$/;"	t	class:btree::btree_map_container
self_type	cpp-btree/btree_container.h	/^  typedef btree_multi_container<Tree> self_type;$/;"	t	class:btree::btree_multi_container
self_type	cpp-btree/btree_container.h	/^  typedef btree_unique_container<Tree> self_type;$/;"	t	class:btree::btree_unique_container
self_type	cpp-btree/btree_map.h	/^  typedef btree_map<Key, Value, Compare, Alloc, TargetNodeSize> self_type;$/;"	t	class:btree::btree_map
self_type	cpp-btree/btree_map.h	/^  typedef btree_multimap<Key, Value, Compare, Alloc, TargetNodeSize> self_type;$/;"	t	class:btree::btree_multimap
self_type	cpp-btree/btree_set.h	/^  typedef btree_multiset<Key, Compare, Alloc, TargetNodeSize> self_type;$/;"	t	class:btree::btree_multiset
self_type	cpp-btree/btree_set.h	/^  typedef btree_set<Key, Compare, Alloc, TargetNodeSize> self_type;$/;"	t	class:btree::btree_set
seq	ceph_fs.h	/^	__le32 migrate_seq, seq;$/;"	m	struct:ceph_mds_cap_item
seq	ceph_fs.h	/^	__le32 seq, issue_seq, mseq;$/;"	m	struct:ceph_mds_request_release
seq	ceph_fs.h	/^	__le32 seq, issue_seq;$/;"	m	struct:ceph_mds_caps_head
seq	ceph_fs.h	/^	__le32 seq, mseq;$/;"	m	struct:ceph_mds_reply_cap
seq	ceph_fs.h	/^	__le32 seq;$/;"	m	struct:ceph_mds_cap_peer
seq	ceph_fs.h	/^	__le32 seq;$/;"	m	struct:ceph_mds_lease
seq	ceph_fs.h	/^	__le32 seq;$/;"	m	struct:ceph_mds_reply_lease
seq	ceph_fs.h	/^	__le64 seq;           \/* snap: version *\/$/;"	m	struct:ceph_mds_snap_realm
seq	ceph_fs.h	/^	__le64 seq;     \/* snap seq for this snap realm *\/$/;"	m	struct:ceph_mds_snaprealm_reconnect
seq	ceph_fs.h	/^	__le64 seq;$/;"	m	struct:ceph_mds_session_head
seq	msgr.h	/^	__le64 seq;       \/* message seq# for this session *\/$/;"	m	struct:ceph_msg_header
seq	msgr.h	/^	__le64 seq;       \/* message seq# for this session *\/$/;"	m	struct:ceph_msg_header_old
seq	rados/rados_types.hpp	/^  snap_t seq;   \/\/ newest snapid seen by the object$/;"	m	struct:librados::snap_set_t
session_mon	ceph_fs.h	/^	__le16 session_mon;$/;"	m	struct:ceph_mon_request_header
session_mon_tid	ceph_fs.h	/^	__le64 session_mon_tid;$/;"	m	struct:ceph_mon_request_header
set	bitmapper.h	/^  void set(int b) {$/;"	f	class:bitmapper
set	compact_set.h	/^    const compact_set_base* set;$/;"	m	class:compact_set_base::iterator_base
set	compact_set.h	/^  std::unique_ptr<Set> set;$/;"	m	class:compact_set_base
set_child	cpp-btree/btree.h	/^  void set_child(int i, btree_node *c) {$/;"	f	class:btree::btree_node
set_count	cpp-btree/btree.h	/^  void set_count(int v) { fields_.count = v; }$/;"	f	class:btree::btree_node
set_data	bitmapper.h	/^  void set_data(char *data, int len) { _data = data; _len = len; }$/;"	f	class:bitmapper
set_dumpable	coredumpctl.h	/^  int set_dumpable(int new_state) {$/;"	f	struct:PrCtl
set_finisher	Context.h	/^  void set_finisher(ContextType *finisher_) {$/;"	f	class:C_GatherBuilderBase
set_finisher	Context.h	/^  void set_finisher(ContextType *onfinish_) {$/;"	f	class:C_GatherBase
set_from_double	utime.h	/^  void set_from_double(double d) { $/;"	f	class:utime_t
set_from_timeval	utime.h	/^  void set_from_timeval(const struct timeval *v) {$/;"	f	class:utime_t
set_len	interval_set.h	/^        void set_len(T len) {$/;"	f	class:interval_set::iterator
set_length	buffer.h	/^    void set_length(unsigned l) {$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
set_length	rados/buffer.h	/^    void set_length(unsigned l) {$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
set_offset	buffer.h	/^    void set_offset(unsigned o) {$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
set_offset	rados/buffer.h	/^    void set_offset(unsigned o) {$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
set_path	filepath.h	/^  void set_path(boost::string_view s) {$/;"	f	class:filepath
set_path	filepath.h	/^  void set_path(boost::string_view s, inodeno_t b) {$/;"	f	class:filepath
set_position	cpp-btree/btree.h	/^  void set_position(int v) { fields_.position = v; }$/;"	f	class:btree::btree_node
setattr	ceph_fs.h	/^	} __attribute__ ((packed)) setattr;$/;"	m	union:ceph_mds_request_args	typeref:struct:ceph_mds_request_args::__anon57
setattr	ceph_fs.h	/^	} __attribute__ ((packed)) setattr;$/;"	m	union:ceph_mds_request_args_legacy	typeref:struct:ceph_mds_request_args_legacy::__anon48
setlayout	ceph_fs.h	/^	} __attribute__ ((packed)) setlayout;$/;"	m	union:ceph_mds_request_args	typeref:struct:ceph_mds_request_args::__anon63
setlayout	ceph_fs.h	/^	} __attribute__ ((packed)) setlayout;$/;"	m	union:ceph_mds_request_args_legacy	typeref:struct:ceph_mds_request_args_legacy::__anon54
setlike_details	denc.h	/^  struct setlike_details : public container_details_base<Container> {$/;"	s	namespace:_denc
setxattr	ceph_fs.h	/^	} __attribute__ ((packed)) setxattr;$/;"	m	union:ceph_mds_request_args	typeref:struct:ceph_mds_request_args::__anon62
setxattr	ceph_fs.h	/^	} __attribute__ ((packed)) setxattr;$/;"	m	union:ceph_mds_request_args_legacy	typeref:struct:ceph_mds_request_args_legacy::__anon53
shard	mempool.h	/^  shard_t shard[num_shards];$/;"	m	class:mempool::pool_t
shard	rados/rados_types.hpp	/^  int8_t shard;$/;"	m	struct:librados::osd_shard_t
shard_id_t	types.h	/^  explicit shard_id_t(int8_t _id) : id(_id) {}$/;"	f	struct:shard_id_t
shard_id_t	types.h	/^  shard_id_t() : id(0) {}$/;"	f	struct:shard_id_t
shard_id_t	types.h	/^struct shard_id_t {$/;"	s
shard_info_t	rados/rados_types.hpp	/^struct shard_info_t : err_t {$/;"	s	namespace:librados
shard_t	mempool.h	/^struct shard_t {$/;"	s	namespace:mempool
shards	rados/rados_types.hpp	/^  std::map<osd_shard_t, shard_info_t> shards;$/;"	m	struct:inconsistent_obj_t
share	buffer.h	/^    void share(const list& bl)$/;"	f	class:ceph::CEPH_BUFFER_API::list
share	rados/buffer.h	/^    void share(const list& bl)$/;"	f	class:ceph::CEPH_BUFFER_API::list
si_u_t	types.h	/^  explicit si_u_t(uint64_t _v) : v(_v) {};$/;"	f	struct:si_u_t
si_u_t	types.h	/^struct si_u_t {$/;"	s
sig	msgr.h	/^	__le64  sig;$/;"	m	struct:ceph_msg_footer
signature	rbd_types.h	/^	char signature[4];$/;"	m	struct:rbd_obj_header_ondisk
simplify	frag.h	/^  void simplify() {$/;"	f	class:fragset_t
size	ceph_fs.h	/^			__le64 size, max_size, truncate_size;$/;"	m	struct:ceph_mds_caps_body_legacy::__anon66::__anon67
size	ceph_fs.h	/^		__le64 size, old_size;       \/* old_size needed by truncate *\/$/;"	m	struct:ceph_mds_request_args::__anon57
size	ceph_fs.h	/^		__le64 size, old_size;       \/* old_size needed by truncate *\/$/;"	m	struct:ceph_mds_request_args_legacy::__anon48
size	ceph_fs.h	/^	__le64 size;$/;"	m	struct:ceph_mds_cap_reconnect_v1
size	compact_map.h	/^  size_t size() const {$/;"	f	class:compact_map_base
size	compact_set.h	/^  size_t size() const {$/;"	f	class:compact_set_base
size	cpp-btree/btree.h	/^    size_type size;$/;"	m	struct:btree::btree_node::root_fields
size	cpp-btree/btree.h	/^  size_type size() const { return fields_.size; }$/;"	f	class:btree::btree_node
size	cpp-btree/btree.h	/^  size_type size() const {$/;"	f	class:btree::btree
size	cpp-btree/btree_container.h	/^  size_type size() const { return tree_.size(); }$/;"	f	class:btree::btree_container
size	interval_set.h	/^  int64_t size() const {$/;"	f	class:interval_set
size	rados/rados_types.hpp	/^  uint64_t size = -1;$/;"	m	struct:librados::shard_info_t
size	rados/rados_types.hpp	/^  uint64_t size;$/;"	m	struct:librados::clone_info_t
size	rangeset.h	/^  unsigned size() {$/;"	f	class:rangeset
size	rbd/librbd.h	/^  uint64_t size;$/;"	m	struct:__anon75
size	rbd/librbd.h	/^  uint64_t size;$/;"	m	struct:__anon77
size	rbd/librbd.hpp	/^    uint64_t size;$/;"	m	struct:librbd::__anon69
size	xlist.h	/^  size_t size() const {$/;"	f	class:xlist
size_mismatch	rados/rados_types.hpp	/^  bool size_mismatch() const {$/;"	f	struct:inconsistent_snapset_t
size_type	cpp-btree/btree.h	/^  typedef ssize_t size_type;$/;"	t	struct:btree::btree_common_params
size_type	cpp-btree/btree.h	/^  typedef typename Node::size_type size_type;$/;"	t	struct:btree::btree_iterator
size_type	cpp-btree/btree.h	/^  typedef typename Params::size_type size_type;$/;"	t	class:btree::btree
size_type	cpp-btree/btree.h	/^  typedef typename Params::size_type size_type;$/;"	t	class:btree::btree_node
size_type	cpp-btree/btree_container.h	/^  typedef typename Tree::size_type size_type;$/;"	t	class:btree::btree_container
size_type	cpp-btree/btree_container.h	/^  typedef typename Tree::size_type size_type;$/;"	t	class:btree::btree_multi_container
size_type	cpp-btree/btree_container.h	/^  typedef typename Tree::size_type size_type;$/;"	t	class:btree::btree_unique_container
size_type	mempool.h	/^  typedef std::size_t size_type;$/;"	t	class:mempool::pool_allocator
sizeof	cpp-btree/btree.h	/^      sizeof(big_),$/;"	m	class:btree::btree
sleep	utime.h	/^  void sleep() const {$/;"	f	class:utime_t
small_	cpp-btree/btree.h	/^typedef char small_;$/;"	t	namespace:btree
snap	object.h	/^  snapid_t snap;$/;"	m	struct:sobject_t
snap	rados.h	/^	        } __attribute__ ((packed)) snap;$/;"	m	union:ceph_osd_op::__anon13	typeref:struct:ceph_osd_op::__anon13::__anon18
snap	rados/rados_types.hpp	/^  snap_t snap = 0;$/;"	m	struct:librados::object_id_t
snap_count	rbd_types.h	/^	__le32 snap_count;$/;"	m	struct:rbd_obj_header_ondisk
snap_follows	ceph_fs.h	/^	__le64 snap_follows;$/;"	m	struct:ceph_mds_caps_head
snap_info_t	rbd/librbd.hpp	/^  } snap_info_t;$/;"	t	namespace:librbd	typeref:struct:librbd::__anon69
snap_names_len	rbd_types.h	/^	__le64 snap_names_len;$/;"	m	struct:rbd_obj_header_ondisk
snap_seq	rbd_types.h	/^	__le64 snap_seq;$/;"	m	struct:rbd_obj_header_ondisk
snap_set_t	rados/rados_types.hpp	/^  snap_set_t() : seq(0) {}$/;"	f	struct:librados::snap_set_t
snap_set_t	rados/rados_types.hpp	/^struct snap_set_t {$/;"	s	namespace:librados
snap_t	rados/rados_types.hpp	/^typedef uint64_t snap_t;$/;"	t	namespace:librados
snap_trace_len	ceph_fs.h	/^	__le32 snap_trace_len;$/;"	m	struct:ceph_mds_caps_head
snapid	ceph_fs.h	/^	__le64 snapid;$/;"	m	struct:ceph_mon_poolop
snapid	ceph_fs.h	/^	__le64 snapid;$/;"	m	struct:ceph_mon_unmanaged_snap
snapid	cephfs/libcephfs.h	/^  snapid_t snapid;$/;"	m	struct:vinodeno_t
snapid	rados.h	/^			__le64 snapid;$/;"	m	struct:ceph_osd_op::__anon13::__anon24
snapid	rados.h	/^		        __le64 snapid;$/;"	m	struct:ceph_osd_op::__anon13::__anon18
snapid_t	cephfs/libcephfs.h	/^} snapid_t;$/;"	t	typeref:struct:_snapid_t
snapid_t	object.h	/^  snapid_t(uint64_t v=0) : val(v) {}$/;"	f	struct:snapid_t
snapid_t	object.h	/^struct snapid_t {$/;"	s
snaprealm	ceph_fs.h	/^	__le64 snaprealm;$/;"	m	struct:ceph_mds_cap_reconnect
snaprealm	ceph_fs.h	/^	__le64 snaprealm;$/;"	m	struct:ceph_mds_cap_reconnect_v1
snaps	rados/rados_types.hpp	/^  std::vector<snap_t> snaps;          \/\/ ascending$/;"	m	struct:librados::clone_info_t
snaps	rbd_types.h	/^	struct rbd_obj_snap_ondisk snaps[0];$/;"	m	struct:rbd_obj_header_ondisk	typeref:struct:rbd_obj_header_ondisk::rbd_obj_snap_ondisk
snapset_corrupted	rados/rados_types.hpp	/^  bool snapset_corrupted() const {$/;"	f	struct:inconsistent_snapset_t
snapset_error	rados/rados_types.hpp	/^  bool snapset_error() const {$/;"	f	struct:inconsistent_snapset_t
snapset_mismatch	rados/rados_types.hpp	/^  bool snapset_mismatch() const {    \/\/ Compatibility$/;"	f	struct:inconsistent_snapset_t
snapset_missing	rados/rados_types.hpp	/^  bool snapset_missing() const {$/;"	f	struct:inconsistent_snapset_t
snprintf	utime.h	/^  static int snprintf(char *out, int outlen, time_t tt) {$/;"	f	class:utime_t
sobject_t	object.h	/^  sobject_t() : snap(0) {}$/;"	f	struct:sobject_t
sobject_t	object.h	/^  sobject_t(object_t o, snapid_t s) : oid(o), snap(s) {}$/;"	f	struct:sobject_t
sobject_t	object.h	/^struct sobject_t {$/;"	s
source	rbd/librbd.h	/^  rbd_trash_image_source_t source;$/;"	m	struct:__anon87
source	rbd/librbd.hpp	/^    rbd_trash_image_source_t source;$/;"	m	struct:librbd::__anon74
span_of	interval_set.h	/^  void span_of(const interval_set &other, T start, T len) {$/;"	f	class:interval_set
spinlock	Spinlock.h	/^    const Spinlock& spinlock;$/;"	m	class:Spinlock::Locker
split	ceph_fs.h	/^	__le64 split;             \/* ino to split off, if any *\/$/;"	m	struct:ceph_mds_snap_head
split	frag.h	/^  void split(frag_t x, int b, bool simplify=true) {$/;"	f	class:fragtree_t
split	frag.h	/^  void split(int nb, std::list<frag_t>& fragments) const {$/;"	f	class:frag_t
splits	ceph_fs.h	/^	struct ceph_frag_tree_split splits[];$/;"	m	struct:ceph_frag_tree_head	typeref:struct:ceph_frag_tree_head::ceph_frag_tree_split
sprintf	utime.h	/^  int sprintf(char *out, int outlen) const {$/;"	f	class:utime_t
src	msgr.h	/^	struct ceph_entity_inst src, orig_src;$/;"	m	struct:ceph_msg_header_old	typeref:struct:ceph_msg_header_old::ceph_entity_inst
src	msgr.h	/^	struct ceph_entity_name src;$/;"	m	struct:ceph_msg_header	typeref:struct:ceph_msg_header::ceph_entity_name
src_fadvise_flags	rados.h	/^			__le32 src_fadvise_flags;$/;"	m	struct:ceph_osd_op::__anon13::__anon24
src_offset	rados.h	/^			__le64 src_offset;$/;"	m	struct:ceph_osd_op::__anon13::__anon22
src_version	rados.h	/^			__le64 src_version;$/;"	m	struct:ceph_osd_op::__anon13::__anon24
ss_attr_corrupted	rados/rados_types.hpp	/^  bool ss_attr_corrupted() const {   \/\/ Compatibility$/;"	f	struct:inconsistent_snapset_t
ss_attr_missing	rados/rados_types.hpp	/^  bool ss_attr_missing() const {     \/\/ Compatibility$/;"	f	struct:inconsistent_snapset_t
ss_bl	rados/rados_types.hpp	/^  ceph::bufferlist ss_bl;$/;"	m	struct:inconsistent_snapset_t
st	ceph_fs.h	/^	struct ceph_statfs st;$/;"	m	struct:ceph_mon_statfs_reply	typeref:struct:ceph_mon_statfs_reply::ceph_statfs
st_atim	statlite.h	/^  struct timespec st_atim;            \/* Time of last access.  *\/$/;"	m	struct:statlite	typeref:struct:statlite::timespec
st_blksize	statlite.h	/^  blksize_t     st_blksize;  \/* blocksize for filesystem I\/O *\/$/;"	m	struct:statlite
st_blocks	statlite.h	/^  blkcnt_t      st_blocks;   \/* number of blocks allocated   *\/$/;"	m	struct:statlite
st_ctim	statlite.h	/^  struct timespec st_ctim;            \/* Time of last status change.  *\/$/;"	m	struct:statlite	typeref:struct:statlite::timespec
st_dev	statlite.h	/^  dev_t         st_dev;      \/* device *\/$/;"	m	struct:statlite
st_gid	statlite.h	/^  gid_t         st_gid;      \/* group ID of owner *\/$/;"	m	struct:statlite
st_ino	statlite.h	/^  ino_t         st_ino;      \/* inode *\/$/;"	m	struct:statlite
st_litemask	statlite.h	/^  unsigned long st_litemask; \/* bit mask for optional fields *\/$/;"	m	struct:statlite
st_mode	statlite.h	/^  mode_t        st_mode;     \/* protection *\/$/;"	m	struct:statlite
st_mtim	statlite.h	/^  struct timespec st_mtim;            \/* Time of last modification.  *\/$/;"	m	struct:statlite	typeref:struct:statlite::timespec
st_nlink	statlite.h	/^  nlink_t       st_nlink;    \/* number of hard links *\/$/;"	m	struct:statlite
st_rdev	statlite.h	/^  dev_t         st_rdev;     \/* device type (if inode device)*\/$/;"	m	struct:statlite
st_size	statlite.h	/^  off_t         st_size;     \/* total size, in bytes         *\/$/;"	m	struct:statlite
st_uid	statlite.h	/^  uid_t         st_uid;      \/* user ID of owner *\/$/;"	m	struct:statlite
stamp	ceph_fs.h	/^	struct ceph_timespec stamp;$/;"	m	struct:ceph_mds_session_head	typeref:struct:ceph_mds_session_head::ceph_timespec
stamp	rados.h	/^			struct ceph_timespec stamp;$/;"	m	struct:ceph_osd_op::__anon13::__anon25	typeref:struct:ceph_osd_op::__anon13::__anon25::ceph_timespec
start	buffer.h	/^      const char *start; \/\/\/< starting pointer into bp->c_str()$/;"	m	class:ceph::CEPH_BUFFER_API::ptr::iterator
start	buffer.h	/^    unsigned start() const { return _off; }$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
start	ceph_fs.h	/^		__le64 start; \/* initial location to lock *\/$/;"	m	struct:ceph_mds_request_args::__anon64
start	ceph_fs.h	/^		__le64 start; \/* initial location to lock *\/$/;"	m	struct:ceph_mds_request_args_legacy::__anon55
start	ceph_fs.h	/^	__le32 start;$/;"	m	struct:ceph_osd_getmap
start	ceph_fs.h	/^	__le64 start;$/;"	m	struct:ceph_mon_subscribe_item
start	ceph_fs.h	/^	__le64 start;\/* file offset to start lock at *\/$/;"	m	struct:ceph_filelock
start	rados/buffer.h	/^      const char *start; \/\/\/< starting pointer into bp->c_str()$/;"	m	class:ceph::CEPH_BUFFER_API::ptr::iterator
start	rados/buffer.h	/^    unsigned start() const { return _off; }$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
start_after	interval_set.h	/^  T start_after(T i) const {$/;"	f	class:interval_set
start_epoch	rados.h	/^			__le32 start_epoch; \/* for the pgls sequence *\/$/;"	m	struct:ceph_osd_op::__anon13::__anon17
starts_after	interval_set.h	/^  bool starts_after(T i) const {$/;"	f	class:interval_set
stat_get_atime_nsec	stat.h	/^static inline uint32_t stat_get_atime_nsec(struct stat *st)$/;"	f
stat_get_atime_sec	stat.h	/^static inline uint32_t stat_get_atime_sec(struct stat *st)$/;"	f
stat_get_ctime_nsec	stat.h	/^static inline uint32_t stat_get_ctime_nsec(struct stat *st)$/;"	f
stat_get_ctime_sec	stat.h	/^static inline uint32_t stat_get_ctime_sec(struct stat *st)$/;"	f
stat_get_mtime_nsec	stat.h	/^static inline uint32_t stat_get_mtime_nsec(struct stat *st)$/;"	f
stat_get_mtime_sec	stat.h	/^static inline uint32_t stat_get_mtime_sec(struct stat *st)$/;"	f
stat_set_atime_nsec	stat.h	/^static inline void stat_set_atime_nsec(struct stat *st, uint32_t nsec)$/;"	f
stat_set_atime_sec	stat.h	/^static inline void stat_set_atime_sec(struct stat *st, uint32_t sec)$/;"	f
stat_set_ctime_nsec	stat.h	/^static inline void stat_set_ctime_nsec(struct stat *st, uint32_t nsec)$/;"	f
stat_set_ctime_sec	stat.h	/^static inline void stat_set_ctime_sec(struct stat *st, uint32_t sec)$/;"	f
stat_set_mtime_nsec	stat.h	/^static inline void stat_set_mtime_nsec(struct stat *st, uint32_t nsec)$/;"	f
stat_set_mtime_sec	stat.h	/^static inline void stat_set_mtime_sec(struct stat *st, uint32_t sec)$/;"	f
state	rbd/librbd.h	/^  rbd_mirror_image_state_t state;$/;"	m	struct:__anon81
state	rbd/librbd.h	/^  rbd_mirror_image_status_state_t state;$/;"	m	struct:__anon83
state	rbd/librbd.hpp	/^    mirror_image_state_t state;$/;"	m	struct:librbd::__anon72
state	rbd/librbd.hpp	/^    mirror_image_status_state_t state;$/;"	m	struct:librbd::__anon73
statlite	statlite.h	/^struct statlite {$/;"	s
stats_map	rados/librados.hpp	/^  typedef std::map<std::string, pool_stat_t> stats_map;$/;"	t	namespace:librados
stats_t	mempool.h	/^struct stats_t {$/;"	s	namespace:mempool
std	fs_types.h	/^namespace std {$/;"	n
std	object.h	/^namespace std {$/;"	n
str_join	str_list.h	/^inline std::string str_join(const std::vector<std::string>& v, std::string sep)$/;"	f
stringify	stringify.h	/^inline std::string stringify(const T& a) {$/;"	f
stripe_count	ceph_fs.h	/^		__le32 stripe_count;         \/* ... *\/$/;"	m	struct:ceph_mds_request_args::__anon61
stripe_count	ceph_fs.h	/^		__le32 stripe_count;         \/* ... *\/$/;"	m	struct:ceph_mds_request_args_legacy::__anon52
stripe_count	fs_types.h	/^  uint32_t stripe_count;  \/\/\/< over this many objects$/;"	m	struct:file_layout_t
stripe_unit	ceph_fs.h	/^		__le32 stripe_unit;          \/* layout for newly created file *\/$/;"	m	struct:ceph_mds_request_args::__anon61
stripe_unit	ceph_fs.h	/^		__le32 stripe_unit;          \/* layout for newly created file *\/$/;"	m	struct:ceph_mds_request_args_legacy::__anon52
stripe_unit	fs_types.h	/^  uint32_t stripe_unit;   \/\/\/< stripe unit, in bytes,$/;"	m	struct:file_layout_t
stx_atime	cephfs/ceph_statx.h	/^	struct timespec	stx_atime;$/;"	m	struct:ceph_statx	typeref:struct:ceph_statx::timespec
stx_blksize	cephfs/ceph_statx.h	/^	uint32_t	stx_blksize;$/;"	m	struct:ceph_statx
stx_blocks	cephfs/ceph_statx.h	/^	uint64_t	stx_blocks;$/;"	m	struct:ceph_statx
stx_btime	cephfs/ceph_statx.h	/^	struct timespec	stx_btime;$/;"	m	struct:ceph_statx	typeref:struct:ceph_statx::timespec
stx_ctime	cephfs/ceph_statx.h	/^	struct timespec	stx_ctime;$/;"	m	struct:ceph_statx	typeref:struct:ceph_statx::timespec
stx_dev	cephfs/ceph_statx.h	/^	dev_t		stx_dev;$/;"	m	struct:ceph_statx
stx_gid	cephfs/ceph_statx.h	/^	uint32_t	stx_gid;$/;"	m	struct:ceph_statx
stx_ino	cephfs/ceph_statx.h	/^	uint64_t	stx_ino;$/;"	m	struct:ceph_statx
stx_mask	cephfs/ceph_statx.h	/^	uint32_t	stx_mask;$/;"	m	struct:ceph_statx
stx_mode	cephfs/ceph_statx.h	/^	uint16_t	stx_mode;$/;"	m	struct:ceph_statx
stx_mtime	cephfs/ceph_statx.h	/^	struct timespec	stx_mtime;$/;"	m	struct:ceph_statx	typeref:struct:ceph_statx::timespec
stx_nlink	cephfs/ceph_statx.h	/^	uint32_t	stx_nlink;$/;"	m	struct:ceph_statx
stx_rdev	cephfs/ceph_statx.h	/^	dev_t		stx_rdev;$/;"	m	struct:ceph_statx
stx_size	cephfs/ceph_statx.h	/^	uint64_t	stx_size;$/;"	m	struct:ceph_statx
stx_uid	cephfs/ceph_statx.h	/^	uint32_t	stx_uid;$/;"	m	struct:ceph_statx
stx_version	cephfs/ceph_statx.h	/^	uint64_t	stx_version;$/;"	m	struct:ceph_statx
sub_created_count	Context.h	/^  int sub_created_count;$/;"	m	class:C_GatherBase
sub_existing_count	Context.h	/^  int sub_existing_count;$/;"	m	class:C_GatherBase
sub_finish	Context.h	/^  void sub_finish(ContextType* sub, int r) {$/;"	f	class:C_GatherBase
subset_of	interval_set.h	/^  bool subset_of(const interval_set &big) const {$/;"	f	class:interval_set
subset_of	interval_set.h	/^  void subset_of(const interval_set &other, T start, T end) {$/;"	f	class:interval_set
subset_size_sym	interval_set.h	/^  bool subset_size_sym(const interval_set &b) const {$/;"	f	class:interval_set
subtract	interval_set.h	/^  void subtract(const interval_set &a) {$/;"	f	class:interval_set
super_type	cpp-btree/btree_container.h	/^  typedef btree_container<Tree> super_type;$/;"	t	class:btree::btree_multi_container
super_type	cpp-btree/btree_container.h	/^  typedef btree_container<Tree> super_type;$/;"	t	class:btree::btree_unique_container
super_type	cpp-btree/btree_container.h	/^  typedef btree_unique_container<Tree> super_type;$/;"	t	class:btree::btree_map_container
super_type	cpp-btree/btree_map.h	/^  typedef btree_map_container<btree_type> super_type;$/;"	t	class:btree::btree_map
super_type	cpp-btree/btree_map.h	/^  typedef btree_multi_container<btree_type> super_type;$/;"	t	class:btree::btree_multimap
super_type	cpp-btree/btree_set.h	/^  typedef btree_multi_container<btree_type> super_type;$/;"	t	class:btree::btree_multiset
super_type	cpp-btree/btree_set.h	/^  typedef btree_unique_container<btree_type> super_type;$/;"	t	class:btree::btree_set
supported	denc.h	/^    static constexpr bool supported = (denc_traits<T>::supported &&$/;"	m	struct:_denc::tuple_traits
supported	denc.h	/^    static constexpr bool supported = true;$/;"	m	struct:_denc::container_base
supported	denc.h	/^    static constexpr bool supported = true;$/;"	m	struct:_denc::tuple_traits
supported	denc.h	/^  static constexpr bool supported = false;$/;"	m	struct:denc_traits
supported	denc.h	/^  static constexpr bool supported = true;$/;"	m	struct:denc_traits
supported	fs_types.h	/^  static constexpr bool supported = true;$/;"	m	struct:denc_traits
supported	health.h	/^  static constexpr bool supported = true;$/;"	m	struct:denc_traits
supported	interval_set.h	/^  static constexpr bool supported = true;$/;"	m	struct:denc_traits
supported	object.h	/^  static constexpr bool supported = true;$/;"	m	struct:denc_traits
swab	byteorder.h	/^swab(T val) {$/;"	f
swap	alloc_ptr.h	/^    void swap (alloc_ptr<pointer>& rhs) {$/;"	f	class:alloc_ptr
swap	compact_map.h	/^  void swap(compact_map_base& o) {$/;"	f	class:compact_map_base
swap	compact_set.h	/^  void swap(compact_set_base& o) {$/;"	f	class:compact_set_base
swap	cpp-btree/btree.h	/^  static void swap(mutable_value_type *a, mutable_value_type *b) {$/;"	f	struct:btree::btree_map_params
swap	cpp-btree/btree.h	/^  static void swap(mutable_value_type *a, mutable_value_type *b) {$/;"	f	struct:btree::btree_set_params
swap	cpp-btree/btree_container.h	/^  void swap(self_type &x) {$/;"	f	class:btree::btree_container
swap	cpp-btree/btree_map.h	/^inline void swap(btree_map<K, V, C, A, N> &x,$/;"	f	namespace:btree
swap	cpp-btree/btree_map.h	/^inline void swap(btree_multimap<K, V, C, A, N> &x,$/;"	f	namespace:btree
swap	cpp-btree/btree_set.h	/^inline void swap(btree_multiset<K, C, A, N> &x,$/;"	f	namespace:btree
swap	cpp-btree/btree_set.h	/^inline void swap(btree_set<K, C, A, N> &x, btree_set<K, C, A, N> &y) {$/;"	f	namespace:btree
swap	frag.h	/^  void swap(fragtree_t& other) {$/;"	f	class:fragtree_t
swap	interval_set.h	/^  void swap(interval_set<T,Map>& other) {$/;"	f	class:interval_set
swap	object.h	/^  void swap(object_t& o) {$/;"	f	struct:object_t
swap	object.h	/^  void swap(sobject_t& o) {$/;"	f	struct:sobject_t
t	Context.h	/^  T t;$/;"	m	struct:LambdaContext
tag	msgr.h	/^	__u8 tag;$/;"	m	struct:ceph_msg_connect_reply
take	Context.h	/^  void take(std::list<ContextType*>& ls) {$/;"	f	class:C_ContextsBase
text	rbd_types.h	/^	char text[40];$/;"	m	struct:rbd_obj_header_ondisk
theset	rangeset.h	/^  _rangeset_base<T> theset;$/;"	m	class:rangeset
tid	msgr.h	/^	__le64 tid;       \/* transaction id *\/$/;"	m	struct:ceph_msg_header
tid	msgr.h	/^	__le64 tid;       \/* transaction id *\/$/;"	m	struct:ceph_msg_header_old
time_warp_seq	ceph_fs.h	/^			__le32 time_warp_seq;$/;"	m	struct:ceph_mds_caps_body_legacy::__anon66::__anon67
timeout	rados.h	/^			__u32 timeout; \/* connection timeout *\/$/;"	m	struct:ceph_osd_op::__anon13::__anon19
timeout_seconds	rados/rados_types.h	/^  uint32_t timeout_seconds;$/;"	m	struct:obj_watch_t
tmap2omap	rados.h	/^		} __attribute__ ((packed)) tmap2omap;$/;"	m	union:ceph_osd_op::__anon13	typeref:struct:ceph_osd_op::__anon13::__anon26
to_msec	utime.h	/^  uint64_t to_msec() const {$/;"	f	class:utime_t
to_nsec	utime.h	/^  uint64_t to_nsec() const {$/;"	f	class:utime_t
to_real_time	utime.h	/^  real_time to_real_time() const {$/;"	f	class:utime_t
to_run	Context.h	/^  Context *to_run;$/;"	m	struct:RunOnDelete
to_run	Context.h	/^  Context *to_run;$/;"	m	struct:Wrapper
to_string	uuid.h	/^ std::string to_string() const {$/;"	f	struct:uuid_d
to_timespec	utime.h	/^  void to_timespec(struct timespec *ts) const {$/;"	f	class:utime_t
toggle	bitmapper.h	/^  void toggle(int b) {$/;"	f	class:bitmapper
top	lru.h	/^  LRUList top, bottom, pintail;$/;"	m	class:LRU
trace_len	ceph_fs.h	/^	__le32 trace_len;         \/* size of snap trace blob *\/$/;"	m	struct:ceph_mds_snap_head
trash_image_info_t	rbd/librbd.hpp	/^  } trash_image_info_t;$/;"	t	namespace:librbd	typeref:struct:librbd::__anon74
tree_	cpp-btree/btree_container.h	/^  Tree tree_;$/;"	m	class:btree::btree_container
truncate_seq	ceph_fs.h	/^			__le32 truncate_seq;$/;"	m	struct:ceph_mds_caps_body_legacy::__anon66::__anon67
truncate_seq	rados.h	/^			__le32 truncate_seq;$/;"	m	struct:ceph_osd_op::__anon13::__anon14
truncate_size	ceph_fs.h	/^			__le64 size, max_size, truncate_size;$/;"	m	struct:ceph_mds_caps_body_legacy::__anon66::__anon67
truncate_size	rados.h	/^			__le64 truncate_size;$/;"	m	struct:ceph_osd_op::__anon13::__anon14
try_assimilate_children	frag.h	/^  void try_assimilate_children(frag_t x) {$/;"	f	class:fragtree_t
tuple_traits	denc.h	/^  struct tuple_traits<> {$/;"	s	namespace:_denc
tuple_traits	denc.h	/^  struct tuple_traits<T, Ts...> {$/;"	s	namespace:_denc
tv	utime.h	/^  } tv;$/;"	m	class:utime_t	typeref:struct:utime_t::__anon31
tv_nsec	rados.h	/^	__le32 tv_nsec;$/;"	m	struct:ceph_timespec
tv_nsec	utime.h	/^    __u32 tv_sec, tv_nsec;$/;"	m	struct:utime_t::__anon31
tv_sec	rados.h	/^	__le32 tv_sec;$/;"	m	struct:ceph_timespec
tv_sec	utime.h	/^    __u32 tv_sec, tv_nsec;$/;"	m	struct:utime_t::__anon31
type	ceph_fs.h	/^		__u8 type; \/* shared, exclusive, remove*\/$/;"	m	struct:ceph_mds_request_args::__anon64
type	ceph_fs.h	/^		__u8 type; \/* shared, exclusive, remove*\/$/;"	m	struct:ceph_mds_request_args_legacy::__anon55
type	ceph_fs.h	/^	__u8 type; \/* shared lock, exclusive lock, or unlock *\/$/;"	m	struct:ceph_filelock
type	cpp-btree/btree.h	/^  typedef A type;$/;"	t	struct:btree::if_
type	cpp-btree/btree.h	/^  typedef B type;$/;"	t	struct:btree::if_
type	mempool.h	/^  type_t *type = nullptr;$/;"	m	class:mempool::pool_allocator
type	msgr.h	/^	__le16 type;      \/* message type *\/$/;"	m	struct:ceph_msg_header
type	msgr.h	/^	__le16 type;      \/* message type *\/$/;"	m	struct:ceph_msg_header_old
type	msgr.h	/^	__le32 type;$/;"	m	struct:ceph_entity_addr
type	msgr.h	/^	__u8 type;      \/* CEPH_ENTITY_TYPE_* *\/$/;"	m	struct:ceph_entity_name
type	rados.h	/^			__u8 type;              \/* CEPH_OSD_CHECKSUM_OP_TYPE_* *\/$/;"	m	struct:ceph_osd_op::__anon13::__anon29
type_info_hash	mempool.h	/^struct type_info_hash {$/;"	s	namespace:mempool
type_map	mempool.h	/^  std::unordered_map<const char *, type_t> type_map;$/;"	m	class:mempool::pool_t
type_name	mempool.h	/^  const char *type_name;$/;"	m	struct:mempool::type_t
type_t	mempool.h	/^struct type_t {$/;"	s	namespace:mempool
uid	ceph_fs.h	/^		__le32 uid;$/;"	m	struct:ceph_mds_request_args::__anon57
uid	ceph_fs.h	/^		__le32 uid;$/;"	m	struct:ceph_mds_request_args_legacy::__anon48
uid	ceph_fs.h	/^	__le32 uid, gid, mode;$/;"	m	struct:ceph_mds_caps_head
uint128_t	inline_memory.h	/^typedef unsigned uint128_t __attribute__ ((mode (TI)));$/;"	t
uint128_t	rados/inline_memory.h	/^typedef unsigned uint128_t __attribute__ ((mode (TI)));$/;"	t
uint16_t	cpp-btree/btree.h	/^    uint16_t,$/;"	t	struct:btree::btree_common_params
uio_cnt	rados/rgw_file.h	/^  uint32_t uio_cnt;$/;"	m	struct:rgw_uio
uio_flags	rados/rgw_file.h	/^  uint32_t uio_flags;$/;"	m	struct:rgw_uio
uio_offset	rados/rgw_file.h	/^  uint64_t uio_offset;$/;"	m	struct:rgw_uio
uio_p1	rados/rgw_file.h	/^  void *uio_p1;$/;"	m	struct:rgw_uio
uio_rele	rados/rgw_file.h	/^  rgw_uio_release uio_rele;$/;"	m	struct:rgw_uio
uio_resid	rados/rgw_file.h	/^  uint64_t uio_resid;$/;"	m	struct:rgw_uio
uio_u1	rados/rgw_file.h	/^  void *uio_u1;$/;"	m	struct:rgw_uio
uio_vio	rados/rgw_file.h	/^  struct rgw_vio *uio_vio; \/* appended vectors *\/$/;"	m	struct:rgw_uio	typeref:struct:rgw_uio::rgw_vio
union_insert	interval_set.h	/^  void union_insert(T off, T len) {$/;"	f	class:interval_set
union_of	interval_set.h	/^  void union_of(const interval_set &a, const interval_set &b) {$/;"	f	class:interval_set
union_of	interval_set.h	/^  void union_of(const interval_set &b) {$/;"	f	class:interval_set
union_shards	rados/rados_types.hpp	/^  err_t union_shards;$/;"	m	struct:inconsistent_obj_t
unlock	Spinlock.h	/^  void unlock() const {$/;"	f	class:Spinlock
unsupported	CompatSet.h	/^  CompatSet unsupported(CompatSet& other) {$/;"	f	struct:CompatSet
unused	rados.h	/^			__le64 unused;$/;"	m	struct:ceph_osd_op::__anon13::__anon21
unused	rados/librados.hpp	/^    time_t *unused;$/;"	m	class:librados::ObjectWriteOperation
unused	rbd_types.h	/^		__u8 unused;$/;"	m	struct:rbd_obj_header_ondisk::__anon32
up	rbd/librbd.h	/^  bool up;$/;"	m	struct:__anon83
up	rbd/librbd.hpp	/^    bool up;$/;"	m	struct:librbd::__anon73
update	buffer.h	/^    void update(const buffer::list& bl) {$/;"	f	class:ceph::CEPH_BUFFER_API::hash
update	rados/buffer.h	/^    void update(const buffer::list& bl) {$/;"	f	class:ceph::CEPH_BUFFER_API::hash
upper_bound	compact_map.h	/^  const_iterator upper_bound(const Key& k) const {$/;"	f	class:compact_map_base
upper_bound	compact_map.h	/^  iterator upper_bound(const Key& k) {$/;"	f	class:compact_map_base
upper_bound	compact_set.h	/^  const_iterator upper_bound(const T& t) const {$/;"	f	class:compact_set_base
upper_bound	compact_set.h	/^  iterator upper_bound(const T& t) {$/;"	f	class:compact_set_base
upper_bound	cpp-btree/btree.h	/^  const_iterator upper_bound(const key_type &key) const {$/;"	f	class:btree::btree
upper_bound	cpp-btree/btree.h	/^  int upper_bound(const key_type &k, const Compare &comp) const {$/;"	f	class:btree::btree_node
upper_bound	cpp-btree/btree.h	/^  iterator upper_bound(const key_type &key) {$/;"	f	class:btree::btree
upper_bound	cpp-btree/btree.h	/^  static int upper_bound(const K &k, const N &n, Compare comp)  {$/;"	f	struct:btree::btree_binary_search_plain_compare
upper_bound	cpp-btree/btree.h	/^  static int upper_bound(const K &k, const N &n, Compare comp)  {$/;"	f	struct:btree::btree_linear_search_plain_compare
upper_bound	cpp-btree/btree.h	/^  static int upper_bound(const K &k, const N &n, CompareTo comp)  {$/;"	f	struct:btree::btree_binary_search_compare_to
upper_bound	cpp-btree/btree.h	/^  static int upper_bound(const K &k, const N &n, CompareTo comp)  {$/;"	f	struct:btree::btree_linear_search_compare_to
upper_bound	cpp-btree/btree_container.h	/^  const_iterator upper_bound(const key_type &key) const {$/;"	f	class:btree::btree_container
upper_bound	cpp-btree/btree_container.h	/^  iterator upper_bound(const key_type &key) {$/;"	f	class:btree::btree_container
usec	utime.h	/^  long          usec() const { return tv.tv_nsec\/1000; }$/;"	f	class:utime_t
utime_t	utime.h	/^  explicit utime_t(const ceph::coarse_real_time& crt) {$/;"	f	class:utime_t
utime_t	utime.h	/^  explicit utime_t(const ceph::real_time& rt) {$/;"	f	class:utime_t
utime_t	utime.h	/^  utime_t() { tv.tv_sec = 0; tv.tv_nsec = 0; }$/;"	f	class:utime_t
utime_t	utime.h	/^  utime_t(const struct ceph_timespec &v) {$/;"	f	class:utime_t
utime_t	utime.h	/^  utime_t(const struct timespec v)$/;"	f	class:utime_t
utime_t	utime.h	/^  utime_t(const struct timeval &v) {$/;"	f	class:utime_t
utime_t	utime.h	/^  utime_t(const struct timeval *v) {$/;"	f	class:utime_t
utime_t	utime.h	/^  utime_t(time_t s, int n) { tv.tv_sec = s; tv.tv_nsec = n; normalize(); }$/;"	f	class:utime_t
utime_t	utime.h	/^class utime_t {$/;"	c
uuid	rbd/librbd.h	/^  char *uuid;$/;"	m	struct:__anon79
uuid	rbd/librbd.hpp	/^    std::string uuid;$/;"	m	struct:librbd::__anon71
uuid	uuid.h	/^  boost::uuids::uuid uuid;$/;"	m	struct:uuid_d
uuid_d	uuid.h	/^  uuid_d() {$/;"	f	struct:uuid_d
uuid_d	uuid.h	/^struct uuid_d {$/;"	s
v	Distribution.h	/^  vector<int> v;$/;"	m	class:Distribution
v	byteorder.h	/^  T v;$/;"	m	struct:ceph_le
v	types.h	/^  float v;$/;"	m	struct:weightf_t
v	types.h	/^  int64_t v;$/;"	m	struct:client_t
v	types.h	/^  uint64_t v;$/;"	m	struct:byte_u_t
v	types.h	/^  uint64_t v;$/;"	m	struct:si_u_t
val	Context.h	/^  T val;$/;"	m	struct:Wrapper
val	cephfs/libcephfs.h	/^  uint64_t val;$/;"	m	struct:_snapid_t
val	cephfs/libcephfs.h	/^  uint64_t val;$/;"	m	struct:inodeno_t
val	fs_types.h	/^  _inodeno_t val;$/;"	m	struct:inodeno_t
val	object.h	/^  uint64_t val;$/;"	m	struct:snapid_t
value	cpp-btree/btree.h	/^  const_reference value(int i) const {$/;"	f	class:btree::btree_node
value	cpp-btree/btree.h	/^  reference value(int i) {$/;"	f	class:btree::btree_node
value	denc.h	/^    static constexpr bool value = decltype($/;"	m	class:_denc::container_has_reserve
value	frag.h	/^  unsigned value() const { return ceph_frag_value(_enc); }$/;"	f	class:frag_t
value_destroy	cpp-btree/btree.h	/^  void value_destroy(int i) {$/;"	f	class:btree::btree_node
value_init	cpp-btree/btree.h	/^  void value_init(int i) {$/;"	f	class:btree::btree_node
value_init	cpp-btree/btree.h	/^  void value_init(int i, const value_type &x) {$/;"	f	class:btree::btree_node
value_len	rados.h	/^			__le32 value_len;$/;"	m	struct:ceph_osd_op::__anon13::__anon15
value_swap	cpp-btree/btree.h	/^  void value_swap(int i, btree_node *x, int j) {$/;"	f	class:btree::btree_node
value_type	cpp-btree/btree.h	/^  typedef Key value_type;$/;"	t	struct:btree::btree_set_params
value_type	cpp-btree/btree.h	/^  typedef std::pair<const Key, data_type> value_type;$/;"	t	struct:btree::btree_map_params
value_type	cpp-btree/btree.h	/^  typedef typename Params::value_type value_type;$/;"	t	class:btree::btree
value_type	cpp-btree/btree.h	/^  typedef typename Params::value_type value_type;$/;"	t	class:btree::btree_node
value_type	cpp-btree/btree.h	/^  typedef typename params_type::value_type value_type;$/;"	t	struct:btree::btree_iterator
value_type	cpp-btree/btree_container.h	/^  typedef typename Tree::value_type value_type;$/;"	t	class:btree::btree_container
value_type	cpp-btree/btree_container.h	/^  typedef typename Tree::value_type value_type;$/;"	t	class:btree::btree_map_container
value_type	cpp-btree/btree_container.h	/^  typedef typename Tree::value_type value_type;$/;"	t	class:btree::btree_multi_container
value_type	cpp-btree/btree_container.h	/^  typedef typename Tree::value_type value_type;$/;"	t	class:btree::btree_unique_container
value_type	mempool.h	/^  typedef T value_type;$/;"	t	class:mempool::pool_allocator
value_type	xlist.h	/^  typedef item* value_type;$/;"	t	class:xlist
values	cpp-btree/btree.h	/^    mutable_value_type values[kNodeValues];$/;"	m	struct:btree::btree_node::leaf_fields
ver	rados.h	/^			__le64 ver;     \/* no longer used *\/$/;"	m	struct:ceph_osd_op::__anon13::__anon19
ver	rados.h	/^			__le64 ver;$/;"	m	struct:ceph_osd_op::__anon13::__anon21
verify	cpp-btree/btree_container.h	/^  void verify() const {$/;"	f	class:btree::btree_container
version	ceph_fs.h	/^	__le16 version;$/;"	m	struct:ceph_mds_request_head
version	ceph_fs.h	/^	__le64 version;$/;"	m	struct:ceph_mon_statfs_reply
version	msgr.h	/^	__le16 version;   \/* version of message encoding *\/$/;"	m	struct:ceph_msg_header
version	msgr.h	/^	__le16 version;   \/* version of message encoding *\/$/;"	m	struct:ceph_msg_header_old
version	rados.h	/^	__le64 version;$/;"	m	struct:ceph_eversion
version	rados/rados_types.hpp	/^  uint64_t version;  \/\/ XXX: Redundant with object info attr$/;"	m	struct:inconsistent_obj_t
version	rbd_types.h	/^	char version[8];$/;"	m	struct:rbd_obj_header_ondisk
version_t	types.h	/^typedef uint64_t version_t;$/;"	t
vinodeno	cephfs/libcephfs.h	/^typedef struct vinodeno_t vinodeno;$/;"	t	typeref:struct:vinodeno_t
vinodeno_t	cephfs/libcephfs.h	/^typedef struct vinodeno_t {$/;"	s
vinodeno_t	cephfs/libcephfs.h	/^} vinodeno_t;$/;"	t	typeref:struct:vinodeno_t
vio_base	rados/rgw_file.h	/^  void *vio_base;$/;"	m	struct:rgw_vio
vio_len	rados/rgw_file.h	/^  int32_t vio_len;$/;"	m	struct:rgw_vio
vio_p1	rados/rgw_file.h	/^  void *vio_p1;$/;"	m	struct:rgw_vio
vio_u1	rados/rgw_file.h	/^  void *vio_u1;$/;"	m	struct:rgw_vio
wait	ceph_fs.h	/^		__u8 wait; \/* will caller wait for lock to become available? *\/$/;"	m	struct:ceph_mds_request_args::__anon64
wait	ceph_fs.h	/^		__u8 wait; \/* will caller wait for lock to become available? *\/$/;"	m	struct:ceph_mds_request_args_legacy::__anon55
waitfor	Context.h	/^  std::set<ContextType*> waitfor;$/;"	m	class:C_GatherBase
wanted	ceph_fs.h	/^	__le32 caps, wanted, dirty; \/* latest issued\/wanted\/dirty *\/$/;"	m	struct:ceph_mds_caps_head
wanted	ceph_fs.h	/^	__le32 caps, wanted;           \/* caps issued, wanted *\/$/;"	m	struct:ceph_mds_reply_cap
wanted	ceph_fs.h	/^	__le32 caps, wanted;           \/* new issued, wanted *\/$/;"	m	struct:ceph_mds_request_release
wanted	ceph_fs.h	/^	__le32 wanted;$/;"	m	struct:ceph_mds_cap_reconnect
wanted	ceph_fs.h	/^	__le32 wanted;$/;"	m	struct:ceph_mds_cap_reconnect_v1
watch	rados.h	/^		} __attribute__ ((packed)) watch;$/;"	m	union:ceph_osd_op::__anon13	typeref:struct:ceph_osd_op::__anon13::__anon19
watcher_id	rados/rados_types.h	/^  int64_t watcher_id;$/;"	m	struct:obj_watch_t
weightf_t	types.h	/^  weightf_t(float _v) : v(_v) {}$/;"	f	struct:weightf_t
weightf_t	types.h	/^struct weightf_t {$/;"	s
writeable	CompatSet.h	/^  bool writeable(CompatSet const& other) const {$/;"	f	struct:CompatSet
writesame	rados.h	/^		} __attribute__ ((packed)) writesame;$/;"	m	union:ceph_osd_op::__anon13	typeref:struct:ceph_osd_op::__anon13::__anon28
xattr	rados.h	/^		} __attribute__ ((packed)) xattr;$/;"	m	union:ceph_osd_op::__anon13	typeref:struct:ceph_osd_op::__anon13::__anon15
xattr_len	ceph_fs.h	/^	__le32 xattr_len;$/;"	m	struct:ceph_mds_caps_head
xattr_version	ceph_fs.h	/^	__le64 xattr_version;$/;"	m	struct:ceph_mds_caps_head
xlist	xlist.h	/^  xlist() : _front(0), _back(0), _size(0) {}$/;"	f	class:xlist
xlist	xlist.h	/^  xlist(const xlist& other) {$/;"	f	class:xlist
xlist	xlist.h	/^class xlist {$/;"	c
~C_GatherBuilderBase	Context.h	/^  ~C_GatherBuilderBase() {$/;"	f	class:C_GatherBuilderBase
~Context	Context.h	/^  virtual ~Context() {}       \/\/ we want a virtual destructor!!!$/;"	f	class:Context
~Counter	counter.h	/^  ~Counter() {$/;"	f	class:Counter
~GenContext	Context.h	/^  virtual ~GenContext() {}       \/\/ we want a virtual destructor!!!$/;"	f	class:GenContext
~LRUObject	lru.h	/^inline LRUObject::~LRUObject() {$/;"	f	class:LRUObject
~Locker	Spinlock.h	/^    ~Locker() {$/;"	f	class:Spinlock::Locker
~ObjectOperationCompletion	rados/librados.hpp	/^    virtual ~ObjectOperationCompletion() {}$/;"	f	class:librados::ObjectOperationCompletion
~OnExitManager	on_exit.h	/^    ~OnExitManager() {$/;"	f	class:OnExitManager
~PrCtl	coredumpctl.h	/^  ~PrCtl() {$/;"	f	struct:PrCtl
~RunOnDelete	Context.h	/^  ~RunOnDelete() {$/;"	f	struct:RunOnDelete
~Spinlock	Spinlock.h	/^  ~Spinlock() {$/;"	f	class:Spinlock
~UpdateWatchCtx	rbd/librbd.hpp	/^  virtual ~UpdateWatchCtx() {}$/;"	f	class:librbd::UpdateWatchCtx
~btree	cpp-btree/btree.h	/^  ~btree() {$/;"	f	class:btree::btree
~compact_map_base	compact_map.h	/^  ~compact_map_base() {}$/;"	f	class:compact_map_base
~compact_set_base	compact_set.h	/^  ~compact_set_base() {}$/;"	f	class:compact_set_base
~contiguous_appender	buffer.h	/^      ~contiguous_appender() {$/;"	f	class:ceph::CEPH_BUFFER_API::list::contiguous_appender
~contiguous_appender	rados/buffer.h	/^      ~contiguous_appender() {$/;"	f	class:ceph::CEPH_BUFFER_API::list::contiguous_appender
~elist	elist.h	/^  ~elist() { $/;"	f	class:elist
~item	elist.h	/^    ~item() { $/;"	f	struct:elist::item
~item	xlist.h	/^    ~item() { $/;"	f	struct:xlist::item
~page_aligned_appender	buffer.h	/^      ~page_aligned_appender() {$/;"	f	class:ceph::CEPH_BUFFER_API::list::page_aligned_appender
~page_aligned_appender	rados/buffer.h	/^      ~page_aligned_appender() {$/;"	f	class:ceph::CEPH_BUFFER_API::list::page_aligned_appender
~ptr	buffer.h	/^    ~ptr() {$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
~ptr	rados/buffer.h	/^    ~ptr() {$/;"	f	class:ceph::CEPH_BUFFER_API::ptr
~scope_guard	scope_guard.h	/^  ~scope_guard() {$/;"	f	struct:scope_guard
~xlist	xlist.h	/^  ~xlist() { $/;"	f	class:xlist
